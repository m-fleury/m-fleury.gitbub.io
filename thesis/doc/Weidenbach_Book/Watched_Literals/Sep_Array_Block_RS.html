<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Sep_Array_Block_RS (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Sep_Array_Block_RS</h1>

<span class="command">theory</span> <span class="name">Sep_Array_Block_RS</span><br/>
<span class="keyword">imports</span> <a href="Sep_Block_Allocator_RS.html"><span class="name">Sep_Block_Allocator_RS</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Array-Blocks --- Reasoning Setup&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Sep_Array_Block_RS</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;../basic/LLVM_Basic_Main&quot;</span></span></span><span> </span><span>Sep_Block_Allocator_RS</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;aval</span><span> </span><span>ablock</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; &#39;aval&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>baddr</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>this_addr</span><span class="delimiter">)</span><span> </span><span>addr_algebra</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase &#8801; &#955;BADDR i va &#8658; va=this_addr&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(~<span class="hidden">&#8681;</span><sub>a</sub>) &#8801; &#955;BADDR i1 va1 &#8658; &#955;BADDR i2 va2 &#8658; va1=this_addr &#8743; va2=this_addr&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(-<span class="hidden">&#8681;</span><sub>a</sub>) &#8801; &#955;BADDR i1 va1 &#8658; &#955;BADDR i2 va2 &#8658; i1 - i2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(+<span class="hidden">&#8681;</span><sub>a</sub>) &#8801; &#955;BADDR i va &#8658; &#955;j. BADDR (i+j) va&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>abase_baddr_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase (BADDR i va) &#10231; va=this_addr&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>abase_baddr_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>acompat_baddr_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;BADDR i1 va1 ~<span class="hidden">&#8681;</span><sub>a</sub> BADDR i2 va2 &#10231; va1=this_addr &#8743; va2=this_addr&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>acompat_baddr_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adiff_baddr_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;BADDR i1 va1 -<span class="hidden">&#8681;</span><sub>a</sub> BADDR i2 va2 = i1 - i2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>adiff_baddr_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aidx_baddr_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;BADDR i va +<span class="hidden">&#8681;</span><sub>a</sub> j = BADDR (i+j) va&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>aidx_baddr_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>part_equivpI</span><span> </span><span>sympI</span><span> </span><span>transpI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>abase_baddr_def</span><span> </span><span>acompat_baddr_def</span><span> </span><span>adiff_baddr_def</span><span> </span><span>aidx_baddr_def</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>baddr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>array_block2</span><span> </span><span class="delimiter">=</span><span> </span><span>array_block1</span><span> </span><span>static_err</span><span> </span><span>mem_err</span><span> </span><span>vload</span><span> </span><span>vstore</span><span> </span><span>vgep</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>static_err</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;err</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mem_err</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;err</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vload</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;vaddr::this_addr &#8658; (&#39;val,_,&#39;val,&#39;err) M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vstore</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;val &#8658; &#39;vaddr &#8658; (unit,_,&#39;val,&#39;err) M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vgep</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;vaddr &#8658; &#39;vidx &#8658; (&#39;vaddr,_,&#39;val,&#39;err) M&quot;</span></span></span><span>
</span><span>    
</span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>&#945;v</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;val &#8658; &#39;aval::unique_zero_sep_algebra&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vpto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;val &#8658; &#39;vaddr &#8658; &#39;aval &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vcomplete</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;aval &#8658; bool&quot;</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>vload_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple &#945;v (vpto x va) (vload va) (&#955;r. &#8593;(r=x) ** vpto x va)&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vstore_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple &#945;v (vpto xx va) (vstore x va) (&#955;_. vpto x va)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vpto_notZ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x a. &#172;vpto x a 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vcompleteD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;v v&#39;. &#10214;vcomplete v; v##v&#39;&#10215; &#10233; v&#39;=0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vpto_this</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;v av. vpto v this_addr av &#10231; av = &#945;v v&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#945;v_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;v. vcomplete (&#945;v v)&quot;</span></span></span><span>
</span><span>      
</span><span>      
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  lemma is_arr_baddr_idx[simp]: &quot;is_arr_baddr (idx_baddr a i) &#10231; is_arr_baddr a&quot;
    by (auto simp: is_arr_baddr_def idx_baddr_def split: baddr.splits)
  
  lemma idx_baddr_add[simp]: &quot;idx_baddr (idx_baddr a i) j = idx_baddr a (i+j)&quot;
    by (auto simp: idx_baddr_def split: prod.splits baddr.splits)
    
  definition &quot;idx_ptr &#8801; &#955;RP_ADDR (ADDR bi ba) &#8658; &#955;i. RP_ADDR (ADDR bi (idx_baddr ba i)) | RP_NULL &#8658; &#955;i. RP_NULL&quot;
  *)</span></span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Rename to is_block_ptr! *)</span></span></span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_block_ptr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;vaddr baddr addr rptr &#8658; bool&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_block_ptr &#8801; &#955;RP_ADDR (ADDR bi ba) &#8658; ba=this_addr | _ &#8658; False&quot;</span></span></span><span>
</span><span>  
</span><span>  
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*definition &quot;is_arr_ptr &#8801; &#955;RP_ADDR (ADDR bi ba) &#8658; is_arr_baddr ba | _ &#8658; False&quot;*)</span></span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 
  lemma is_arr_ptr_simps[simp]:
    &quot;is_arr_ptr (RP_ADDR (ADDR bi ba)) = is_arr_baddr ba&quot;    
    &quot;is_arr_ptr RP_NULL &#10231; False&quot;
    by (auto simp: is_arr_ptr_def)
  *)</span></span></span></span></span><span>
</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_block_ptr_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;is_block_ptr RP_NULL&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;is_block_ptr (RP_ADDR (ADDR bi ba)) &#10231; ba=this_addr&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_block_ptr_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>block_ptr_imp_abase</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_block_ptr p &#10233; abase p&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_block_ptr_def</span><span> </span><span>this_addr_baddr_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>rptr.splits</span><span> </span><span>addr.splits</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  
  lemma idx_ptr_add[simp]: &quot;idx_ptr (idx_ptr a i) j = idx_ptr a (i+j)&quot;
    by (auto simp: idx_ptr_def split: rptr.splits addr.splits)
    
  lemma is_arr_ptr_idx[simp]: &quot;is_arr_ptr (idx_ptr p i) &#10231; is_arr_ptr p&quot;
    by (cases p) (auto simp: idx_ptr_def is_arr_ptr_def split: rptr.splits addr.splits)
  *)</span></span></span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>&#945;v_notZ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945;v v &#8800; 0&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vpto_notZ</span><span> </span><span>vpto_this</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945; &#8801; list&#945; &#945;v&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;val &#8658; &#39;vaddr baddr &#8658; &#39;aval ablock &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pto &#8801; &#955;x. &#955;BADDR i va &#8658; &#955;s. &#8707;v. i&#8805;0 &#8743; s=0(nat i:=v) &#8743; vpto x va v&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tag_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;val block &#8658; int&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tag_of &#8801; int o length&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_complete_tag ablk n &#8801; 0&#8804;n &#8743; (&#8704;i. (ablk i &#8800; 0 &#10231; i&lt;nat n) &#8743; (&#8704;i. ablk i &#8800; 0 &#10230; vcomplete (ablk i)))&quot;</span></span></span><span>
</span><span>    
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;array_lifter i &#8801; idx_lifter (&#955;_. ()) &#945;v i&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_lifter_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.&#945;s (array_lifter i) = &#945;v&quot;</span></span></span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.&#945;b (array_lifter i) = &#945;&quot;</span></span></span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.L (array_lifter i) = idx<span class="hidden">&#8681;</span><sub>L</sub> i&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_lifter_def</span><span> </span><span>&#945;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>array_lifter</span><span class="delimiter">:</span><span> </span><span>sep_lifter</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;array_lifter i&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_lifter_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pto_is_lift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pto x = (&#955;BADDR i va &#8658; (&#8593;(i&#8805;0) ** array_lifter.lift_assn (nat i) (vpto x va)))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_lifter.lift_assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>array_lifter_def</span><span> </span><span>pto_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>baddr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fun_upd_triv</span><span> </span><span>fun_upd_upd</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_is_pto</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&#8805;0 &#10233; array_lifter.lift_assn (nat i) (vpto x va) = pto x (BADDR i va)&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pto_is_lift</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>vpto_notZ</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>  
</span><span>    
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>load_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple &#945; (pto x va) (load va) (&#955;r. &#8593;(r=x) ** pto x va)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>load_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>pto_is_lift</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>va</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>htriple_extract_pre_pure</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>array_lifter.lift_operation</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>vload_rule</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>store_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple &#945; (pto xx va) (store x va) (&#955;_. pto x va)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>store_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>pto_is_lift</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>va</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>htriple_extract_pre_pure</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>array_lifter.lift_operation</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>vstore_rule</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>load_pres_tag</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wlp (load a) (&#955;_ s&#39;. tag_of s&#39; = tag_of s) s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>load_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wlp_def</span><span> </span><span>run_simps</span><span> </span><span>tag_of_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>option.splits</span><span> </span><span>baddr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mwp_trivI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>store_pres_tag</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wlp (store a x) (&#955;_ s&#39;. tag_of s&#39; = tag_of s) s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>store_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wlp_def</span><span> </span><span>run_simps</span><span> </span><span>tag_of_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>option.splits</span><span> </span><span>baddr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mwp_trivI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>complete_tag</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;is_complete_tag ablock (tag_of cblock); ablock ## f; &#945; cblock = ablock + f&#10215; &#10233; f = 0&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_complete_tag_def</span><span> </span><span>tag_of_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>&#945;_def</span><span> </span><span>disjoint_zero_sym</span><span> </span><span>list&#945;_in_range</span><span> </span><span>sep_add_disj_eq</span><span> </span><span>sep_disj_fun_def</span><span> </span><span>sep_disj_zero</span><span> </span><span>unique_zero</span><span> </span><span>vcompleteD</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Z_upd_eq_Z_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0(i:=x) = 0 &#10231; x=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pto_notZ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; pto x a 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pto_def</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checked_idx_baddr_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase a 
    &#10233; htriple &#945; (pto xx (a +<span class="hidden">&#8681;</span><sub>a</sub> i)) (checked_idx_baddr a i) (&#955;r. &#8593;(r=a +<span class="hidden">&#8681;</span><sub>a</sub> i) ** pto xx (a +<span class="hidden">&#8681;</span><sub>a</sub> i))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>htripleI&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>checked_idx_baddr_def</span><span> </span><span>check_addr_def</span><span> </span><span>pto_is_lift</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>baddr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>array_lifter.infer_pre_get_with_frame</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wp_def</span><span> </span><span>run_simps</span><span> </span><span>aidx_baddr_def</span><span> </span><span>abase_baddr_def</span><span> </span><span>sep_algebra_simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>baddr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>ba</span><span class="delimiter">:</span><span> </span><span>block_allocator2</span><span> </span><span>static_err</span><span> </span><span>mem_err</span><span> </span><span>load</span><span> </span><span>store</span><span> </span><span>check_addr</span><span> </span><span>&#945;</span><span> </span><span>pto</span><span> </span><span>tag_of</span><span> </span><span>is_complete_tag</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>load_rule</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>store_rule</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>load_pres_tag</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>store_pres_tag</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>complete_tag</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>pto_notZ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>       
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list&#945;_rep_nn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;list&#945; &#945;v (replicate n v) n = 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pto_this_exact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pto x (BADDR i this_addr) = (&#8593;(i&#8805;0) ** EXACT (0(nat i:=&#945;v x)))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pto_def</span><span> </span><span>vpto_this</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ba_pto_this_exact</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;is_block_ptr p; i&#8805;0&#10215; 
    &#10233; ba.pto x (p +<span class="hidden">&#8681;</span><sub>a</sub> i) = EXACT (0(rptr_the_block_index p := (0(nat i:=&#945;v x),0)))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ba.pto_def</span><span> </span><span>aidx_baddr_def</span><span> </span><span>pto_this_exact</span><span> </span><span>this_addr_baddr_def</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>is_block_ptr_def</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>rptr.splits</span><span> </span><span>addr.splits</span><span> </span><span>baddr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_pto_exact</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&#8805;0 &#10233; ba.block_lifter.lift_assn bi (pto v (this_addr +<span class="hidden">&#8681;</span><sub>a</sub> i)) = EXACT (0(bi := (0(nat i:=&#945;v v),0)))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span>  </span><span>aidx_baddr_def</span><span> </span><span>pto_this_exact</span><span> </span><span>this_addr_baddr_def</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>is_block_ptr_def</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>rptr.splits</span><span> </span><span>addr.splits</span><span> </span><span>baddr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atLeast_lessThan_plus1</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;l&#8804;v &#10233; {l..&lt;1+v::int} = insert v {l..&lt;v}&quot;</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;l&#8804;v &#10233; {l..&lt;v+1::int} = insert v {l..&lt;v}&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sep_set_img_int_range_to_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;*i&#8712;{0..&lt;int n}. f i) = (&#8899;*i&#8712;{0..&lt;n}. f (int i))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atLeast_lessThan_plus1</span><span> </span><span>atLeast0_lessThan_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ba_block_alt</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;ba.block (&#945; (init v n)) p = (&#8593;(is_block_ptr p) ** (&#8899;*i&#8712;{0..&lt;int n}. ba.pto v (p +<span class="hidden">&#8681;</span><sub>a</sub> i)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ba_block_alt_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;*i&#8712;{0..&lt;int n}. EXACT (0(x1 := (0(nat i := &#945;v v), 0)))) = EXACT (0(x1 := (list&#945; &#945;v (replicate n v), 0)))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>replicate_Suc_conv_snoc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>replicate_Suc</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_snoc</span><span> </span><span>sep_algebra_simps</span><span> </span><span>sep_disj_fun_def</span><span> </span><span>atLeast0_lessThan_Suc</span><span> </span><span>atLeast_lessThan_plus1</span><span> </span><span>sep_conj_def</span><span> </span><span>list&#945;_rep_nn</span><span>
</span><span>          </span><span>cong</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span> 
</span><span>          </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>foo</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P=Q; Q &#10233; X=Y&#10215; &#10233; (&#8593;P**X) = (&#8593;Q**Y)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>X</span><span> </span><span>Y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;*x&#8712;{0..&lt;int n}. ba.pto v ((RP_ADDR (ADDR x1 (this_addr +<span class="hidden">&#8681;</span><sub>a</sub> x))))) 
      = (&#8899;*x&#8712;{0..&lt;int n}. EXACT (0(x1 := (0(nat x := &#945;v v), 0))))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sep_set_img_cong</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lift_pto_exact</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>ba.pto_addr_eq</span><span>  
</span><span>      
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_def</span><span> </span><span>ba.block_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>rptr.splits</span><span> </span><span>addr.splits</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>&#945;_def</span><span> </span><span>ba_block_alt_aux</span><span> 
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>foo</span><span>
</span><span>        </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ba_block_exs_alt_aux</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8805;0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;*i&#8712;{0..&lt;n}. (EXS x. ba.pto x ((RP_ADDR (ADDR bi (this_addr +<span class="hidden">&#8681;</span><sub>a</sub> i)))))) 
      = (EXS xs. &#8593;(int (length xs) = n) ** EXACT (0(bi := (list&#945; &#945;v xs, 0))))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>int_induct</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>0</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step1</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0&#8804;n&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>step1.IH</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n+1&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0&#8804;n&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>replicate_Suc_conv_snoc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>replicate_Suc</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>atLeast_lessThan_plus1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>IH</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>sep_disj_fun_def</span><span> </span><span>sep_conj_def</span><span> </span><span>list&#945;_at_len</span><span> </span><span>lift_pto_exact</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xs</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;xs@[x]&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_snoc</span><span> </span><span>sep_algebra_simps</span><span> </span><span>list&#945;_at_len</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>this_addr_baddr_def</span><span> </span><span>pto_this_exact</span><span>
</span><span>        </span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;last xs&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;butlast xs&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_gt_len</span><span> </span><span>sep_algebra_simps</span><span> </span><span>list&#945;_snoc</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>    
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step2</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ba_block_exs_alt</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;is_block_ptr p; n&#8805;0&#10215; &#10233; (&#8899;*i&#8712;{0..&lt;n}. EXS v. ba.pto v (p +<span class="hidden">&#8681;</span><sub>a</sub> i)) = (EXS blk. &#8593;(int (length blk) = n) ** ba.block (&#945; blk) p)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_def</span><span> </span><span>ba.block_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>ba.pto_addr_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>ba.rptr_cases.cases</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>rptr.splits</span><span> </span><span>addr.splits</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>&#945;_def</span><span> </span><span>ba_block_exs_alt_aux</span><span>
</span><span>      </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tag_of_init</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tag_of (init v n) = int n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tag_of_def</span><span> </span><span>init_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ba_allocn_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple ba.&#945; &#9633; (ba_allocn v n) (&#955;r. (&#8899;*i&#8712;{0..&lt;int n}. ba.pto v (r +<span class="hidden">&#8681;</span><sub>a</sub> i)) ** ba.tag (int n) r ** &#8593;(abase r))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ba_allocn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cons_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ba.alloc_rule</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ba_block_alt</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to gen_wp locale *)</span></span></span></span></span><span>          
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wp_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wp c Q s &#10233; (&#8896;x s. Q x s &#10233; Q&#39; x s) &#10233; wp c Q&#39; s&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wp_monoI</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blk_complete_tag</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_complete_tag (&#945; blk) (int (length blk))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_complete_tag_def</span><span> </span><span>&#945;_def</span><span> </span><span>list&#945;_def</span><span> </span><span>&#945;v_complete</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: is_base_ptr: This logic is already encoded in ba.tag! Try to get rid of is_base_ptr! *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ba_tag_extr_baseptr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ba.tag n p = (&#8593;(is_block_ptr p &#8743; 0&#8804;n) ** ba.tag n p)&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ba.tag_def</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>addr.splits</span><span> </span><span>rptr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tag_of_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ba_freen_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple ba.&#945; ((&#8899;*i&#8712;{0..&lt;n}. EXS v. ba.pto v (p+<span class="hidden">&#8681;</span><sub>a</sub>i)) &#8743;* ba.tag n p) (ba.free p) (&#955;_. &#9633;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ba_tag_extr_baseptr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>htripleI&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ba_block_exs_alt</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pp</span><span> </span><span>s</span><span> </span><span>f</span><span> </span><span>blk</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>R</span><span> </span><span class="delimiter">=</span><span> </span><span>ba.free_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945; blk&quot;</span></span></span><span> </span><span>p</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int (length blk)&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>R</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>htripleD&#39;</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>wp_cons</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checked_idx_baddr_pres_tag</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wlp (checked_idx_baddr (BADDR a b) i) (&#955;_ s&#39;. tag_of s&#39; = tag_of sa) sa&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wlp_def</span><span> </span><span>checked_idx_baddr_def</span><span> </span><span>check_addr_def</span><span> </span><span>run_simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>baddr.splits</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>return_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple &#945; P (return x) (&#955;r. &#8593;(r=x)**P)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>&#945;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>    
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wlp_return</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wlp (return x) Q s = Q x s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>wlp_def</span><span> </span><span>run_simps</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>checked_idx_ptr_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase p 
    &#10233; htriple ba.&#945; (ba.pto xx (p +<span class="hidden">&#8681;</span><sub>a</sub> i)) (checked_idx_ptr p i) (&#955;r. &#8593;(r=p +<span class="hidden">&#8681;</span><sub>a</sub> i) ** ba.pto xx (p +<span class="hidden">&#8681;</span><sub>a</sub> i))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>checked_idx_ptr_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>ba.rptr_cases.cases</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zoom_bind</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>ba.block_lifter.lift_operation</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>checked_idx_baddr_rule</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>ba.block_lifter.lift_operation</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>return_rule</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>pto_notZ</span><span> </span><span>checked_idx_baddr_pres_tag</span><span> </span><span>abase_baddr_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>fri_prepare_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>aidx_baddr_simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>baddr.splits</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


