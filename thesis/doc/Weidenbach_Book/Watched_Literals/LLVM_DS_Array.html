<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory LLVM_DS_Array (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory LLVM_DS_Array</h1>

<span class="command">theory</span> <span class="name">LLVM_DS_Array</span><br/>
<span class="keyword">imports</span> <a href="LLVM_DS_Arith.html"><span class="name">LLVM_DS_Arith</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Arrays&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>LLVM_DS_Array</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>LLVM_DS_Arith</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Implementing Lists by Arrays&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>llvm_prim_mem_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;array_assn &#8801; mk_assn (&#955;xs p. 
    &#8639;(ll_range {0..&lt;int (length xs)}) ((!) xs o nat) p ** ll_malloc_tag (int (length xs)) p
  )&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_assn_not_null</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8639;array_assn xs null = sep_false&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>array_assn_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;array_new TYPE(&#39;a::llvm_rep) n &#8801; ll_malloc TYPE(&#39;a) n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;array_free a &#8801; ll_free a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;array_nth a i &#8801; doM { p &#8592; ll_ofs_ptr a i; ll_load p }&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;array_upd a i x &#8801; doM { p &#8592; ll_ofs_ptr a i; ll_store x p; return a }&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_range_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;I=I&#39; &#10233; (&#8896;i. i&#8712;I&#39; &#10233; f i = f&#39; i) &#10233; p=p&#39; 
    &#10233; &#8639;(ll_range I) f p = &#8639;(ll_range I&#39;) f&#39; p&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ll_range_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_assn_cnv_range_malloc</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8639;array_assn (replicate n init) p = (&#8639;(ll_range {0..&lt;int n}) (&#955;_. init) p ** ll_malloc_tag (int n) p)&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sep_conj_trivial_strip2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ll_range_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_assn_cnv_range_upd</span><span class="delimiter">:</span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8639;array_assn (xs[i:=x]) p = (&#8639;(ll_range {0..&lt;int (length xs)}) (((!) xs &#8728; nat)(int i := x)) p ** ll_malloc_tag (int (length xs)) p)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sep_conj_trivial_strip2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ll_range_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pos_sint_to_uint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&#8804;sint i &#10233; sint i = uint i&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Suc_n_not_le_n</span><span> </span><span>Suc_pred</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>int_mod_eq&#39;</span><span> </span><span>len_gt_0</span><span> </span><span>power_increasing_iff</span><span> </span><span>sint_range&#39;</span><span> </span><span>uint_sint</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_new_rule_sint</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
    (&#8639;sint.assn n ni ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(n&gt;0)) 
    (array_new TYPE(&#39;a::llvm_rep) ni) 
    (&#8639;array_assn (replicate (nat n) init))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_new_def</span><span> </span><span>array_assn_cnv_range_malloc</span><span> </span><span>sint.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>pos_sint_to_uint</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_new_rule_uint</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
    (&#8639;uint.assn n ni ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(n&gt;0)) 
    (array_new TYPE(&#39;a::llvm_rep) ni) 
    (&#8639;array_assn (replicate (nat n) init))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_new_def</span><span> </span><span>array_assn_cnv_range_malloc</span><span> </span><span>uint.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_new_rule_unat</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
    (&#8639;unat.assn n ni ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(n&gt;0)) 
    (array_new TYPE(&#39;a::llvm_rep) ni) 
    (&#8639;array_assn (replicate n init))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_new_def</span><span> </span><span>array_assn_cnv_range_malloc</span><span> </span><span>unat.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unat_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_new_rule_snat</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
    (&#8639;snat.assn n ni ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(n&gt;0)) 
    (array_new TYPE(&#39;a::llvm_rep) ni) 
    (&#8639;array_assn (replicate n init))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_new_def</span><span> </span><span>array_assn_cnv_range_malloc</span><span> </span><span>snat.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>cnv_snat_to_uint</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>    
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_free_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#8639;array_assn xs p) (array_free p) (&#955;_. &#9633;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_free_def</span><span> </span><span>array_assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_cast_index</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint (ii::&#39;a::len word) &lt; max_sint LENGTH(&#39;a)&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint ii = uint ii&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat (uint ii) &lt; n &#10231; uint ii &lt; int n&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>max_sint_def</span><span> </span><span>msb_uint_big</span><span> </span><span>sint_eq_uint</span><span> </span><span>unat_def</span><span> </span><span>nat_less_iff</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;in_range_nat i (ii::&#39;a::len word) xs &#8801; i&lt;length xs &#8743; int i&lt;max_sint LENGTH(&#39;a)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;in_range_uint i (ii::&#39;a::len word) xs &#8801; i&lt;int (length xs) &#8743; i&lt;max_sint LENGTH(&#39;a)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_nth_rule_sint</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
    (&#8639;array_assn xs p ** &#8639;sint.assn i ii ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(0&#8804;i &#8743; i&lt;int (length xs)))
    (array_nth p ii)
    (&#955;r. &#8593;(r = xs!nat i) ** &#8639;array_assn xs p)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_nth_def</span><span> </span><span>array_assn_def</span><span> </span><span>sint.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_nth_rule_uint</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
    (&#8639;array_assn xs p ** &#8639;uint.assn i ii ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(in_range_uint i ii xs))
    (array_nth p ii)
    (&#955;r. &#8593;(r = xs!nat i) ** &#8639;array_assn xs p)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_nth_def</span><span> </span><span>array_assn_def</span><span> </span><span>uint.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>array_cast_index</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_nth_rule_unat</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
    (&#8639;array_assn xs p ** &#8639;unat.assn i ii ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(in_range_nat i ii xs))
    (array_nth p ii)
    (&#955;r. &#8593;(r = xs!i) ** &#8639;array_assn xs p)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_nth_def</span><span> </span><span>array_assn_def</span><span> </span><span>unat.assn_def</span><span> </span><span>unat_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>array_cast_index</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_nth_rule_snat</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
    (&#8639;array_assn xs p ** &#8639;snat.assn i ii ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(i&lt;length xs))
    (array_nth p ii)
    (&#955;r. &#8593;(r = xs!i) ** &#8639;array_assn xs p)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_nth_def</span><span> </span><span>array_assn_def</span><span> </span><span>snat.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>cnv_snat_to_uint</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_upd_rule_sint</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple
    (&#8639;array_assn xs p ** &#8639;sint.assn i ii ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(0&#8804;i &#8743; i &lt; int (length xs)))
    (array_upd p ii x)
    (&#955;r. &#8593;(r=p) ** &#8639;array_assn (xs[nat i:=x]) p)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_assn_cnv_range_upd</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_upd_def</span><span> </span><span>array_assn_def</span><span> </span><span>sint.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>fri_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>fri_abs_cong_rl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_upd_rule_uint</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple
    (&#8639;array_assn xs p ** &#8639;uint.assn i ii ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>in_range_uint i ii xs)
    (array_upd p ii x)
    (&#955;r. &#8593;(r=p) ** &#8639;array_assn (xs[nat i:=x]) p)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_assn_cnv_range_upd</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_upd_def</span><span> </span><span>array_assn_def</span><span> </span><span>uint.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>array_cast_index</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>fri_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>fri_abs_cong_rl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>        
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_upd_rule_nat</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple
    (&#8639;array_assn xs p ** &#8639;unat.assn i ii ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>in_range_nat i ii xs)
    (array_upd p ii x)
    (&#955;r. &#8593;(r=p) ** &#8639;array_assn (xs[i:=x]) p)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_assn_cnv_range_upd</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_upd_def</span><span> </span><span>array_assn_def</span><span> </span><span>unat.assn_def</span><span> </span><span>unat_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>array_cast_index</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>fri_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>fri_abs_cong_rl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_upd_rule_snat</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple
    (&#8639;array_assn xs p ** &#8639;snat.assn i ii ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(i&lt;length xs))
    (array_upd p ii x)
    (&#955;r. &#8593;(r=p) ** &#8639;array_assn (xs[i:=x]) p)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_assn_cnv_range_upd</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_upd_def</span><span> </span><span>array_assn_def</span><span> </span><span>snat.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>cnv_snat_to_uint</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>fri_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>fri_abs_cong_rl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>    
</span><span>    
</span><span>    
</span><span>    
</span><span>    
</span><span>    
</span><span>    
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Basic Algorithms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Array-Copy&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;arraycpy dst src (n::&#39;a::len2 word) &#8801; 
  doM {
    llc_while 
      (&#955;i. ll_icmp_ult i n) 
      (&#955;i. doM { 
        x&#8592;array_nth src i;
        array_upd dst i x;
        i&#8592;ll_add i (signed_nat 1);
        return i
      }) (signed_nat 0);
    return ()
  }&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>arraycpy_def</span><span class="delimiter">[</span><span>llvm_code</span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">export_llvm</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;arraycpy :: 8 word ptr &#8658; _ &#8658; 64 word &#8658; _&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;arraycpy&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move / REMOVE?*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_not_msb_imp_less_max_sint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; unat ` {w::&#39;a::len word. &#172; msb w} &#10233; int x &lt; max_sint LENGTH(&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>msb_uint_big</span><span> </span><span>max_sint_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arraycpy_rule_snat</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
    (&#8639;array_assn dst dsti ** &#8639;array_assn src srci ** &#8639;snat.assn n ni ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(n&#8804;length src &#8743; n&#8804;length dst))
    (arraycpy dsti srci ni)
    (&#955;_. &#8639;array_assn (take n src @ drop n dst) dsti ** &#8639;array_assn src srci)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>arraycpy_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>annotate_llc_while</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;ii t. EXS i dst&#39;. &#8639;snat.assn i ii ** &#8639;array_assn dst&#39; dsti ** &#8639;array_assn src srci
      ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(0&#8804;i &#8743; i&#8804;n &#8743; dst&#39; = take i src @ drop i dst) ** &#8593;<span class="hidden">&#8681;</span><sub>a</sub>(t = n-i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;measure id&quot;</span></span></span><span>
</span><span>      </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_monadify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_update_append</span><span> </span><span>upd_conv_take_nth_drop</span><span> </span><span>take_Suc_conv_app_nth</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Array-Set&#8250;</span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>arrayset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::llvm_rep ptr &#8658; &#39;b &#8658; &#39;a::len2 word &#8658; unit llM&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>llvm_code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;arrayset dst c n &#8801; doM {
    llc_while
      (&#955;i. ll_cmp (i&lt;n))
      (&#955;i. doM {
        array_upd dst i c;
        let i=i+(signed_nat 1);
        return i
      }) (signed_nat 0);
    return ()
  }&quot;</span></span></span><span>  
</span><span>  
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*declare arrayset_def[llvm_code]*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_llvm</span></span><span> </span><span class="delimiter">(</span><span>debug</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;arrayset :: 32 word ptr &#8658; 32 word &#8658; 64 word &#8658; _&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arrayset_rule_snat</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
  (&#8639;array_assn dst dsti ** &#8639;snat.assn n ni ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(n&#8804;length dst))
  (arrayset dsti c ni)
  (&#955;_. &#8639;array_assn (replicate n c @ drop n dst) dsti)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>arrayset_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>annotate_llc_while</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;ii t. EXS i dst&#39;. &#8639;snat.assn i ii ** &#8639;array_assn dst&#39; dsti 
      ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(0&#8804;i &#8743; i&#8804;n &#8743; dst&#39; = replicate i c @ drop i dst) ** &#8593;<span class="hidden">&#8681;</span><sub>a</sub>(t = n-i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;measure id&quot;</span></span></span><span>  
</span><span>  </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_monadify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span> </span><span>list_update_append</span><span> </span><span>replicate_Suc_conv_snoc</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>replicate_Suc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_nth_drop_Suc</span><span> </span><span>less_le_trans</span><span> </span><span>list_update_code</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Array-Set also works for zero-size, and any pointer, including &#8249;null&#8250;&#8250;</span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arrayset_zerosize_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#8639;snat.assn 0 ni) (arrayset p c ni) (&#955;_. &#9633;)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>arrayset_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>annotate_llc_while</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>I</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;ii _. EXS i. &#8639;snat.assn i ii&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{}&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_monadify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Array-New-Init&#8250;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;array_new_init n (c::&#39;a::llvm_rep) &#8801; doM { 
  r &#8592; array_new TYPE(&#39;a) n; 
  arrayset r c n;
  return r
}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>array_new_init_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple   
  (&#8639;snat.assn n ni ** &#8593;<span class="hidden">&#8681;</span><sub>d</sub>(n&gt;0)) 
  (array_new_init ni c) 
  (&#955;r. &#8639;array_assn (replicate n c) r)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>array_new_init_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


