<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Sepref_Rules (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Sepref_Rules</h1>

<span class="command">theory</span> <span class="name">Sepref_Rules</span><br/>
<span class="keyword">imports</span> <a href="Sepref_Constraints.html"><span class="name">Sepref_Constraints</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Refinement Rule Management&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Sepref_Rules</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Sepref_Basic</span><span> </span><span>Sepref_Constraints</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This theory contains tools for managing the refinement rules used by Sepref&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The theories are based on uncurried functions, i.e.,
    every function has type @{typ &quot;&#39;a&#8658;&#39;b&quot;}, where @{typ &#39;a} is the 
    tuple of parameters, or unit if there are none.
    &#8250;</span></span></span><span>
</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;non_dep R &#8801; &#8704;b. R b = R undefined&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_dep_simp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;non_dep R &#10233; NO_MATCH undefined x &#10233; R x = R undefined&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>non_dep_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_dep_K</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;non_dep (&#955;_. c)&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>non_dep_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    
</span><span>    
</span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Assertion Interface Binding&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Binding of interface types to refinement assertions&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>intf_of_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; _ &#8658; assn) &#8658; &#39;b itself &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intf_of_assn a b = True&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intf_of_assnI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intf_of_assn R TYPE(&#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">named_theorems_rev</span></span><span> </span><span>intf_of_assn</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Links between refinement assertions and interface types&#8250;</span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intf_of_assn_fallback</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intf_of_assn (R :: &#39;a &#8658; _ &#8658; assn) TYPE(&#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Function Refinement with Precondition&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;c &#8658; bool) &#8658; (&#39;a &#215; &#39;c) set &#8658; (&#39;c &#8658; (&#39;b &#215; &#39;d) set)
           &#8658; ((&#39;a &#8658; &#39;b) &#215; (&#39;c &#8658; &#39;d)) set&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;[_]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> _ &#8594; _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>         
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[P]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S &#8801; {(f,g). &#8704;x y. P y &#8743; (x,y)&#8712;R &#10230; (f x, g y)&#8712;S y}&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>freft</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8594;<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R &#8594;<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> S &#8801; ([&#955;_. True]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>freftnd</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8594;<span class="hidden">&#8681;</span><sub>f</sub> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R &#8594;<span class="hidden">&#8681;</span><sub>f</sub> S &#8801; ([&#955;_. True]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; (&#955;_. S))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>frefnd</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;[_]<span class="hidden">&#8681;</span><sub>f</sub> _ &#8594; _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[P]<span class="hidden">&#8681;</span><sub>f</sub> R &#8594; S &#8801; [P]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; (&#955;_. S)&quot;</span></span></span><span>
</span><span>
</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel2p_fref</span><span class="delimiter">[</span><span>rel2p</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel2p (fref P R S) 
    = (&#955;f g. (&#8704;x y. P y &#10230; rel2p R x y &#10230; rel2p (S y) (f x) (g y)))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fref_def</span><span> </span><span>rel2p_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_cons</span><span class="delimiter">:</span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;c a. (c,a)&#8712;R&#39; &#10233; Q a &#10233; P a&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R&#39; &#8838; R&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;c a. &#10214;(c,a)&#8712;R&#39;; Q a&#10215; &#10233; S a &#8838; S&#39; a&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [Q]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> R&#39; &#8594; S&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fref_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fref_cons&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>fref_cons</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>order_refl</span><span> </span><span>order_refl</span><span class="delimiter">]</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frefI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x y. &#10214;P y; (x,y)&#8712;R&#10215; &#10233; (f x, g y)&#8712;S y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g)&#8712;fref P R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fref_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_ncI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g)&#8712;R&#8594;S &#10233; (f,g)&#8712;R&#8594;<span class="hidden">&#8681;</span><sub>f</sub>S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>frefI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>parametricity</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>frefD</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g)&#8712;fref P R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P y; (x,y)&#8712;R&#10215; &#10233; (f x, g y)&#8712;S y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fref_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_ncD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g)&#8712;R&#8594;<span class="hidden">&#8681;</span><sub>f</sub>S &#10233; (f,g)&#8712;R&#8594;S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fun_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>frefD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rr_comp S R1 R2 x &#8801; if non_dep R1 then R1 undefined O R2 x else (&#8899;{R1 y | y. (y,x)&#8712;S}) O R2 x&quot;</span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rr_comp_K</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rr_comp S (&#955;_. R1) R2 = (&#955;x. R1 O R2 x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rr_comp_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rr_comp_nondep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rr_comp T (&#955;_. A) R = (&#955;x. A O (R x))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rr_comp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_compI</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fref P R1 R2 O fref Q S1 S2 &#8838;
      fref (&#955;x. Q x &#8743; (&#8704;y. (y,x)&#8712;S1 &#10230; P y)) (R1 O S1) (rr_comp S1 R2 S2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fref_def</span><span> </span><span>rr_comp_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;non_dep R2&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>non_dep_simp</span><span class="delimiter">[</span><span>of</span><span> </span><span>R2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_compI&#39;</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (f,g)&#8712;fref P R1 R2; (g,h)&#8712;fref Q S1 S2 &#10215; 
      &#10233; (f,h) &#8712; fref (&#955;x. Q x &#8743; (&#8704;y. (y,x)&#8712;S1 &#10230; P y)) (R1 O S1) (rr_comp S1 R2 S2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fref_compI</span><span class="delimiter">[</span><span>of</span><span> </span><span>P</span><span> </span><span>R1</span><span> </span><span>R2</span><span> </span><span>Q</span><span> </span><span>S1</span><span> </span><span>S2</span><span class="delimiter">]</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_unit_conv</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;_. c, &#955;_. a) &#8712; fref P unit_rel S &#10231; (P () &#10230; (c,a)&#8712;S ())&quot;</span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_uncurry_conv</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry c, uncurry a) &#8712; fref P (R1&#215;<span class="hidden">&#8681;</span><sub>r</sub>R2) S 
    &#10231; (&#8704;x1 y1 x2 y2. P (y1,y2) &#10230; (x1,y1)&#8712;R1 &#10230; (x2,y2)&#8712;R2 &#10230; (c x1 x2, a y1 y2) &#8712; S (y1,y2))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; &#8896;x. P&#39; x &#10233; P x; R&#39; &#8838; R; &#8896;x y. P&#39; x &#10233; S x &#8838; S&#39; x &#10215; 
    &#10233; fref P R S &#8838; fref P&#39; R&#39; S&#39;&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fref_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_composeI</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FR1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g)&#8712;fref P R1 R2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FR2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(g,h)&#8712;fref Q S1 S2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>C1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. P&#39; x &#10233; Q x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>C2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x y. &#10214;P&#39; x; (y,x)&#8712;S1&#10215; &#10233; P y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R&#39; &#8838; R1 O S1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. &#10214; P&#39; x &#10215; &#10233; rr_comp S1 R2 S2 x &#8838; S&#39; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f&#39;=f&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h&#39;=h&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f&#39;,h&#39;) &#8712; fref P&#39; R&#39; S&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>FH</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fref_mono</span><span> </span><span>fref_compI&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FR1</span><span> </span><span>FR2</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C1</span><span> </span><span>C2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R1</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>R2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_triv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#8838;Id &#10233; (f,f)&#8712;[P]<span class="hidden">&#8681;</span><sub>f</sub> A &#8594; Id&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Heap-Function Refinement&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
    The following relates a heap-function with a pure function.
    It contains a precondition, a refinement assertion for the arguments
    before and after execution, and a refinement relation for the result.
    &#8250;</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: We only use this with keep/destroy information, so we could model
    the parameter relations as such ((&#39;a&#8658;&#39;ai &#8658; assn) &#215; bool) *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hfref</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;
      (&#39;a &#8658; bool) 
   &#8658; ((&#39;a &#8658; &#39;ai &#8658; assn) &#215; (&#39;a &#8658; &#39;ai &#8658; assn)) 
   &#8658; (&#39;a &#8658; &#39;b &#8658; &#39;bi &#8658; assn) 
   &#8658; ((&#39;ai &#8658; &#39;bi llM) &#215; (&#39;a&#8658;&#39;b nres)) set&quot;</span></span></span><span>
</span><span>   </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;[_]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> _ &#8594; _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;[P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> RS &#8594; T &#8801; { (f,g) . &#8704;c a.  P a &#10230; hn_refine (fst RS a c) (f c) (snd RS a c) (T a) (g a)}&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hfrefnd</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;[_]<span class="hidden">&#8681;</span><sub>a</sub> _ &#8594; _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[P]<span class="hidden">&#8681;</span><sub>a</sub> RS &#8594; T &#8801; ([P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> RS &#8594; (&#955;_. T))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hfreft</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8594;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RS &#8594;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> T &#8801; ([&#955;_. True]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> RS &#8594; T)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hfreftnd</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8594;<span class="hidden">&#8681;</span><sub>a</sub> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RS &#8594;<span class="hidden">&#8681;</span><sub>a</sub> T &#8801; [&#955;_. True]<span class="hidden">&#8681;</span><sub>a</sub> RS &#8594; T&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfrefI</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;c a. P a &#10233; hn_refine (fst RS a c) (f c) (snd RS a c) (T a) (g a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g)&#8712;hfref P RS T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfrefD</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g)&#8712;hfref P RS T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;c a. P a &#10233; hn_refine (fst RS a c) (f c) (snd RS a c) (T a) (g a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_to_ASSERT_conv</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;NO_MATCH (&#955;_. True) P &#10233; (a,b)&#8712;[P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S &#10231; (a,&#955;x. ASSERT (P x) &#10914; b x) &#8712; R &#8594;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">;</span><span> </span><span>safe</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_nofailI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xc</span><span> </span><span>xa</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>xc</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>xa</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
    A pair of argument refinement assertions can be created by the 
    input assertion and the information whether the parameter is kept or destroyed
    by the function.
    &#8250;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>hf_pres</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; &#39;b &#8658; assn) &#8658; bool &#8658; (&#39;a &#8658; &#39;b &#8658; assn)&#215;(&#39;a &#8658; &#39;b &#8658; assn)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hf_pres R True = (R,R)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hf_pres R False = (R,invalid_assn R)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hfkeep</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; &#39;b &#8658; assn) &#8658; (&#39;a &#8658; &#39;b &#8658; assn)&#215;(&#39;a &#8658; &#39;b &#8658; assn)&quot;</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(_<span class="hidden">&#8679;</span><sup>k</sup>)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>999</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R<span class="hidden">&#8679;</span><sup>k</sup> &#8801; hf_pres R True&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hfdrop</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; &#39;b &#8658; assn) &#8658; (&#39;a &#8658; &#39;b &#8658; assn)&#215;(&#39;a &#8658; &#39;b &#8658; assn)&quot;</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(_<span class="hidden">&#8679;</span><sup>d</sup>)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>999</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R<span class="hidden">&#8679;</span><sup>d</sup> &#8801; hf_pres R False&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_kede R kd &#8801; hn_ctxt (snd (hf_pres R kd))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_keep R &#8801; hn_kede R True&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_dest R &#8801; hn_kede R False&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keep_drop_sels</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fst (R<span class="hidden">&#8679;</span><sup>k</sup>) = R&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;snd (R<span class="hidden">&#8679;</span><sup>k</sup>) = R&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fst (R<span class="hidden">&#8679;</span><sup>d</sup>) = R&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;snd (R<span class="hidden">&#8679;</span><sup>d</sup>) = invalid_assn R&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hf_pres_fst</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (hf_pres R k) = R&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
    The following operator combines multiple argument assertion-pairs to
    argument assertion-pairs for the product. It is required to state
    argument assertion-pairs for uncurried functions.
    &#8250;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hfprod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;
    ((&#39;a &#8658; &#39;b &#8658; assn)&#215;(&#39;a &#8658; &#39;b &#8658; assn)) 
    &#8658; ((&#39;c &#8658; &#39;d &#8658; assn)&#215;(&#39;c &#8658; &#39;d &#8658; assn))
    &#8658; (((&#39;a&#215;&#39;c) &#8658; (&#39;b &#215; &#39;d) &#8658; assn) &#215; ((&#39;a&#215;&#39;c) &#8658; (&#39;b &#215; &#39;d) &#8658; assn))&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;*<span class="hidden">&#8681;</span><sub>a</sub>&quot;</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RR *<span class="hidden">&#8681;</span><sub>a</sub> SS &#8801; (prod_assn (fst RR) (fst SS), prod_assn (snd RR) (snd SS))&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfprod_fst_snd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fst (A *<span class="hidden">&#8681;</span><sub>a</sub> B) = prod_assn (fst A) (fst B)&quot;</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;snd (A *<span class="hidden">&#8681;</span><sub>a</sub> B) = prod_assn (snd A) (snd B)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfprod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Conversion from fref to hfref&#8250;</span></span></span><span>  
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Variant of import-param! Automate this! *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_to_pure_hfref&#39;</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>f</sub> R&#8594;&#10216;S&#10217;nres_rel&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. x&#8712;Domain R &#8745; R&#175;``Collect P &#10233; f x = RETURN (f&#39; x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(return o f&#39;, g) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub> (pure R)<span class="hidden">&#8679;</span><sup>k</sup>&#8594;pure S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>c</span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P a&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nofail (g a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, a) &#8712; R&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;x. (f&#39; c, x) &#8712; S &#8743; RETURN x &#8804; g a&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fref_def</span><span> </span><span>pw_le_iff</span><span> </span><span>pw_nres_rel_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ENTAILS F ((&#8593;((c, a) &#8712; R) &#8743;* (&#955;s. &#8707;x. (&#8593;((f&#39; c, x) &#8712; S) &#8743;* &#8593;(RETURN x &#8804; g a)) s)) &#8743;* F)&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>F</span><span> </span><span class="delimiter">::</span><span> </span><span>assn</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>AUX</span><span class="delimiter">=</span><span>this</span><span> 
</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfrefI</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refineI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pure_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>AUX</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Conversion from hfref to hnr&#8250;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This section contains the lemmas. The ML code is further down. &#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hf2hnr</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x xi. P x &#10230; hn_refine (hn_ctxt (fst R) x xi ** &#9633;) (f$xi) (hn_ctxt (snd R) x xi ** &#9633;) (S x) (g$x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Products that stem from currying are tagged by a special refinement relation *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;to_hnr_prod &#8801; prod_assn&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_hnr_prod_fst_snd</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fst (A *<span class="hidden">&#8681;</span><sub>a</sub> B) = to_hnr_prod (fst A) (fst B)&quot;</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;snd (A *<span class="hidden">&#8681;</span><sub>a</sub> B) = to_hnr_prod (snd A) (snd B)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfprod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Warning: This lemma is carefully set up to be applicable as an unfold rule,
    for more than one level of uncurrying*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hnr_uncurry_unfold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;
    (&#8704;x xi. P x &#10230; 
      hn_refine 
        (hn_ctxt (to_hnr_prod A B) x xi ** &#915;) 
        (fi xi) 
        (hn_ctxt (to_hnr_prod A&#39; B&#39;) x xi ** &#915;&#39;) 
        (R x) 
        (f x))
&#10231; (&#8704;b bi a ai. P (a,b) &#10230;
      hn_refine 
        (hn_ctxt A a ai ** hn_ctxt B b bi ** &#915;) 
        (fi (ai,bi)) 
        (hn_ctxt A&#39; a ai ** hn_ctxt B&#39; b bi ** &#915;&#39;)
        (R (a,b))
        (f (a,b))
    )&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span> </span><span>prod_assn_def</span><span> </span><span>sep_conj_ac</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hnr_intro_dummy</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x xi. P x &#10230; hn_refine (&#915; x xi) (c xi) (&#915;&#39; x xi) (R x) (a x) &#10233; &#8704;x xi. P x &#10230; hn_refine (&#915; x xi ** &#9633;) (c xi) (&#915;&#39; x xi ** &#9633;) (R x) (a x)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_ctxt_ctxt_fix_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt (hn_ctxt R) = hn_ctxt R&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncurry_APP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry f$(a,b) = f$a$b&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Replace by more general rule. *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_RETURN_o</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (RETURN o f)$x = (RETURN$(f$x))&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (RETURN oo f)$x$y = (RETURN$(f$x$y))&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (RETURN ooo f)$x$y$z = (RETURN$(f$x$y$z))&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (&#955;x. RETURN ooo f x)$x$y$z$a = (RETURN$(f$x$y$z$a))&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (&#955;x y. RETURN ooo f x y)$x$y$z$a$b = (RETURN$(f$x$y$z$a$b))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>norm_return_o</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (return o f)$x = (return$(f$x))&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (return oo f)$x$y = (return$(f$x$y))&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (return ooo f)$x$y$z = (return$(f$x$y$z))&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (&#955;x. return ooo f x)$x$y$z$a = (return$(f$x$y$z$a))&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (&#955;x y. return ooo f x y)$x$y$z$a$b = (return$(f$x$y$z$a$b))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_val_unit_conv_emp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_val unit_rel x y = &#9633;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span> </span><span>pure_def</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Conversion from hnr to hfref&#8250;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This section contains the lemmas. The ML code is further down. &#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id_assn &#8801; pure Id&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unit_assn &#8801; id_assn :: unit &#8658; _&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_unit_rel_eq_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unit_assn x y = &#9633;&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uc_hfprod_sel</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;fst (A *<span class="hidden">&#8681;</span><sub>a</sub> B) a c = (case (a,c) of ((a1,a2),(c1,c2)) &#8658; fst A a1 c1 ** fst B a2 c2)&quot;</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;snd (A *<span class="hidden">&#8681;</span><sub>a</sub> B) a c = (case (a,c) of ((a1,a2),(c1,c2)) &#8658; snd A a1 c1 ** snd B a2 c2)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Conversion from relation to fref&#8250;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This section contains the lemmas. The ML code is further down. &#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CURRY R &#8801; { (f,g). (uncurry f, uncurry g) &#8712; R }&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_param1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R&#8594;S = R&#8594;<span class="hidden">&#8681;</span><sub>f</sub>S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fref_def</span><span> </span><span>fun_relD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_nest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[P1]<span class="hidden">&#8681;</span><sub>f</sub> R1 &#8594; ([P2]<span class="hidden">&#8681;</span><sub>f</sub> R2 &#8594; S) 
    &#8801; CURRY ([(&#955;(a,b). P1 a &#8743; P2 b)]<span class="hidden">&#8681;</span><sub>f</sub> (R1&#215;<span class="hidden">&#8681;</span><sub>r</sub>R2) &#8594; S)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eq_reflection</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fref_def</span><span> </span><span>CURRY_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_CURRY_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; CURRY R &#10231; (uncurry f, uncurry g) &#8712; R&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CURRY_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncurry0_APP</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry0 c $ x = c&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_param0I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c,a)&#8712;R &#10233; (uncurry0 c, uncurry0 a) &#8712; unit_rel &#8594;<span class="hidden">&#8681;</span><sub>f</sub> R&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Composition&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hr_comp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658; &#39;c &#8658; assn) &#8658; (&#39;b &#215; &#39;a) set &#8658; &#39;a &#8658; &#39;c &#8658; assn&quot;</span></span></span><span>
</span><span>    </span><span class="comment">&#8213; &#8249;Compose refinement assertion with refinement relation&#8250;</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hr_comp R1 R2 a c &#8801; EXS b. R1 b c ** &#8593;((b,a)&#8712;R2)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hrp_comp</span><span> 
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;d &#8658; &#39;b &#8658; assn) &#215; (&#39;d &#8658; &#39;c &#8658; assn)
        &#8658; (&#39;d &#215; &#39;a) set &#8658; (&#39;a &#8658; &#39;b &#8658; assn) &#215; (&#39;a &#8658; &#39;c &#8658; assn)&quot;</span></span></span><span>
</span><span>    </span><span class="comment">&#8213; &#8249;Compose argument assertion-pair with refinement relation&#8250;</span><span>    
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_comp RR&#39; S &#8801; (hr_comp (fst RR&#39;) S, hr_comp (snd RR&#39;) S) &quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hr_compI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(b,a)&#8712;R2 &#10233; R1 b c &#8866; hr_comp R1 R2 a c&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hr_comp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>entails_def</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hr_comp_Id1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hr_comp (pure Id) R = pure R&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hr_comp_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>pure_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hr_comp_Id2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hr_comp R Id = R&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hr_comp_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hr_comp_emp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hr_comp (&#955;a c. &#9633;) R a c = &#8593;(&#8707;b. (b,a)&#8712;R)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hr_comp_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hr_comp_prod_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hr_comp (prod_assn Ra Rb) (Ra&#39; &#215;<span class="hidden">&#8681;</span><sub>r</sub> Rb&#39;) 
    = prod_assn (hr_comp Ra Ra&#39;) (hr_comp Rb Rb&#39;)&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hr_comp_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>prod_assn_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hr_comp_pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hr_comp (pure R) S = pure (R O S)&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hr_comp_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>pure_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hr_comp_is_pure</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure A &#10233; is_pure (hr_comp A B)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hr_comp_pure</span><span> </span><span>is_pure_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hr_comp_the_pure</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure A &#10233; the_pure (hr_comp A B) = the_pure A O B&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_pure_conv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hr_comp_pure</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rdomp_hrcomp_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rdomp (hr_comp A R) x &#10231; (&#8707;y. rdomp A y &#8743; (y,x)&#8712;R)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rdomp_def</span><span> </span><span>hr_comp_def</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_rel_compI</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;nofail a; (b,a)&#8712;&#10216;R2&#10217;nres_rel&#10215; &#10233; hn_rel R1 b c &#8866; hn_rel (hr_comp R1 R2) a c&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hr_comp_def</span><span> </span><span>hn_rel_def</span><span> </span><span>nres_rel_def</span><span> </span><span>entails_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ret_le_down_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  
  lemma hr_comp_precise[constraint_rules]:
    assumes [safe_constraint_rules]: &quot;precise R&quot;
    assumes SV: &quot;single_valued S&quot;
    shows &quot;precise (hr_comp R S)&quot;
    apply (rule preciseI)
    unfolding hr_comp_def
    apply clarsimp
    by (metis SV assms(1) preciseD single_valuedD)
  *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hr_comp_assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hr_comp (hr_comp R S) T = hr_comp R (S O T)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hr_comp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrp_comp_Id1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_comp (hf_pres (pure Id) pp) R = hf_pres (pure R) pp&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hrp_comp_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pp</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hr_comp_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>invalid_assn_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>fun_eq_iff</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrp_comp_Id2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_comp A Id = A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hrp_comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hnr_comp_aux</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RETURN x &#8804; m&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nofail m&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m,m&#39;)&#8712;&#10216;R&#10217;nres_rel&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x,x&#39;)&#8712;R&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RETURN x&#39; &#8804; m&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>inres_def</span><span> </span><span>nres_relD</span><span> </span><span>pwD2</span><span> </span><span>pw_conc_inres</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrr_comp R R1 R2 x a c &#8801; 
    if non_dep R1 then
      hr_comp (R1 undefined) (R2 x) a c
    else
      EXS b. &#8593;((b,x)&#8712;R) ** hr_comp (R1 b) (R2 x) a c&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hnr_comp</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;b1 c1. P b1 &#10233; hn_refine (R1 b1 c1 ** &#915;) (c c1) (R1p b1 c1 ** &#915;&#39;) (R b1) (b b1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a1 b1. &#10214;Q a1; (b1,a1)&#8712;R1&#39;&#10215; &#10233; (b b1,a a1)&#8712;&#10216;R&#39; a1&#10217;nres_rel&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a1 b1. &#10214;Q a1; (b1,a1)&#8712;R1&#39;&#10215; &#10233; P b1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q a1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine 
      (hr_comp R1 R1&#39; a1 c1 ** &#915;) 
      (c c1)
      (hr_comp R1p R1&#39; a1 c1 ** &#915;&#39;) 
      (hrr_comp R1&#39; R R&#39; a1) 
      (a a1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>R</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>hn_refineD</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>c1</span><span class="delimiter">]</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nofail (b x)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;nofail (a a1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x, a1) &#8712; R1&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Q</span><span> </span><span>S</span><span> </span><span>nres_rel_def</span><span> </span><span>pw_ref_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    
</span><span>      
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hn_refine_alt</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hr_comp_def</span><span> </span><span>hn_rel_def</span><span> </span><span>hrr_comp_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;non_dep R&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>prems</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PQ</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Q</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>non_dep_simp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>prems</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>S</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Q</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hnr_comp_aux</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_try_solve</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PQ</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Q</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>S</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Q</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hnr_comp_aux</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_try_solve</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hnr_comp1_aux</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;b1 c1. P b1 &#10233; hn_refine (hn_ctxt R1 b1 c1) (c c1) (hn_ctxt R1p b1 c1) (R b1) (b$b1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a1 b1. &#10214;Q a1; (b1,a1)&#8712;R1&#39;&#10215; &#10233; (b$b1,a$a1)&#8712;&#10216;R&#39; a1&#10217;nres_rel&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a1 b1. &#10214;Q a1; (b1,a1)&#8712;R1&#39;&#10215; &#10233; P b1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q a1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine 
      (hr_comp R1 R1&#39; a1 c1) 
      (c c1)
      (hr_comp R1p R1&#39; a1 c1) 
      (hrr_comp R1&#39; R R&#39; a1) 
      (a a1)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>hnr_comp</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>&#915;</span><span class="delimiter">=</span><span>&#9633;</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>&#915;&#39;</span><span class="delimiter">=</span><span>&#9633;</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">=</span><span>a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">=</span><span>b</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">=</span><span>c</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span>P</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span>Q</span><span class="delimiter">]</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hn_ctxt_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfcomp</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> RR&#39; &#8594; S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(g,h) &#8712; [Q]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> T &#8594; (&#955;x. &#10216;U x&#10217;nres_rel)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; [&#955;a. Q a &#8743; (&#8704;a&#39;. (a&#39;,a)&#8712;T &#10230; P a&#39;)]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> 
      hrp_comp RR&#39; T &#8594; hrr_comp T S U&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fref_def</span><span> </span><span>hfref_def</span><span> </span><span>hrp_comp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hnr_comp1_aux</span><span class="delimiter">[</span><span>of</span><span> 
</span><span>        </span><span>P</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst RR&#39;&quot;</span></span></span><span> </span><span>f</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd RR&#39;&quot;</span></span></span><span> </span><span>S</span><span> </span><span>g</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a. Q a &#8743; (&#8704;a&#39;. (a&#39;,a)&#8712;T &#10230; P a&#39;)&quot;</span></span></span><span> </span><span>T</span><span> </span><span>h</span><span> </span><span>U</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrr_comp_nondep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrr_comp T (&#955;_. A) R = (&#955;x. hr_comp A (R x))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hrr_comp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Concept of lifting dependent relation over other relation! Allows us to handle hrr_comp R R1 (&#955;_. Id) *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrr_comp_Id_R_Id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrr_comp Id R1 (&#955;_. Id) = R1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hrr_comp_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>non_dep_simp</span><span class="delimiter">[</span><span>of</span><span> </span><span>R1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrr_comp_id_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrr_comp Id R1 R2 = (&#955;x. hr_comp (R1 x) (R2 x))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hrr_comp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>non_dep_simp</span><span class="delimiter">[</span><span>of</span><span> </span><span>R1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_weaken_pre_nofail</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [&#955;x. nofail (g x) &#10230; P x]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span> </span><span>hn_refine_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_cons</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. P&#39; x &#10233; P x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x y. fst R&#39; x y &#8866; fst R x y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x y. snd R x y &#8866; snd R&#39; x y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x y a. P&#39; a &#10233; S a x y &#8866; S&#39; a x y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P&#39;]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> R&#39; &#8594; S&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>entails_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>entails_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma xfer_hrr_comp:
    assumes &quot;&#8896;x y a c. &#10214; (x,y)&#8712;T &#10215; &#10233; R x a c &#8866; R&#39; y a c&quot;  
    shows &quot;hrr_comp T R S x a c &#8866; (hr_comp (R&#39; x) S) a c&quot;
    using assms unfolding hrr_comp_def
    apply (cases &quot;non_dep R&quot;; simp)
    subgoal sorry
    apply (auto simp: sep_algebra_simps pred_lift_extract_simps entails_def hr_comp_def non_dep_simp[of R])
  *)</span></span></span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Composition Automation&#8250;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This section contains the lemmas. The ML code is further down. &#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prod_hrp_comp</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_comp (A *<span class="hidden">&#8681;</span><sub>a</sub> B) (C &#215;<span class="hidden">&#8681;</span><sub>r</sub> D) = hrp_comp A C *<span class="hidden">&#8681;</span><sub>a</sub> hrp_comp B D&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hrp_comp_def</span><span> </span><span>hfprod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrp_comp_keep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_comp (A<span class="hidden">&#8679;</span><sup>k</sup>) B = (hr_comp A B)<span class="hidden">&#8679;</span><sup>k</sup>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hrp_comp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hr_comp_invalid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hr_comp (invalid_assn R1) R2 = invalid_assn (hr_comp R1 R2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invalid_assn_def</span><span> </span><span>hr_comp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_part_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: too low-level! *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrp_comp_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_comp (A<span class="hidden">&#8679;</span><sup>d</sup>) B = (hr_comp A B)<span class="hidden">&#8679;</span><sup>d</sup>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hrp_comp_def</span><span> </span><span>hr_comp_invalid</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_imp RR RR&#39; &#8801; 
    &#8704;a b. (fst RR&#39; a b &#8866; fst RR a b) &#8743; (snd RR a b &#8866; snd RR&#39; a b)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_imp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_imp RR RR&#39; &#10233; [P]<span class="hidden">&#8681;</span><sub>a</sub> RR &#8594; S &#8838; [P]<span class="hidden">&#8681;</span><sub>a</sub> RR&#39; &#8594; S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>hfref_cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hrp_imp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrp_imp_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_imp RR RR&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hrp_imp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrp_imp_reflI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RR = RR&#39; &#10233; hrp_imp RR RR&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hrp_imp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrp_comp_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_imp A A&#39; &#10233; B=B&#39; &#10233; hrp_imp (hrp_comp A B) (hrp_comp A&#39; B&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hrp_imp_def</span><span> </span><span>hrp_comp_def</span><span> </span><span>hr_comp_def</span><span> </span><span>entails_def</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrp_prod_cong</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_imp A A&#39; &#10233; hrp_imp B B&#39; &#10233; hrp_imp (A*<span class="hidden">&#8681;</span><sub>a</sub>B) (A&#39;*<span class="hidden">&#8681;</span><sub>a</sub>B&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hrp_imp_def</span><span> </span><span>prod_assn_def</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>conj_entails_mono</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hrp_imp_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrp_imp A B &#10233; hrp_imp B C &#10233; hrp_imp A C&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hrp_imp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>entails_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fcomp_norm_dflt_init</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;[P]<span class="hidden">&#8681;</span><sub>a</sub> R &#8594; T &#10233; hrp_imp R S &#10233; x&#8712;[P]<span class="hidden">&#8681;</span><sub>a</sub> S &#8594; T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_imp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;comp_PRE R P Q S &#8801; &#955;x. S x &#10230; (P x &#8743; (&#8704;y. (y,x)&#8712;R &#10230; Q x y))&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_PRE_cong</span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R&#8801;R&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. P x &#8801; P&#39; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. S x &#8801; S&#39; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x y. &#10214;P x; (y,x)&#8712;R; y&#8712;Domain R; S&#39; x &#10215; &#10233; Q x y &#8801; Q&#39; x y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;comp_PRE R P Q S &#8801; comp_PRE R&#39; P&#39; Q&#39; S&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_PRE_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>eq_reflection</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_compI_PRE</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (f,g)&#8712;fref P R1 R2; (g,h)&#8712;fref Q S1 S2 &#10215; 
      &#10233; (f,h) &#8712; fref (comp_PRE S1 Q (&#955;_. P) (&#955;_. True)) (R1 O S1) (rr_comp S1 R2 S2)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fref_compI</span><span class="delimiter">[</span><span>of</span><span> </span><span>P</span><span> </span><span>R1</span><span> </span><span>R2</span><span> </span><span>Q</span><span> </span><span>S1</span><span> </span><span>S2</span><span class="delimiter">]</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_PRE_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PRE_D1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q x &#8743; P x) &#10230; comp_PRE S1 Q (&#955;x _. P x) S x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_PRE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PRE_D2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q x &#8743; (&#8704;y. (y,x)&#8712;S1 &#10230; S x &#10230; P x y)) &#10230; comp_PRE S1 Q P S x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_PRE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_weaken_pre</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. P x &#10230; P&#39; x&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; fref P&#39; R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; fref P R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_rev_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>fref_mono</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_PRE_D1</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; fref (comp_PRE S1 Q (&#955;x _. P x) X) R S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; fref (&#955;x. Q x &#8743; P x) R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fref_weaken_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PRE_D1</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fref_PRE_D2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; fref (comp_PRE S1 Q P X) R S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; fref (&#955;x. Q x &#8743; (&#8704;y. (y,x)&#8712;S1 &#10230; X x &#10230; P x y)) R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>fref_weaken_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PRE_D2</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fref_PRE_D</span><span> </span><span class="delimiter">=</span><span> </span><span>fref_PRE_D1</span><span> </span><span>fref_PRE_D2</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_weaken_pre</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. P x &#10230; P&#39; x&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref P&#39; R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref P R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hfref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_weaken_pre&#39;</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. &#10214;P x; rdomp (fst R) x&#10215; &#10233; P&#39; x&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref P&#39; R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref P R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfrefI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_preI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hfref_def</span><span> </span><span>rdomp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_weaken_pre_nofail&#39;</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. &#10214;nofail (g x); Q x&#10215; &#10233; P x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [Q]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_weaken_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>hfref_weaken_pre_nofail</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c,a)&#8712;[&#955;x. P x &#8743; rdomp (fst A) x]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> A &#8594; R&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c,a)&#8712;[P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> A &#8594; R&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>assms</span><span> </span><span>hfref_weaken_pre&#39;</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_compI_PRE_aux</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> RR&#39; &#8594; S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(g,h) &#8712; [Q]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> T &#8594; (&#955;x. &#10216;U x&#10217;nres_rel)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; [comp_PRE T Q (&#955;_. P) (&#955;_. True)]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> 
      hrp_comp RR&#39; T &#8594; hrr_comp T S U&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_weaken_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>hfcomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_PRE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_compI_PRE</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> RR&#39; &#8594; S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(g,h) &#8712; [Q]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> T &#8594; (&#955;x. &#10216;U x&#10217;nres_rel)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; [comp_PRE T Q (&#955;x y. P y) (&#955;x. nofail (h x))]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> 
      hrp_comp RR&#39; T &#8594; hrr_comp T S U&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hfref_compI_PRE_aux</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>hfref_weaken_pre_nofail</span><span class="delimiter">]</span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_weaken_pre</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_PRE_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_PRE_D1</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref (comp_PRE S1 Q (&#955;x _. P x) X) R S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref (&#955;x. Q x &#8743; P x) R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_weaken_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PRE_D1</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_PRE_D2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref (comp_PRE S1 Q P X) R S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref (&#955;x. Q x &#8743; (&#8704;y. (y,x)&#8712;S1 &#10230; X x &#10230; P x y)) R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_weaken_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PRE_D2</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_PRE_D3</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref (comp_PRE S1 Q P X) R S&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref (comp_PRE S1 Q P X) R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hfref_PRE_D</span><span> </span><span class="delimiter">=</span><span> </span><span>hfref_PRE_D1</span><span> </span><span>hfref_PRE_D3</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Automation&#8250;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Purity configuration for constraint solver&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>pure_pure</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invalid_pure</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure (invalid_assn A)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>invalid_assn_def</span><span> </span><span>is_pure_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Configuration for hfref to hnr conversion&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>to_hnr_post</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;to_hnr converter: Postprocessing unfold rules&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncurry0_add_app_tag</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry0 (RETURN c) = uncurry0 (RETURN$c)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>sep_conj_empty</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P::ll_assn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>to_hnr_post</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>norm_RETURN_o</span><span> </span><span>norm_return_o</span><span>
</span><span>    </span><span>uncurry0_add_app_tag</span><span> </span><span>uncurry0_apply</span><span> </span><span>uncurry0_APP</span><span> </span><span>hn_val_unit_conv_emp</span><span>
</span><span>    </span><span>sep_conj_empty</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P::ll_assn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span class="delimiter">]</span><span> </span><span>sep_conj_empty&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P::ll_assn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>to_hfref_post</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;to_hfref converter: Postprocessing unfold rules&#8250;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prod_casesK</span><span class="delimiter">[</span><span>to_hfref_post</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;case_prod (&#955;_ _. k) = (&#955;_. k)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uncurry0_hfref_post</span><span class="delimiter">[</span><span>to_hfref_post</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hfref (uncurry0 True) R S = hfref (&#955;_. True) R S&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fo_rule</span><span> </span><span>arg_cong</span><span> </span><span>fun_cong</span><span class="delimiter">)</span><span class="delimiter">+</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Currently not used, we keep it in here anyway. *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Configuration for relation normalization after composition&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>fcomp_norm_unfold</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fcomp-normalizer: Unfold theorems&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>fcomp_norm_simps</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fcomp-normalizer: Simplification theorems&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>fcomp_norm_init</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fcomp-normalizer: Initialization rules&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>fcomp_norm_trans</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fcomp-normalizer: Transitivity rules&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>fcomp_norm_cong</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fcomp-normalizer: Congruence rules&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>fcomp_norm_norm</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fcomp-normalizer: Normalization rules&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>fcomp_norm_refl</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fcomp-normalizer: Reflexivity rules&quot;</span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Default Setup&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>prod_rel_comp</span><span> </span><span>nres_rel_comp</span><span> </span><span>Id_O_R</span><span> </span><span>R_O_Id</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hr_comp_Id1</span><span> </span><span>hr_comp_Id2</span><span> </span><span>hrp_comp_Id1</span><span> </span><span>hrp_comp_Id2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span>rr_comp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hrr_comp_nondep</span><span> </span><span>rr_comp_nondep</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hr_comp_prod_conv</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>prod_hrp_comp</span><span> </span><span>hrp_comp_keep</span><span> </span><span>hrp_comp_dest</span><span> </span><span>hr_comp_pure</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemmas [fcomp_norm_unfold] = prod_casesK uncurry0_hfref_post*)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONSTRAINT is_pure P &#10233; pure (the_pure P) = P&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>True_implies_equals</span><span> 
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_init</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>fcomp_norm_dflt_init</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_trans</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hrp_imp_trans</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_cong</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hrp_comp_cong</span><span> </span><span>hrp_prod_cong</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemmas [fcomp_norm_norm] = hrp_comp_dest*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_refl</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>refl</span><span> </span><span>hrp_imp_refl</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ensure_fref_nresI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g)&#8712;[P]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> R&#8594;S &#10233; (RETURN o f, RETURN o g)&#8712;[P]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> R&#8594;(&#955;x. &#10216;S x&#10217;nres_rel)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>nres_relI</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ensure_fref_nres_unfold</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. RETURN o (uncurry0 f) = uncurry0 (RETURN f)&quot;</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. RETURN o (uncurry f) = uncurry (RETURN oo f)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. (RETURN ooo uncurry) f = uncurry (RETURN ooo f)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Composed precondition normalizer&#8250;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>fcomp_prenorm_simps</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fcomp precondition-normalizer: Simplification theorems&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Support for preconditions of the form @{text &quot;_&#8712;Domain R&quot;}, 
    where @{text R} is the relation of the next more abstract level.&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>DomainI</span><span class="delimiter">[</span><span>fcomp_prenorm_simps</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auto_weaken_pre_init_hf</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. PROTECT P x &#10230; P&#39; x&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref P&#39; R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; hfref P R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hfref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auto_weaken_pre_init_f</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. PROTECT P x &#10230; P&#39; x&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; fref P&#39; R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,h) &#8712; fref P R S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>auto_weaken_pre_init</span><span> </span><span class="delimiter">=</span><span> </span><span>auto_weaken_pre_init_hf</span><span> </span><span>auto_weaken_pre_init_f</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auto_weaken_pre_uncurry_step</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;PROTECT f a &#8801; f&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;PROTECT (&#955;(x,y). f x y) (a,b) &#8801; f&#39; b&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>curry_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>meta_eq_to_obj_eq</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>eq_reflection</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auto_weaken_pre_uncurry_finish</span><span class="delimiter">:</span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;PROTECT f x &#8801; f x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auto_weaken_pre_uncurry_start</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8801; P&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P&#39;&#10230;Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P&#10230;Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auto_weaken_pre_comp_PRE_I</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S x &#10233; P x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;y. &#10214;(y,x)&#8712;R; P x; S x&#10215; &#10233; Q x y&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;comp_PRE R P Q S x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_PRE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auto_weaken_pre_to_imp_nf</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(A&#10230;B&#10230;C) = (A&#8743;B &#10230; C)&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;((A&#8743;B)&#8743;C) = (A&#8743;B&#8743;C)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auto_weaken_pre_add_dummy_imp</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;P &#10233; True &#10230; P&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Synthesis for hfref statements&#8250;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hfsynth_ID_R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; _ &#8658; assn) &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hfsynth_ID_R _ _ &#8801; True&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfsynth_ID_R_D</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>I</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a itself&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hfsynth_ID_R R a&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intf_of_assn R I&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a ::<span class="hidden">&#8681;</span><sub>i</sub> I&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfsynth_hnr_from_hfI</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x xi. P x &#8743; hfsynth_ID_R (fst R) x &#10230; hn_refine (hn_ctxt (fst R) x xi ** &#9633;) (f$xi) (hn_ctxt (snd R) x xi ** &#9633;) (S x) (g$x)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(f,g) &#8712; [P]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> R &#8594; S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfsynth_ID_R_uncurry_unfold</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hfsynth_ID_R (to_hnr_prod R S) (a,b) &#8801; hfsynth_ID_R R a &#8743; hfsynth_ID_R S b&quot;</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hfsynth_ID_R (fst (hf_pres R k)) &#8801; hfsynth_ID_R R&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>eq_reflection</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;

    signature SEPREF_RULES = sig
      (* Analysis of relations, both fref and fun_rel *)
      (* &quot;R1&#8594;...&#8594;Rn&#8594;_&quot; / &quot;[_]<span class="hidden">&#8681;</span><sub>f</sub> ((R1&#215;<span class="hidden">&#8681;</span><sub>r</sub>R2)...&#215;<span class="hidden">&#8681;</span><sub>r</sub>Rn)&quot;  &#8614;  &quot;[R1,...,Rn]&quot; *)
      val binder_rels: term -&gt; term list 
      (* &quot;_&#8594;...&#8594;_&#8594;S&quot; / &quot;[_]<span class="hidden">&#8681;</span><sub>f</sub> _ &#8594; S&quot;  &#8614;  &quot;S&quot; *)
      val body_rel: term -&gt; term 
      (* Map &#8594;/fref to (precond,args,res). NONE if no/trivial precond. *)
      val analyze_rel: term -&gt; term option * term list * term 
      (* Make trivial (&quot;&#955;_. True&quot;) precond *)
      val mk_triv_precond: term list -&gt; term 
      (* Make &quot;[P]<span class="hidden">&#8681;</span><sub>f</sub><span class="hidden">&#8681;</span><sub>d</sub> ((R1&#215;<span class="hidden">&#8681;</span><sub>r</sub>R2)...&#215;<span class="hidden">&#8681;</span><sub>r</sub>Rn) &#8594; S&quot;. Insert trivial precond if NONE. *)
      val mk_rel: term option * term list * term -&gt; term 
      (* Map relation to (args,res) *)
      val strip_rel: term -&gt; term list * term 

      (* Make hfprod (op *<span class="hidden">&#8681;</span><sub>a</sub>) *)
      val mk_hfprod : term * term -&gt; term
      val mk_hfprods : term list -&gt; term

      (* Determine interface type of refinement assertion, using default fallback
        if necessary. Use named_thms intf_of_assn for configuration. *)
      val intf_of_assn : Proof.context -&gt; term -&gt; typ

      (*
        Convert a parametricity theorem in higher-order form to
        uncurried fref-form. For functions without arguments, 
        a unit-argument is added.

        TODO/FIXME: Currently this only works for higher-order theorems,
          i.e., theorems of the form (f,g)&#8712;R1&#8594;&#8230;&#8594;Rn. 
          
          First-order theorems are silently treated as refinement theorems
          for functions with zero arguments, i.e., a unit-argument is added.
      *)
      val to_fref : Proof.context -&gt; thm -&gt; thm

      (* Convert a parametricity or fref theorem to first order form *)
      val to_foparam : Proof.context -&gt; thm -&gt; thm

      (* Convert schematic hfref goal to hnr-goal *)
      val prepare_hfref_synth_tac : Proof.context -&gt; tactic&#39;

      (* Convert theorem in hfref-form to hnr-form *)
      val to_hnr : Proof.context -&gt; thm -&gt; thm

      (* Convert theorem in hnr-form to hfref-form *)
      val to_hfref: Proof.context -&gt; thm -&gt; thm

      (* Convert theorem to given form, if not yet in this form *)
      val ensure_fref : Proof.context -&gt; thm -&gt; thm
      val ensure_fref_nres : Proof.context -&gt; thm -&gt; thm
      val ensure_hfref : Proof.context -&gt; thm -&gt; thm
      val ensure_hnr : Proof.context -&gt; thm -&gt; thm


      type hnr_analysis = {
        thm: thm,                     (* Original theorem, may be normalized *)
        precond: term,                (* Precondition, abstracted over abs-arguments *)
        prems : term list,            (* Premises not depending on arguments *)
        ahead: term * bool,           (* Abstract function, has leading RETURN *)
        chead: term * bool,           (* Concrete function, has leading return *)
        argrels: (term * bool) list,  (* Argument relations, preserved (keep-flag) *)
        result_rel: term              (* Result relation *)
      }
  
      val analyze_hnr: Proof.context -&gt; thm -&gt; hnr_analysis
      val pretty_hnr_analysis: Proof.context -&gt; hnr_analysis -&gt; Pretty.T
      val mk_hfref_thm: Proof.context -&gt; hnr_analysis -&gt; thm
  
  

      (* Simplify precondition of fref/hfref-theorem *)
      val simplify_precond: Proof.context -&gt; thm -&gt; thm

      (* Normalize hfref-theorem after composition *)
      val norm_fcomp_rule: Proof.context -&gt; thm -&gt; thm

      (* Replace &quot;pure ?A&quot; by &quot;?A&#39;&quot; and is_pure constraint, then normalize *)
      val add_pure_constraints_rule: Proof.context -&gt; thm -&gt; thm

      (* Compose fref/hfref and fref theorem, to produce hfref theorem.
        The input theorems may also be in ho-param or hnr form, and
        are converted accordingly.
      *)
      val gen_compose : Proof.context -&gt; thm -&gt; thm -&gt; thm

      (* FCOMP-attribute *)
      val fcomp_attrib: attribute context_parser
    end

    structure Sepref_Rules: SEPREF_RULES = struct

      local open Refine_Util Relators in
        fun binder_rels @{mpat &quot;?F &#8594; ?G&quot;} = F::binder_rels G
          | binder_rels @{mpat &quot;fref _ ?F _&quot;} = strip_prodrel_left F
          | binder_rels _ = []
    
        local 
          fun br_aux @{mpat &quot;_ &#8594; ?G&quot;} = br_aux G
            | br_aux R = R
        in    
          fun body_rel @{mpat &quot;fref _ _ ?G&quot;} = G
            | body_rel R = br_aux R
        end
    
        fun strip_rel R = (binder_rels R, body_rel R)   
    
        fun analyze_rel @{mpat &quot;fref (&#955;_. True) ?R ?S&quot;} = (NONE,strip_prodrel_left R,S)
          | analyze_rel @{mpat &quot;fref ?P ?R ?S&quot;} = (SOME P,strip_prodrel_left R,S)
          | analyze_rel R = let
              val (args,res) = strip_rel R
              val argTuc = 
                   map (fastype_of #&gt; HOLogic.dest_setT #&gt; HOLogic.dest_prodT #&gt; snd) args 
                |&gt; list_prodT_left
              val res = Term.absdummy argTuc res
            in
              (NONE,args,res)
            end
    
        fun mk_triv_precond Rs = absdummy (map rel_absT Rs |&gt; list_prodT_left) @{term True}
    
        fun mk_rel (P,Rs,S) = let 
          val R = list_prodrel_left Rs 
    
          val P = case P of 
              SOME P =&gt; P 
            | NONE =&gt; mk_triv_precond Rs
    
        in 
          @{mk_term &quot;fref ?P ?R ?S&quot;} 
        end
      end


      fun mk_hfprod (a, b) = @{mk_term &quot;?a*<span class="hidden">&#8681;</span><sub>a</sub>?b&quot;}
  
      local 
        fun mk_hfprods_rev [] = @{mk_term &quot;unit_assn<span class="hidden">&#8679;</span><sup>k</sup>&quot;}
          | mk_hfprods_rev [Rk] = Rk
          | mk_hfprods_rev (Rkn::Rks) = mk_hfprod (mk_hfprods_rev Rks, Rkn)
      in
        val mk_hfprods = mk_hfprods_rev o rev
      end


      fun intf_of_assn ctxt t = let
        val orig_ctxt = ctxt
        val (t,ctxt) = yield_singleton (Variable.import_terms false) t ctxt

        val v = TVar ((&quot;T&quot;,0),Proof_Context.default_sort ctxt (&quot;T&quot;,0)) |&gt; Logic.mk_type
        val goal = @{mk_term &quot;Trueprop (intf_of_assn ?t ?v)&quot;}

        val i_of_assn_rls = 
          Named_Theorems_Rev.get ctxt @{named_theorems_rev intf_of_assn}
          @ @{thms intf_of_assn_fallback}

        fun tac ctxt = REPEAT_ALL_NEW (resolve_tac ctxt i_of_assn_rls)

        val thm = Goal.prove ctxt [] [] goal (fn {context,...} =&gt; ALLGOALS (tac context))
        val intf = case Thm.concl_of thm of
            @{mpat &quot;Trueprop (intf_of_assn _ (?v AS<span class="hidden">&#8681;</span><sub>p</sub> TYPE (_)))&quot;} =&gt; v 
          | _ =&gt; raise THM(&quot;Intf_of_assn: Proved a different theorem?&quot;,~1,[thm])

        val intf = singleton (Variable.export_terms ctxt orig_ctxt) intf
          |&gt; Logic.dest_type

      in
        intf
      end

      datatype rthm_type = 
        RT_HOPARAM    (* (_,_) &#8712; _ &#8594; &#8230; &#8594; _ *)
      | RT_FREF       (* (_,_) &#8712; [_]<span class="hidden">&#8681;</span><sub>f</sub> _ &#8594; _ *)
      | RT_HNR        (* hn_refine _ _ _ _ _ *)
      | RT_HFREF      (* (_,_) &#8712; [_]<span class="hidden">&#8681;</span><sub>a</sub> _ &#8594; _ *)
      | RT_OTHER

      fun rthm_type thm =
        case Thm.concl_of thm |&gt; HOLogic.dest_Trueprop of
          @{mpat &quot;(_,_) &#8712; fref _ _ _&quot;} =&gt; RT_FREF
        | @{mpat &quot;(_,_) &#8712; hfref _ _ _&quot;} =&gt; RT_HFREF
        | @{mpat &quot;hn_refine _ _ _ _ _&quot;} =&gt; RT_HNR
        | @{mpat &quot;(_,_) &#8712; _&quot;} =&gt; RT_HOPARAM (* TODO: Distinction between ho-param and fo-param *)
        | _ =&gt; RT_OTHER


      fun to_fref ctxt thm = let
        open Conv
      in  
        case Thm.concl_of thm |&gt; HOLogic.dest_Trueprop of
          @{mpat &quot;(_,_)&#8712;_&#8594;_&quot;} =&gt;
            Local_Defs.unfold0 ctxt @{thms fref_param1} thm
            |&gt; fconv_rule (repeat_conv (Refine_Util.ftop_conv (K (rewr_conv @{thm fref_nest})) ctxt))
            |&gt; Local_Defs.unfold0 ctxt @{thms in_CURRY_conv}
        | @{mpat &quot;(_,_)&#8712;_&quot;} =&gt; thm RS @{thm fref_param0I}   
        | _ =&gt; raise THM (&quot;to_fref: Expected theorem of form (_,_)&#8712;_&quot;,~1,[thm])
      end

      fun to_foparam ctxt thm = let
        val unf_thms = @{thms 
          split_tupled_all prod_rel_simp uncurry_apply cnv_conj_to_meta Product_Type.split}
      in
        case Thm.concl_of thm of
          @{mpat &quot;Trueprop ((_,_) &#8712; fref _ _ _)&quot;} =&gt;
            (@{thm frefD} OF [thm])
            |&gt; forall_intr_vars
            |&gt; Local_Defs.unfold0 ctxt unf_thms
            |&gt; Variable.gen_all ctxt
        | @{mpat &quot;Trueprop ((_,_) &#8712; _)&quot;} =&gt;
            Parametricity.fo_rule thm
        | _ =&gt; raise THM(&quot;Expected parametricity or fref theorem&quot;,~1,[thm])
      end

      fun to_hnr ctxt thm =
        (thm RS @{thm hf2hnr})
        |&gt; Local_Defs.unfold0 ctxt @{thms to_hnr_prod_fst_snd keep_drop_sels} (* Resolve fst and snd over *<span class="hidden">&#8681;</span><sub>a</sub> and R<span class="hidden">&#8679;</span><sup>k</sup>, R<span class="hidden">&#8679;</span><sup>d</sup> *)
        |&gt; Local_Defs.unfold0 ctxt @{thms hnr_uncurry_unfold} (* Resolve products for uncurried parameters *)
        |&gt; Local_Defs.unfold0 ctxt @{thms uncurry_apply uncurry_APP sep_conj_empty&#39; split} (* Remove the uncurry modifiers, the emp-dummy, and unfold product cases *)
        |&gt; Local_Defs.unfold0 ctxt @{thms hn_ctxt_ctxt_fix_conv} (* Remove duplicate hn_ctxt tagging *)
        |&gt; Local_Defs.unfold0 ctxt @{thms all_to_meta imp_to_meta HOL.True_implies_equals HOL.implies_True_equals Pure.triv_forall_equality cnv_conj_to_meta} (* Convert to meta-level, remove vacuous condition *)
        |&gt; Local_Defs.unfold0 ctxt (Named_Theorems.get ctxt @{named_theorems to_hnr_post}) (* Post-Processing *)
        |&gt; Goal.norm_result ctxt
        |&gt; Conv.fconv_rule Thm.eta_conversion

      (* Convert schematic hfref-goal to hn_refine goal *)  
      fun prepare_hfref_synth_tac ctxt = let
        val i_of_assn_rls = 
          Named_Theorems_Rev.get ctxt @{named_theorems_rev intf_of_assn}
          @ @{thms intf_of_assn_fallback}

        val to_hnr_post_rls = 
          Named_Theorems.get ctxt @{named_theorems to_hnr_post}

        val i_of_assn_tac = (
          REPEAT&#39; (
            DETERM o dresolve_tac ctxt @{thms hfsynth_ID_R_D}
            THEN&#39; DETERM o SOLVED&#39; (REPEAT_ALL_NEW (resolve_tac ctxt i_of_assn_rls))
          )
        )
      in
        (* Note: To re-use the to_hnr infrastructure, we first work with
          $-tags on the abstract function, which are finally removed.
        *)
        resolve_tac ctxt @{thms hfsynth_hnr_from_hfI} THEN_ELSE&#39; (
          SELECT_GOAL (
            unfold_tac ctxt @{thms to_hnr_prod_fst_snd keep_drop_sels hf_pres_fst} (* Distribute fst,snd over product and hf_pres *)
            THEN unfold_tac ctxt @{thms hnr_uncurry_unfold hfsynth_ID_R_uncurry_unfold} (* Curry parameters *)
            THEN unfold_tac ctxt @{thms uncurry_apply uncurry_APP sep_conj_empty&#39; split} (* Curry parameters (II) and remove emp assertion *)
            (*THEN unfold_tac ctxt @{thms hn_ctxt_ctxt_fix_conv} (* Remove duplicate hn_ctxt (Should not be necessary) *)*)
            THEN unfold_tac ctxt @{thms all_to_meta imp_to_meta HOL.True_implies_equals HOL.implies_True_equals Pure.triv_forall_equality cnv_conj_to_meta} (* Convert precondition to meta-level *)
            THEN ALLGOALS i_of_assn_tac (* Generate _::<span class="hidden">&#8681;</span><sub>i</sub>_ premises*)
            THEN unfold_tac ctxt to_hnr_post_rls (* Postprocessing *)
            THEN unfold_tac ctxt @{thms APP_def} (* Get rid of $ - tags *)
          )
        ,
          K all_tac
        )
      end


      (************************************)  
      (* Analyze hnr *)
      structure Termtab2 = Table(
        type key = term * term 
        val ord = prod_ord Term_Ord.fast_term_ord Term_Ord.fast_term_ord);
  
      type hnr_analysis = {
        thm: thm,                     
        precond: term,                
        prems : term list,
        ahead: term * bool,           
        chead: term * bool,           
        argrels: (term * bool) list,  
        result_rel: term              
      }
  
    
      fun analyze_hnr (ctxt:Proof.context) thm = let
    
        (* Debug information: Stores string*term pairs, which are pretty-printed on error *)
        val dbg = Unsynchronized.ref []
        fun add_dbg msg ts = (
          dbg := (msg,ts) :: !dbg;
          ()
        )
        fun pretty_dbg (msg,ts) = Pretty.block [
          Pretty.str msg,
          Pretty.str &quot;:&quot;,
          Pretty.brk 1,
          Pretty.list &quot;[&quot; &quot;]&quot; (map (Syntax.pretty_term ctxt) ts)
        ]
        fun pretty_dbgs l = map pretty_dbg l |&gt; Pretty.fbreaks |&gt; Pretty.block
    
        fun trace_dbg msg = Pretty.block [Pretty.str msg, Pretty.fbrk, pretty_dbgs (rev (!dbg))] |&gt; Pretty.string_of |&gt; tracing
    
        fun fail msg = (trace_dbg msg; raise THM(msg,~1,[thm])) 
        fun assert cond msg = cond orelse fail msg;
    
    
        (* Heads may have a leading return/RETURN.
          The following code strips off the leading return, unless it has the form
          &quot;return x&quot; for an argument x
        *)
        fun check_strip_leading args t f = (* Handle the case RETURN x, where x is an argument *)
          if Termtab.defined args f then (t,false) else (f,true)
    
        fun strip_leading_RETURN args (t as @{mpat &quot;RETURN$(?f)&quot;}) = check_strip_leading args t f
          | strip_leading_RETURN args (t as @{mpat &quot;RETURN ?f&quot;}) = check_strip_leading args t f
          | strip_leading_RETURN _ t = (t,false)
    
        fun strip_leading_return args (t as @{mpat &quot;return$(?f)&quot;}) = check_strip_leading args t f
            | strip_leading_return args (t as @{mpat &quot;return ?f&quot;}) = check_strip_leading args t f
            | strip_leading_return _ t = (t,false)
    
    
        (* The following code strips the arguments of the concrete or abstract
          function. It knows how to handle APP-tags ($), and stops at PR_CONST-tags.
    
          Moreover, it only strips actual arguments that occur in the 
          precondition-section of the hn_refine-statement. This ensures
          that non-arguments, like maxsize, are treated correctly.
        *)    
        fun strip_fun _ (t as @{mpat &quot;PR_CONST _&quot;}) = (t,[])
          | strip_fun s (t as @{mpat &quot;?f$?x&quot;}) = check_arg s t f x
          | strip_fun s (t as @{mpat &quot;?f ?x&quot;}) = check_arg s t f x
          | strip_fun _ f = (f,[])
        and check_arg s t f x = 
            if Termtab.defined s x then
              strip_fun s f |&gt; apsnd (curry op :: x)
            else (t,[])  
    
        (* Arguments in the pre/postcondition are wrapped into hn_ctxt tags. 
          This function strips them off. *)    
        fun dest_hn_ctxt @{mpat &quot;hn_ctxt ?R ?a ?c&quot;} = ((a,c),R)
          | dest_hn_ctxt _ = fail &quot;Invalid hn_ctxt parameter in pre or postcondition&quot;
    
    
        fun dest_hn_refine @{mpat &quot;(hn_refine ?G ?c ?G&#39; ?R ?a)&quot;} = (G,c,G&#39;,R,a) 
          | dest_hn_refine _ = fail &quot;Conclusion is not a hn_refine statement&quot;
    
        (*
          Strip separation conjunctions. Special case for &quot;emp&quot;, which is ignored. 
        *)  
        fun is_emp @{mpat &#9633;} = true | is_emp _ = false
  
        val strip_star&#39; = Sepref_Basic.strip_star #&gt; filter (not o is_emp)
  
        (* Compare Termtab2s for equality of keys *)  
        fun pairs_eq pairs1 pairs2 = 
                  Termtab2.forall (Termtab2.defined pairs1 o fst) pairs2
          andalso Termtab2.forall (Termtab2.defined pairs2 o fst) pairs1
    
    
        fun atomize_prem @{mpat &quot;Trueprop ?p&quot;} = p
          | atomize_prem _ = fail &quot;Non-atomic premises&quot;
    
        (* Make HOL conjunction list *)  
        fun mk_conjs [] = @{const True}
          | mk_conjs [p] = p
          | mk_conjs (p::ps) = HOLogic.mk_binop @{const_name &quot;HOL.conj&quot;} (p,mk_conjs ps)
    
    
        (***********************)      
        (* Start actual analysis *)
    
        val _ = add_dbg &quot;thm&quot; [Thm.prop_of thm]
        val prems = Thm.prems_of thm
        val concl = Thm.concl_of thm |&gt; HOLogic.dest_Trueprop
        val (G,c,G&#39;,R,a) = dest_hn_refine concl
    
        val pre_pairs = G 
          |&gt; strip_star&#39;
          |&gt; tap (add_dbg &quot;precondition&quot;)
          |&gt; map dest_hn_ctxt
          |&gt; Termtab2.make
    
        val post_pairs = G&#39; 
          |&gt; strip_star&#39;
          |&gt; tap (add_dbg &quot;postcondition&quot;)
          |&gt; map dest_hn_ctxt
          |&gt; Termtab2.make
    
        val _ = assert (pairs_eq pre_pairs post_pairs) 
          &quot;Parameters in precondition do not match postcondition&quot;
    
        val aa_set = pre_pairs |&gt; Termtab2.keys |&gt; map fst |&gt; Termtab.make_set
        val ca_set = pre_pairs |&gt; Termtab2.keys |&gt; map snd |&gt; Termtab.make_set
    
        val (a,leading_RETURN) = strip_leading_RETURN aa_set a
        val (c,leading_return) = strip_leading_return ca_set c
    
        val _ = add_dbg &quot;stripped abstract term&quot; [a]
        val _ = add_dbg &quot;stripped concrete term&quot; [c]
    
        val (ahead,aargs) = strip_fun aa_set a;
        val (chead,cargs) = strip_fun ca_set c;
    
        val _ = add_dbg &quot;abstract head&quot; [ahead]
        val _ = add_dbg &quot;abstract args&quot; aargs
        val _ = add_dbg &quot;concrete head&quot; [chead]
        val _ = add_dbg &quot;concrete args&quot; cargs
    
    
        val _ = assert (length cargs = length aargs) &quot;Different number of abstract and concrete arguments&quot;;
    
        val _ = assert (not (has_duplicates op aconv aargs)) &quot;Duplicate abstract arguments&quot;
        val _ = assert (not (has_duplicates op aconv cargs)) &quot;Duplicate concrete arguments&quot;
    
        val argpairs = aargs ~~ cargs
        val ap_set = Termtab2.make_set argpairs
        val _ = assert (pairs_eq pre_pairs ap_set) &quot;Arguments from pre/postcondition do not match operation&#39;s arguments&quot;
    
        val pre_rels = map (the o (Termtab2.lookup pre_pairs)) argpairs
        val post_rels = map (the o (Termtab2.lookup post_pairs)) argpairs
    
        val _ = add_dbg &quot;pre-rels&quot; pre_rels
        val _ = add_dbg &quot;post-rels&quot; post_rels

        fun adjust_hf_pres @{mpat &quot;snd (?R<span class="hidden">&#8679;</span><sup>k</sup>)&quot;} = R
          | adjust_hf_pres t = t
          
        val post_rels = map adjust_hf_pres post_rels
    
        fun is_invalid R @{mpat &quot;invalid_assn ?R&#39;&quot;} = R aconv R&#39;
          | is_invalid _ @{mpat &quot;snd (_<span class="hidden">&#8679;</span><sup>d</sup>)&quot;} = true
          | is_invalid _ _ = false
    
        fun is_keep (R,R&#39;) =
          if R aconv R&#39; then true
          else if is_invalid R R&#39; then false
          else fail &quot;Mismatch between pre and post relation for argument&quot;
    
        val keep = map is_keep (pre_rels ~~ post_rels)
    
        val argrels = pre_rels ~~ keep

        val aa_set = Termtab.make_set aargs
        val ca_set = Termtab.make_set cargs

        fun is_precond t =
          (exists_subterm (Termtab.defined ca_set) t andalso fail &quot;Premise contains concrete argument&quot;)
          orelse exists_subterm (Termtab.defined aa_set) t

        val (preconds, prems) = split is_precond prems  
    
        val precond = 
          map atomize_prem preconds 
          |&gt; mk_conjs
          |&gt; fold lambda aargs
    
        val _ = add_dbg &quot;precond&quot; [precond]
        val _ = add_dbg &quot;prems&quot; prems
    
      in
        {
          thm = thm,
          precond = precond,
          prems = prems,
          ahead = (ahead,leading_RETURN),
          chead = (chead,leading_return),
          argrels = argrels,
          result_rel = R
        }
      end  
    
      fun pretty_hnr_analysis 
        ctxt 
        ({thm,precond,ahead,chead,argrels,result_rel,...}) 
        : Pretty.T =
      let  
        val _ = thm (* Suppress unused warning for thm *)

        fun pretty_argrel (R,k) = Pretty.block [
          Syntax.pretty_term ctxt R,
          if k then Pretty.str &quot;<span class="hidden">&#8679;</span><sup>k</sup>&quot; else Pretty.str &quot;<span class="hidden">&#8679;</span><sup>d</sup>&quot;
        ]
    
        val pretty_chead = case chead of 
          (t,false) =&gt; Syntax.pretty_term ctxt t 
        | (t,true) =&gt; Pretty.block [Pretty.str &quot;return &quot;, Syntax.pretty_term ctxt t]

        val pretty_ahead = case ahead of 
          (t,false) =&gt; Syntax.pretty_term ctxt t 
        | (t,true) =&gt; Pretty.block [Pretty.str &quot;RETURN &quot;, Syntax.pretty_term ctxt t]

      in
        Pretty.fbreaks [
          (*Display.pretty_thm ctxt thm,*)
          Pretty.block [ 
            Pretty.enclose &quot;[&quot; &quot;]&quot; [pretty_chead, pretty_ahead],
            Pretty.enclose &quot;[&quot; &quot;]&quot; [Syntax.pretty_term ctxt precond],
            Pretty.brk 1,
            Pretty.block (Pretty.separate &quot; &#8594;&quot; (map pretty_argrel argrels @ [Syntax.pretty_term ctxt result_rel]))
          ]
        ] |&gt; Pretty.block
    
      end
    
    
      fun mk_hfref_thm 
        ctxt 
        ({thm,precond,prems,ahead,chead,argrels,result_rel}) = 
      let
    
        fun mk_keep (R,true) = @{mk_term &quot;?R<span class="hidden">&#8679;</span><sup>k</sup>&quot;}
          | mk_keep (R,false) = @{mk_term &quot;?R<span class="hidden">&#8679;</span><sup>d</sup>&quot;}
    
        (* TODO: Move, this is of general use! *)  
        fun mk_uncurry f = @{mk_term &quot;uncurry ?f&quot;}  
      
        (* Uncurry function for the given number of arguments. 
          For zero arguments, add a unit-parameter.
        *)
        fun rpt_uncurry n t =
          if n=0 then @{mk_term &quot;uncurry0 ?t&quot;}
          else if n=1 then t 
          else funpow (n-1) mk_uncurry t
      
        (* Rewrite uncurried lambda&#39;s to &#955;(_,_). _ form. Use top-down rewriting
          to correctly handle nesting to the left. 
    
          TODO: Combine with abstraction and  uncurry-procedure,
            and mark the deviation about uncurry as redundant 
            intermediate step to be eliminated.
        *)  
        fun rew_uncurry_lambda t = let
          val rr = map (Logic.dest_equals o Thm.prop_of) @{thms uncurry_def uncurry0_def}
          val thy = Proof_Context.theory_of ctxt
        in 
          Pattern.rewrite_term_top thy rr [] t 
        end  
    
        (* Shortcuts for simplification tactics *)
        fun gsimp_only ctxt sec = let
          val ss = put_simpset HOL_basic_ss ctxt |&gt; sec
        in asm_full_simp_tac ss end
    
        fun simp_only ctxt thms = gsimp_only ctxt (fn ctxt =&gt; ctxt addsimps thms)
    
    
        (********************************)
        (* Build theorem statement *)
        (* &#10214;prems&#10215; &#10233; (chead,ahead) &#8712; [precond] rels &#8594; R *)
    
        (* Uncurry precondition *)
        val num_args = length argrels
        val precond = precond
          |&gt; rpt_uncurry num_args
          |&gt; rew_uncurry_lambda (* Convert to nicer &#955;((...,_),_) - form*)

        (* Re-attach leading RETURN/return *)
        fun mk_RETURN (t,r) = if r then 
            let
              val T = funpow num_args range_type (fastype_of (fst ahead))
              val tRETURN = Const (@{const_name RETURN}, T --&gt; Type(@{type_name nres},[T]))
            in
              Refine_Util.mk_compN num_args tRETURN t
            end  
          else t
    
        fun mk_return (t,r) = if r then @{mk_term &quot;return ?t :: _ llM&quot;}
            (*let
              val T = funpow num_args range_type (fastype_of (fst chead))
              val tRETURN = Const (@{const_name return}, T --&gt; Type(@{type_name llvm_memory},[T]))
            in
              Refine_Util.mk_compN num_args tRETURN t
            end  *)
          else t
          
        (* Hrmpf!: Gone for good from 2015&#8594;2016. Inserting ctxt-based substitute here. *)  
        fun certify_inst ctxt (instT, inst) =
         (map (apsnd (Thm.ctyp_of ctxt)) instT,
          map (apsnd (Thm.cterm_of ctxt)) inst);

        (*  
        fun mk_RETURN (t,r) = if r then @{mk_term &quot;RETURN o ?t&quot;} else t
        fun mk_return (t,r) = if r then @{mk_term &quot;return o ?t&quot;} else t
        *)
    
        (* Uncurry abstract and concrete function, append leading return *)
        val ahead = ahead |&gt; mk_RETURN |&gt; rpt_uncurry num_args  
        val chead = chead |&gt; mk_return |&gt; rpt_uncurry num_args 
    
        (* Add keep-flags and summarize argument relations to product *)
        val argrel = map mk_keep argrels |&gt; rev (* TODO: Why this rev? *) |&gt; mk_hfprods
    
        (* Produce final result statement *)
        
        val _ = @{print} chead
        val _ = @{print} (fastype_of chead)
        
        val result = @{mk_term &quot;Trueprop ((?chead,?ahead) &#8712; [?precond]<span class="hidden">&#8681;</span><sub>a</sub> ?argrel &#8594; ?result_rel)&quot;}
        val result = Logic.list_implies (prems,result)
    
        (********************************)
        (* Prove theorem *)
    
        (* Create context and import result statement and original theorem *)
        val orig_ctxt = ctxt
        (*val thy = Proof_Context.theory_of ctxt*)
        val (insts, ctxt) = Variable.import_inst true [result] ctxt
        val insts&#39; = certify_inst ctxt insts
        val result = Term_Subst.instantiate insts result
        val thm = Thm.instantiate insts&#39; thm
    
        (* Unfold APP tags. This is required as some APP-tags have also been unfolded by analysis *)
        val thm = Local_Defs.unfold0 ctxt @{thms APP_def} thm
    
        (* Tactic to prove the theorem. 
          A first step uses hfrefI to get a hnr-goal.
          This is then normalized in several consecutive steps, which 
            get rid of uncurrying. Finally, the original theorem is used for resolution,
            where the pre- and postcondition, and result relation are connected with 
            a consequence rule, to handle unfolded hn_ctxt-tags, re-ordered relations,
            and introduced unit-parameters (TODO: 
              Mark artificially introduced unit-parameter specially, it may get confused 
              with intentional unit-parameter, e.g., functional empty_set ()!)
    
          *)
        fun tac ctxt = 
                resolve_tac ctxt @{thms hfrefI}
          THEN&#39; gsimp_only ctxt (fn c =&gt; c 
            addsimps @{thms uncurry_def hn_ctxt_def uncurry0_def
                            keep_drop_sels uc_hfprod_sel o_apply
                            APP_def}
            |&gt; Splitter.add_split @{thm prod.split}
          ) 
    
          THEN&#39; TRY o (
            REPEAT_ALL_NEW (match_tac ctxt @{thms allI impI})
            THEN&#39; simp_only ctxt @{thms Product_Type.split prod.inject})
    
          THEN&#39; TRY o REPEAT_ALL_NEW (ematch_tac ctxt @{thms conjE})
          THEN&#39; TRY o hyp_subst_tac ctxt
          THEN&#39; simp_only ctxt @{thms triv_forall_equality}
          THEN&#39; (
            resolve_tac ctxt @{thms hn_refine_cons[rotated]} 
            THEN&#39; (resolve_tac ctxt [thm] THEN_ALL_NEW assume_tac ctxt))
          THEN_ALL_NEW simp_only ctxt 
            @{thms hn_ctxt_def entails_refl pure_unit_rel_eq_empty
              mult_ac mult_1 mult_1_right keep_drop_sels}  
    
        (* Prove theorem *)  
        val result = Thm.cterm_of ctxt result
        val rthm = Goal.prove_internal ctxt [] result (fn _ =&gt; ALLGOALS (tac ctxt))
    
        (* Export statement to original context *)
        val rthm = singleton (Variable.export ctxt orig_ctxt) rthm
    
        (* Post-processing *)
        val rthm = Local_Defs.unfold0 ctxt (Named_Theorems.get ctxt @{named_theorems to_hfref_post}) rthm

      in
        rthm
      end
  
      fun to_hfref ctxt = analyze_hnr ctxt #&gt; mk_hfref_thm ctxt




      (***********************************)
      (* Composition *)

      local
        fun norm_set_of ctxt = {
          trans_rules = Named_Theorems.get ctxt @{named_theorems fcomp_norm_trans},
          cong_rules = Named_Theorems.get ctxt @{named_theorems fcomp_norm_cong},
          norm_rules = Named_Theorems.get ctxt @{named_theorems fcomp_norm_norm},
          refl_rules = Named_Theorems.get ctxt @{named_theorems fcomp_norm_refl}
        }
    
        fun init_rules_of ctxt = Named_Theorems.get ctxt @{named_theorems fcomp_norm_init}
        fun unfold_rules_of ctxt = Named_Theorems.get ctxt @{named_theorems fcomp_norm_unfold}
        fun simp_rules_of ctxt = Named_Theorems.get ctxt @{named_theorems fcomp_norm_simps}

      in  
        fun norm_fcomp_rule ctxt = let
          open PO_Normalizer Refine_Util
          val norm1 = gen_norm_rule (init_rules_of ctxt) (norm_set_of ctxt) ctxt
          val norm2 = Local_Defs.unfold0 ctxt (unfold_rules_of ctxt)
          val norm3 = Conv.fconv_rule (
            Simplifier.asm_full_rewrite 
              (put_simpset HOL_basic_ss ctxt addsimps simp_rules_of ctxt))
    
          val norm = changed_rule (try_rule norm1 o try_rule norm2 o try_rule norm3)
        in
          repeat_rule norm
        end
      end  

      fun add_pure_constraints_rule ctxt thm = let
        val orig_ctxt = ctxt
    
        val t = Thm.prop_of thm
    
        fun 
          cnv (@{mpat (typs) &quot;pure (mpaq_STRUCT (mpaq_Var ?x _) :: (?&#39;v_c&#215;?&#39;v_a) set)&quot;}) = 
          let
            val T = a --&gt; c --&gt; @{typ assn}
            val t = Var (x,T)
            val t = @{mk_term &quot;(the_pure ?t)&quot;}
          in
            [(x,T,t)]
          end
        | cnv (t$u) = union op= (cnv t) (cnv u)
        | cnv (Abs (_,_,t)) = cnv t  
        | cnv _ = []
    
        val pvars = cnv t
    
        val _ = (pvars |&gt; map #1 |&gt; has_duplicates op=) 
          andalso raise TERM (&quot;Duplicate indexname with different type&quot;,[t]) (* This should not happen *)
    
        val substs = map (fn (x,_,t) =&gt; (x,t)) pvars
    
        val t&#39; = subst_Vars substs t  
    
        fun mk_asm (x,T,_) = let
          val t = Var (x,T)
          val t = @{mk_term &quot;Trueprop (CONSTRAINT is_pure ?t)&quot;}
        in
          t
        end
    
        val assms = map mk_asm pvars
    
        fun add_prems prems t = let
          val prems&#39; = Logic.strip_imp_prems t
          val concl = Logic.strip_imp_concl t
        in
          Logic.list_implies (prems@prems&#39;, concl)
        end
    
        val t&#39; = add_prems assms t&#39;
    
        val (t&#39;,ctxt) = yield_singleton (Variable.import_terms true) t&#39; ctxt
    
        val thm&#39; = Goal.prove_internal ctxt [] (Thm.cterm_of ctxt t&#39;) (fn _ =&gt; 
          ALLGOALS (resolve_tac ctxt [thm] THEN_ALL_NEW assume_tac ctxt))
    
        val thm&#39; = norm_fcomp_rule ctxt thm&#39;

        val thm&#39; = singleton (Variable.export ctxt orig_ctxt) thm&#39;
      in
        thm&#39;
      end  


      val cfg_simp_precond = 
        Attrib.setup_config_bool @{binding fcomp_simp_precond} (K true)

      local
        fun mk_simp_thm ctxt t = let
          val st = t
            |&gt; HOLogic.mk_Trueprop
            |&gt; Thm.cterm_of ctxt
            |&gt; Goal.init
      
          val ctxt = Context_Position.set_visible false ctxt  
          val ctxt = ctxt addsimps (
              refine_pw_simps.get ctxt 
            @ Named_Theorems.get ctxt @{named_theorems fcomp_prenorm_simps}
            @ @{thms split_tupled_all cnv_conj_to_meta}  
            )
          
          val trace_incomplete_transfer_tac =
            COND (Thm.prems_of #&gt; exists (strip_all_body #&gt; Logic.strip_imp_concl #&gt; Term.is_open))
              (print_tac ctxt &quot;Failed transfer from intermediate level:&quot;) all_tac
    
          val tac = 
            ALLGOALS (resolve_tac ctxt @{thms auto_weaken_pre_comp_PRE_I} )
            THEN ALLGOALS (Simplifier.asm_full_simp_tac ctxt)
            THEN trace_incomplete_transfer_tac
            THEN ALLGOALS (TRY o filter_prems_tac ctxt (K false))
            THEN Local_Defs.unfold0_tac ctxt [Drule.triv_forall_equality]
      
          val st&#39; = tac st |&gt; Seq.take 1 |&gt; Seq.list_of
          val thm = case st&#39; of [st&#39;] =&gt; Goal.conclude st&#39; | _ =&gt; raise THM(&quot;Simp_Precond: Simp-Tactic failed&quot;,~1,[st])
    
          (* Check generated premises for leftover intermediate stuff *)
          val _ = exists (Logic.is_all) (Thm.prems_of thm) 
            andalso raise THM(&quot;Simp_Precond: Transfer from intermediate level failed&quot;,~1,[thm])
    
          val thm = 
             thm
          (*|&gt; map (Simplifier.asm_full_simplify ctxt)*)
          |&gt; Conv.fconv_rule (Object_Logic.atomize ctxt)
          |&gt; Local_Defs.unfold0 ctxt @{thms auto_weaken_pre_to_imp_nf}
    
          val thm = case Thm.concl_of thm of
            @{mpat &quot;Trueprop (_ &#10230; _)&quot;} =&gt; thm
          | @{mpat &quot;Trueprop _&quot;} =&gt; thm RS @{thm auto_weaken_pre_add_dummy_imp}  
          | _ =&gt; raise THM(&quot;Simp_Precond: Generated odd theorem, expected form &#39;P&#10230;Q&#39;&quot;,~1,[thm])
    
    
        in
          thm
        end
      in  
        fun simplify_precond ctxt thm = let
          val orig_ctxt = ctxt
          val thm = Refine_Util.OF_fst @{thms auto_weaken_pre_init} [asm_rl,thm]
          val thm = 
            Local_Defs.unfold0 ctxt @{thms split_tupled_all} thm
            OF @{thms auto_weaken_pre_uncurry_start}
      
          fun rec_uncurry thm =
            case try (fn () =&gt; thm OF @{thms auto_weaken_pre_uncurry_step}) () of
              NONE =&gt; thm OF @{thms auto_weaken_pre_uncurry_finish}
            | SOME thm =&gt; rec_uncurry thm  
      
          val thm = rec_uncurry thm  
            |&gt; Conv.fconv_rule Thm.eta_conversion
      
          val t = case Thm.prems_of thm of
            t::_ =&gt; t | _ =&gt; raise THM(&quot;Simp-Precond: Expected at least one premise&quot;,~1,[thm])
      
          val (t,ctxt) = yield_singleton (Variable.import_terms false) t ctxt
          val ((_,t),ctxt) = Variable.focus NONE t ctxt
          val t = case t of
            @{mpat &quot;Trueprop (_ &#10230; ?t)&quot;} =&gt; t | _ =&gt; raise TERM(&quot;Simp_Precond: Expected implication&quot;,[t])
      
          val simpthm = mk_simp_thm ctxt t  
            |&gt; singleton (Variable.export ctxt orig_ctxt)
            
          val thm = thm OF [simpthm]  
          val thm = Local_Defs.unfold0 ctxt @{thms prod_casesK} thm
        in
          thm
        end

        fun simplify_precond_if_cfg ctxt =
          if Config.get ctxt cfg_simp_precond then
            simplify_precond ctxt
          else I

      end  

      (* fref O fref *)
      fun compose_ff ctxt A B = 
          (@{thm fref_compI_PRE} OF [A,B])
        |&gt; norm_fcomp_rule ctxt
        |&gt; simplify_precond_if_cfg ctxt
        |&gt; Conv.fconv_rule Thm.eta_conversion

      (* hfref O fref *)
      fun compose_hf ctxt A B =
          (@{thm hfref_compI_PRE} OF [A,B])
        |&gt; norm_fcomp_rule ctxt
        |&gt; simplify_precond_if_cfg ctxt
        |&gt; Conv.fconv_rule Thm.eta_conversion
        |&gt; add_pure_constraints_rule ctxt
        |&gt; Conv.fconv_rule Thm.eta_conversion

      fun ensure_fref ctxt thm = case rthm_type thm of
        RT_HOPARAM =&gt; to_fref ctxt thm
      | RT_FREF =&gt; thm
      | _ =&gt; raise THM(&quot;Expected parametricity or fref theorem&quot;,~1,[thm])

      fun ensure_fref_nres ctxt thm = let
        val thm = ensure_fref ctxt thm
      in
        case Thm.concl_of thm of
          @{mpat (typs) &quot;Trueprop (_&#8712;fref _ _ (_::_ &#8658; (_ nres&#215;_)set))&quot;} =&gt; thm
        | @{mpat &quot;Trueprop ((_,_)&#8712;fref _ _ _)&quot;} =&gt; 
            (thm RS @{thm ensure_fref_nresI}) |&gt; Local_Defs.unfold0 ctxt @{thms ensure_fref_nres_unfold}
        | _ =&gt; raise THM(&quot;Expected fref-theorem&quot;,~1,[thm])
      end

      fun ensure_hfref ctxt thm = case rthm_type thm of
        RT_HNR =&gt; to_hfref ctxt thm
      | RT_HFREF =&gt; thm
      | _ =&gt; raise THM(&quot;Expected hnr or hfref theorem&quot;,~1,[thm])

      fun ensure_hnr ctxt thm = case rthm_type thm of
        RT_HNR =&gt; thm
      | RT_HFREF =&gt; to_hnr ctxt thm
      | _ =&gt; raise THM(&quot;Expected hnr or hfref theorem&quot;,~1,[thm])

      fun gen_compose ctxt A B = let
        val rtA = rthm_type A
      in
        if rtA = RT_HOPARAM orelse rtA = RT_FREF then
          compose_ff ctxt (ensure_fref ctxt A) (ensure_fref ctxt B)
        else  
          compose_hf ctxt (ensure_hfref ctxt A) ((ensure_fref_nres ctxt B))
        
      end

      val parse_fcomp_flags = Refine_Util.parse_paren_lists 
        (Refine_Util.parse_bool_config &quot;prenorm&quot; cfg_simp_precond)

      val fcomp_attrib = parse_fcomp_flags |-- Attrib.thm &gt;&gt; (fn B =&gt; Thm.rule_attribute [] (fn context =&gt; fn A =&gt; 
      let
        val ctxt = Context.proof_of context
      in  
        gen_compose ctxt A B
      end))

    end
  &#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>to_fref</span><span> </span><span class="delimiter">=</span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*
    Scan.succeed (Thm.rule_attribute [] (Sepref_Rules.to_fref o Context.proof_of))
  *}</span></span></span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Convert parametricity theorem to uncurried fref-form&quot;</span></span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>to_foparam</span><span> </span><span class="delimiter">=</span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*
      Scan.succeed (Thm.rule_attribute [] (Sepref_Rules.to_foparam o Context.proof_of))
  *}</span></span></span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Convert param or fref rule to first order rule&#8250;</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Overloading existing param_fo - attribute from Parametricity.thy *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>param_fo</span><span> </span><span class="delimiter">=</span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*
      Scan.succeed (Thm.rule_attribute [] (Sepref_Rules.to_foparam o Context.proof_of))
  *}</span></span></span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Convert param or fref rule to first order rule&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>to_hnr</span><span> </span><span class="delimiter">=</span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*
    Scan.succeed (Thm.rule_attribute [] (Sepref_Rules.to_hnr o Context.proof_of))
  *}</span></span></span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Convert hfref-rule to hnr-rule&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>to_hfref</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Scan.succeed (
      Thm.rule_attribute [] (Context.proof_of #&gt; Sepref_Rules.to_hfref)
    )&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Convert hnr to hfref theorem&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>ensure_fref_nres</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Scan.succeed (
      Thm.rule_attribute [] (Context.proof_of #&gt; Sepref_Rules.ensure_fref_nres)
    )&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>sepref_dbg_norm_fcomp_rule</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Scan.succeed (
      Thm.rule_attribute [] (Context.proof_of #&gt; Sepref_Rules.norm_fcomp_rule)
    )&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>sepref_simplify_precond</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Scan.succeed (
      Thm.rule_attribute [] (Context.proof_of #&gt; Sepref_Rules.simplify_precond)
    )&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Simplify precondition of fref/hfref-theorem&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>FCOMP</span><span> </span><span class="delimiter">=</span><span> </span><span>Sepref_Rules.fcomp_attrib</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Composition of refinement rules&quot;</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


