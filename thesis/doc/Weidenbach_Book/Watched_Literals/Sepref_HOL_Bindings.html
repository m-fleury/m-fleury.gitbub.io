<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Sepref_HOL_Bindings (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Sepref_HOL_Bindings</h1>

<span class="command">theory</span> <span class="name">Sepref_HOL_Bindings</span><br/>
<span class="keyword">imports</span> <a href="Sepref_Tool.html"><span class="name">Sepref_Tool</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;HOL Setup&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Sepref_HOL_Bindings</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Sepref_Tool</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Assertion Annotation&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Annotate an assertion to a term. The term must then be refined with this assertion.&#8250;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Version for monadic expressions.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ASSN_ANNOT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; &#39;ai &#8658; assn) &#8658; &#39;a &#8658; &#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ASSN_ANNOT A x &#8801; x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;ai &#8658; assn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;PR_CONST (ASSN_ANNOT A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ASSN_ANNOT$A &#8801; UNPROTECT (ASSN_ANNOT A)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(return o (&#955;x. x), RETURN o PR_CONST (ASSN_ANNOT A)) &#8712; A<span class="hidden">&#8679;</span><sup>d</sup>&#8594;<span class="hidden">&#8681;</span><sub>a</sub>A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_to_hoare</span><span> </span><span>vcg</span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annotate_assn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8801; ASSN_ANNOT A x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Identity Relations&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID R &#8801; R=Id&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_BELOW_ID R &#8801; R&#8838;Id&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID Id&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID R1 &#10233; IS_ID R2 &#10233; IS_ID (R1 &#8594; R2)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID R &#10233; IS_ID (&#10216;R&#10217;option_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID R &#10233; IS_ID (&#10216;R&#10217;list_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID R1 &#10233; IS_ID R2 &#10233; IS_ID (R1 &#215;<span class="hidden">&#8681;</span><sub>r</sub> R2)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID R1 &#10233; IS_ID R2 &#10233; IS_ID (&#10216;R1,R2&#10217;sum_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_ID_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_BELOW_ID Id&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_BELOW_ID R &#10233; IS_BELOW_ID (&#10216;R&#10217;option_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_BELOW_ID R1 &#10233; IS_BELOW_ID R2 &#10233; IS_BELOW_ID (R1 &#215;<span class="hidden">&#8681;</span><sub>r</sub> R2)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_BELOW_ID R1 &#10233; IS_BELOW_ID R2 &#10233; IS_BELOW_ID (&#10216;R1,R2&#10217;sum_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_ID_def</span><span> </span><span>IS_BELOW_ID_def</span><span> </span><span>option_rel_def</span><span> </span><span>sum_rel_def</span><span> </span><span>list_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IS_BELOW_ID_fun_rel_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R1&#8839;Id &#10233; IS_BELOW_ID R2 &#10233; IS_BELOW_ID (R1 &#8594; R2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_BELOW_ID_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>fun_relD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>IS_BELOW_ID_fun_rel</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID R1 &#10233; IS_BELOW_ID R2 &#10233; IS_BELOW_ID (R1 &#8594; R2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IS_BELOW_ID_fun_rel_aux</span><span class="delimiter">[</span><span>of</span><span> </span><span>Id</span><span> </span><span>R2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_ID_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IS_BELOW_ID_list_rel</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_BELOW_ID R &#10233; IS_BELOW_ID (&#10216;R&#10217;list_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IS_BELOW_ID_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span> </span><span>l&#39;</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R&#8838;Id&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(l,l&#39;)&#8712;&#10216;R&#10217;list_rel&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l=l&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induction</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IS_ID_imp_BELOW_ID</span><span class="delimiter">[</span><span>constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID R &#10233; IS_BELOW_ID R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_ID_def</span><span> </span><span>IS_BELOW_ID_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Inverse Relation&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_fun_rel_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(A&#8594;B)&#175; = A&#175;&#8594;B&#175;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>fun_relD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_option_rel_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#10216;K&#10217;option_rel)&#175; = &#10216;K&#175;&#10217;option_rel&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>option_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_prod_rel_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P &#215;<span class="hidden">&#8681;</span><sub>r</sub> Q)&#175; = P&#175; &#215;<span class="hidden">&#8681;</span><sub>r</sub> Q&#175;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_sum_rel_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#10216;P,Q&#10217;sum_rel)&#175; = &#10216;P&#175;,Q&#175;&#10217;sum_rel&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_list_rel_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#10216;R&#10217;list_rel)&#175; = &#10216;R&#175;&#10217;list_rel&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>list.rel_flip</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conversep_iff</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>list.rel_flip</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conversep_iff</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>constraint_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Relation.converse_Id</span><span>
</span><span>  </span><span>inv_fun_rel_eq</span><span>
</span><span>  </span><span>inv_option_rel_eq</span><span>
</span><span>  </span><span>inv_prod_rel_eq</span><span>
</span><span>  </span><span>inv_sum_rel_eq</span><span>
</span><span>  </span><span>inv_list_rel_eq</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Single Valued and Total Relations&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Link to other such theories: Transfer, Autoref *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE R &#8801; single_valued (R&#175;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_TOTAL R &#8801; Domain R = UNIV&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_TOTAL R &#8801; Range R = UNIV&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_UNIQUE &#8801; single_valued&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>IS_RIGHT_UNIQUED</span><span> </span><span class="delimiter">=</span><span> </span><span>single_valuedD</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IS_LEFT_UNIQUED</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;IS_LEFT_UNIQUE r; (y, x) &#8712; r; (z, x) &#8712; r&#10215; &#10233; y = z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_UNIQUE_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>single_valuedD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prop2p</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE R = left_unique (rel2p R)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_UNIQUE R = right_unique (rel2p R)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;right_unique (rel2p (R&#175;)) = left_unique (rel2p R)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_TOTAL R = left_total (rel2p R)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_TOTAL R = right_total (rel2p R)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_UNIQUE_def</span><span> </span><span>left_unique_def</span><span> </span><span>single_valued_def</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>right_unique_def</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_TOTAL_def</span><span> </span><span>left_total_def</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_RIGHT_TOTAL_def</span><span> </span><span>right_total_def</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rel2p_def</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2prop</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;left_unique P = IS_LEFT_UNIQUE (p2rel P)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;right_unique P = IS_RIGHT_UNIQUE (p2rel P)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;left_total P = IS_LEFT_TOTAL (p2rel P)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;right_total P = IS_RIGHT_TOTAL (p2rel P)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bi_unique P &#10231; left_unique P &#8743; right_unique P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_UNIQUE_def</span><span> </span><span>left_unique_def</span><span> </span><span>single_valued_def</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>right_unique_def</span><span> </span><span>bi_unique_alt_def</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_TOTAL_def</span><span> </span><span>left_total_def</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_RIGHT_TOTAL_def</span><span> </span><span>right_total_def</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p2rel_def</span><span>
</span><span>    </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>single_valued_Id</span><span>  
</span><span>  </span><span>prod_rel_sv</span><span> 
</span><span>  </span><span>list_rel_sv</span><span> 
</span><span>  </span><span>option_rel_sv</span><span> 
</span><span>  </span><span>sum_rel_sv</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE Id&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE R1 &#10233; IS_LEFT_UNIQUE R2 &#10233; IS_LEFT_UNIQUE (R1&#215;<span class="hidden">&#8681;</span><sub>r</sub>R2)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE R1 &#10233; IS_LEFT_UNIQUE R2 &#10233; IS_LEFT_UNIQUE (&#10216;R1,R2&#10217;sum_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE R &#10233; IS_LEFT_UNIQUE (&#10216;R&#10217;option_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE R &#10233; IS_LEFT_UNIQUE (&#10216;R&#10217;list_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_UNIQUE_def</span><span> </span><span>prod_rel_sv</span><span> </span><span>sum_rel_sv</span><span> </span><span>option_rel_sv</span><span> </span><span>list_rel_sv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IS_LEFT_TOTAL_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_TOTAL R &#10231; (&#8704;x. &#8707;y. (x,y)&#8712;R)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_TOTAL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IS_RIGHT_TOTAL_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_TOTAL R &#10231; (&#8704;x. &#8707;y. (y,x)&#8712;R)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_RIGHT_TOTAL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_TOTAL Id&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_TOTAL R1 &#10233; IS_LEFT_TOTAL R2 &#10233; IS_LEFT_TOTAL (R1&#215;<span class="hidden">&#8681;</span><sub>r</sub>R2)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_TOTAL R1 &#10233; IS_LEFT_TOTAL R2 &#10233; IS_LEFT_TOTAL (&#10216;R1,R2&#10217;sum_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_TOTAL R &#10233; IS_LEFT_TOTAL (&#10216;R&#10217;option_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_TOTAL_alt</span><span> </span><span>sum_rel_def</span><span> </span><span>option_rel_def</span><span> </span><span>list_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_TOTAL R &#10233; IS_LEFT_TOTAL (&#10216;R&#10217;list_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IS_LEFT_TOTAL_alt</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x.&#8707;y. (x,y)&#8712;R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;l&#39;. (l,l&#39;)&#8712;&#10216;R&#10217;list_rel&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_rel_split_right_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_TOTAL Id&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_TOTAL R1 &#10233; IS_RIGHT_TOTAL R2 &#10233; IS_RIGHT_TOTAL (R1&#215;<span class="hidden">&#8681;</span><sub>r</sub>R2)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_TOTAL R1 &#10233; IS_RIGHT_TOTAL R2 &#10233; IS_RIGHT_TOTAL (&#10216;R1,R2&#10217;sum_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_TOTAL R &#10233; IS_RIGHT_TOTAL (&#10216;R&#10217;option_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_RIGHT_TOTAL_alt</span><span> </span><span>sum_rel_def</span><span> </span><span>option_rel_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_RIGHT_TOTAL_alt</span><span> </span><span>sum_rel_def</span><span> </span><span>option_rel_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_RIGHT_TOTAL_alt</span><span> </span><span>sum_rel_def</span><span> </span><span>option_rel_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_RIGHT_TOTAL_alt</span><span> </span><span>option_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_TOTAL R &#10233; IS_RIGHT_TOTAL (&#10216;R&#10217;list_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IS_RIGHT_TOTAL_alt</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x.&#8707;y. (y,x)&#8712;R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;l&#39;. (l&#39;,l)&#8712;&#10216;R&#10217;list_rel&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_rel_split_left_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>constraint_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_TOTAL (R&#175;) &#10231; IS_RIGHT_TOTAL R &quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_TOTAL (R&#175;) &#10231; IS_LEFT_TOTAL R  &quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE (R&#175;) &#10231; IS_RIGHT_UNIQUE R&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_UNIQUE (R&#175;) &#10231; IS_LEFT_UNIQUE R &quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_RIGHT_TOTAL_alt</span><span> </span><span>IS_LEFT_TOTAL_alt</span><span> </span><span>IS_LEFT_UNIQUE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_UNIQUE A &#10233; IS_RIGHT_TOTAL B &#10233; IS_RIGHT_TOTAL (A&#8594;B)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_TOTAL A &#10233; IS_RIGHT_UNIQUE B &#10233; IS_RIGHT_UNIQUE (A&#8594;B)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE A &#10233; IS_LEFT_TOTAL B &#10233; IS_LEFT_TOTAL (A&#8594;B)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_TOTAL A &#10233; IS_LEFT_UNIQUE B &#10233; IS_LEFT_UNIQUE (A&#8594;B)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prop2p</span><span> </span><span>rel2p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply transfer_step TODO: Isabelle 2016 *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>transfer_raw</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_BELOW_ID R &#10233; IS_RIGHT_UNIQUE R&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_BELOW_ID R &#10233; IS_LEFT_UNIQUE R&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID R &#10233; IS_RIGHT_TOTAL R&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_ID R &#10233; IS_LEFT_TOTAL R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_BELOW_ID_def</span><span> </span><span>IS_ID_def</span><span> </span><span>IS_LEFT_UNIQUE_def</span><span> </span><span>IS_RIGHT_TOTAL_def</span><span> </span><span>IS_LEFT_TOTAL_def</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>single_valuedI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>constraint_rules</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Additional Parametricity Lemmas&#8250;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move. Problem: Depend on IS_LEFT_UNIQUE, which has to be moved to!*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>param_distinct</span><span class="delimiter">[</span><span>param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;IS_LEFT_UNIQUE A; IS_RIGHT_UNIQUE A&#10215; &#10233; (distinct, distinct) &#8712; &#10216;A&#10217;list_rel &#8594; bool_rel&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>rel2p_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel2p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>distinct_transfer</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p2prop</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>param_Image</span><span class="delimiter">[</span><span>param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE A&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_UNIQUE A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((``), (``)) &#8712; &#10216;A&#215;<span class="hidden">&#8681;</span><sub>r</sub>B&#10217;set_rel &#8594; &#10216;A&#10217;set_rel &#8594; &#10216;B&#10217;set_rel&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_rel_def</span><span class="delimiter">;</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>IS_RIGHT_UNIQUED</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_UNIQUED</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pres_eq_iff_svb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((=),(=))&#8712;K&#8594;K&#8594;bool_rel &#10231; (single_valued K &#8743; single_valued (K&#175;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>safe</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>single_valuedI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>IdD</span><span> </span><span>fun_relD1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>IdD</span><span> </span><span>fun_relD1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>single_valuedD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_PRES_EQ R &#8801; ((=), (=))&#8712;R&#8594;R&#8594;bool_rel&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;single_valued R; single_valued (R&#175;)&#10215; &#10233; IS_PRES_EQ R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pres_eq_iff_svb</span><span> </span><span>IS_PRES_EQ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Bounded Assertions&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b_rel R P &#8801; R &#8745; UNIV&#215;Collect P&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b_assn A P &#8801; &#955;x y. &#8593;(P x) ** A x y&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_pure_conv</span><span class="delimiter">[</span><span>constraint_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b_assn (pure R) P = pure (b_rel R P)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>b_rel_def</span><span> </span><span>b_assn_def</span><span> </span><span>pure_def</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_rewrite</span><span class="delimiter">,</span><span> </span><span>sepref_frame_normrel_eqs</span><span class="delimiter">,</span><span> </span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="delimiter">=</span><span> </span><span>b_assn_pure_conv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_rel_nesting</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b_rel (b_rel R P1) P2 = b_rel R (&#955;x. P1 x &#8743; P2 x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>b_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_rel_triv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b_rel R (&#955;_. True) = R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>b_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_nesting</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b_assn (b_assn A P1) P2 = b_assn A (&#955;x. P1 x &#8743; P2 x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>b_assn_def</span><span> </span><span>pure_def</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_triv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;b_assn A (&#955;_. True) = A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>b_assn_def</span><span> </span><span>pure_def</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>constraint_simps</span><span class="delimiter">,</span><span>sepref_import_rewrite</span><span class="delimiter">,</span><span> </span><span>sepref_frame_normrel_eqs</span><span class="delimiter">,</span><span> </span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span>b_rel_nesting</span><span> </span><span>b_assn_nesting</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_rel_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x,y)&#8712;b_rel R P &#10231; (x,y)&#8712;R &#8743; P y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>b_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b_assn A P x y = (&#8593;(P x) ** A x y)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>b_assn_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_rel_Range</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Range (b_rel R P) = Range R &#8745; Collect P&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_rdom</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rdomp (b_assn R P) x &#10231; rdomp R x &#8743; P x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rdomp_def</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_rel_below_id</span><span class="delimiter">[</span><span>constraint_rules</span><span class="delimiter">,</span><span>relator_props</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_BELOW_ID R &#10233; IS_BELOW_ID (b_rel R P)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_BELOW_ID_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_rel_left_unique</span><span class="delimiter">[</span><span>constraint_rules</span><span class="delimiter">,</span><span>relator_props</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_LEFT_UNIQUE R &#10233; IS_LEFT_UNIQUE (b_rel R P)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_UNIQUE_def</span><span> </span><span>single_valued_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_rel_right_unique</span><span class="delimiter">[</span><span>constraint_rules</span><span class="delimiter">,</span><span>relator_props</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;IS_RIGHT_UNIQUE R &#10233; IS_RIGHT_UNIQUE (b_rel R P)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>single_valued_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;Registered as safe rule, although may loose information in the 
    odd case that purity depends condition.&#8250;</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_is_pure</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure A &#10233; is_pure (b_assn A P)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_pure_conv</span><span> </span><span>b_assn_pure_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R_comp_brel_id_conv</span><span class="delimiter">[</span><span>fcomp_norm_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R O b_rel Id P = b_rel R P&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  
</span><span class="comment">&#8213; &#8249;Most general form&#8250;</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_subtyping_match</span><span class="delimiter">[</span><span>sepref_frame_match_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt (b_assn A P) x y &#8866; hn_ctxt A&#39; x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;vassn_tag (hn_ctxt A x y); vassn_tag (hn_ctxt A&#39; x y); P x&#10215; &#10233; P&#39; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt (b_assn A P) x y &#8866; hn_ctxt (b_assn A&#39; P&#39;) x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hn_ctxt_def</span><span> </span><span>b_assn_def</span><span> </span><span>entails_def</span><span> </span><span>vassn_tag_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="comment">&#8213; &#8249;Simplified forms:&#8250;</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_subtyping_match_eqA</span><span class="delimiter">[</span><span>sepref_frame_match_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;vassn_tag (hn_ctxt A x y); P x&#10215; &#10233; P&#39; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt (b_assn A P) x y &#8866; hn_ctxt (b_assn A P&#39;) x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>b_assn_subtyping_match</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hn_ctxt_def</span><span> </span><span>b_assn_def</span><span> </span><span>entails_def</span><span> </span><span>vassn_tag_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_subtyping_match_tR</span><span class="delimiter">[</span><span>sepref_frame_match_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P x&#10215; &#10233; hn_ctxt A x y &#8866; hn_ctxt A&#39; x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt (b_assn A P) x y &#8866; hn_ctxt A&#39; x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hn_ctxt_def</span><span> </span><span>b_assn_def</span><span> </span><span>entails_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_subtyping_match_tL</span><span class="delimiter">[</span><span>sepref_frame_match_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt A x y &#8866; hn_ctxt A&#39; x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;vassn_tag (hn_ctxt A x y)&#10215; &#10233; P&#39; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt A x y &#8866; hn_ctxt (b_assn A&#39; P&#39;) x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hn_ctxt_def</span><span> </span><span>b_assn_def</span><span> </span><span>entails_def</span><span> </span><span>vassn_tag_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_subtyping_match_eqA_tR</span><span class="delimiter">[</span><span>sepref_frame_match_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt (b_assn A P) x y &#8866; hn_ctxt A x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hn_ctxt_def</span><span> </span><span>b_assn_def</span><span> </span><span>entails_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_subtyping_match_eqA_tL</span><span class="delimiter">[</span><span>sepref_frame_match_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;vassn_tag (hn_ctxt A x y)&#10215; &#10233; P&#39; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt A x y &#8866; hn_ctxt (b_assn A P&#39;) x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hn_ctxt_def</span><span> </span><span>b_assn_def</span><span> </span><span>entails_def</span><span> </span><span>vassn_tag_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_rel_gen_merge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MERGE1 A f B g C&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MERGE1 (b_assn A P) f (b_assn B Q) g (b_assn C (&#955;x. P x &#8744; Q x))&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>MERGE1D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>b_rel_merge_eq</span><span class="delimiter">[</span><span>sepref_frame_merge_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>b_rel_gen_merge</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span>P</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span>P</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_frame_merge_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>b_rel_gen_merge</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>b_rel_merge_left</span><span class="delimiter">[</span><span>sepref_frame_merge_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>b_rel_gen_merge</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;_. True&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>b_rel_merge_right</span><span class="delimiter">[</span><span>sepref_frame_merge_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>b_rel_gen_merge</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;_. True&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  
&#8213; &#8249;General form&#8250;
lemma b_rel_subtyping_merge[sepref_frame_merge_rules]:
  assumes &quot;hn_ctxt A x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt A&#39; x y &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_ctxt Am x y&quot;
  shows &quot;hn_ctxt (b_assn A P) x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt (b_assn A&#39; P&#39;) x y &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_ctxt (b_assn Am (&#955;x. P x &#8744; P&#39; x)) x y&quot;
  using assms
  unfolding hn_ctxt_def b_assn_def entailst_def entails_def
  by (fastforce simp: vassn_tag_def)
  
&#8213; &#8249;Simplified forms&#8250;
lemma b_rel_subtyping_merge_eqA[sepref_frame_merge_rules]:
  shows &quot;hn_ctxt (b_assn A P) x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt (b_assn A P&#39;) x y &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_ctxt (b_assn A (&#955;x. P x &#8744; P&#39; x)) x y&quot;
  apply (rule b_rel_subtyping_merge)
  by simp

lemma b_rel_subtyping_merge_tL[sepref_frame_merge_rules]:
  assumes &quot;hn_ctxt A x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt A&#39; x y &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_ctxt Am x y&quot;
  shows &quot;hn_ctxt A x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt (b_assn A&#39; P&#39;) x y &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_ctxt Am x y&quot;
  using b_rel_subtyping_merge[of A x y A&#39; Am &quot;&#955;_. True&quot; P&#39;, simplified] assms .

lemma b_rel_subtyping_merge_tR[sepref_frame_merge_rules]:
  assumes &quot;hn_ctxt A x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt A&#39; x y &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_ctxt Am x y&quot;
  shows &quot;hn_ctxt (b_assn A P) x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt A&#39; x y &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_ctxt Am x y&quot;
  using b_rel_subtyping_merge[of A x y A&#39; Am P &quot;&#955;_. True&quot;, simplified] assms .

lemma b_rel_subtyping_merge_eqA_tL[sepref_frame_merge_rules]:
  shows &quot;hn_ctxt A x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt (b_assn A P&#39;) x y &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_ctxt A x y&quot;
  using b_rel_subtyping_merge_eqA[of A &quot;&#955;_. True&quot; x y P&#39;, simplified] .

lemma b_rel_subtyping_merge_eqA_tR[sepref_frame_merge_rules]:
  shows &quot;hn_ctxt (b_assn A P) x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt A x y &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_ctxt A x y&quot;
  using b_rel_subtyping_merge_eqA[of A P x y &quot;&#955;_. True&quot;, simplified] .

(* TODO: Combinatorial explosion :( *)
lemma b_assn_invalid_merge1: &quot;hn_invalid (b_assn A P) x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_invalid (b_assn A P&#39;) x y
  &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_invalid (b_assn A (&#955;x. P x &#8744; P&#39; x)) x y&quot;
  by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)

lemma b_assn_invalid_merge2: &quot;hn_invalid (b_assn A P) x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_invalid A x y
  &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_invalid A x y&quot;
  by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)
lemma b_assn_invalid_merge3: &quot;hn_invalid A x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_invalid (b_assn A P) x y
  &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_invalid A x y&quot;
  by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)

lemma b_assn_invalid_merge4: &quot;hn_invalid (b_assn A P) x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt (b_assn A P&#39;) x y
  &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_invalid (b_assn A (&#955;x. P x &#8744; P&#39; x)) x y&quot;
  by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)
lemma b_assn_invalid_merge5: &quot;hn_ctxt (b_assn A P&#39;) x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_invalid (b_assn A P) x y
  &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_invalid (b_assn A (&#955;x. P x &#8744; P&#39; x)) x y&quot;
  by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)

lemma b_assn_invalid_merge6: &quot;hn_invalid (b_assn A P) x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt A x y
  &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_invalid A x y&quot;
  by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)
lemma b_assn_invalid_merge7: &quot;hn_ctxt A x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_invalid (b_assn A P) x y
  &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_invalid A x y&quot;
  by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)

lemma b_assn_invalid_merge8: &quot;hn_ctxt (b_assn A P) x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_invalid A x y
  &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_invalid A x y&quot;
  by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)
lemma b_assn_invalid_merge9: &quot;hn_invalid A x y &#8744;<span class="hidden">&#8681;</span><sub>A</sub> hn_ctxt (b_assn A P) x y
  &#10233;<span class="hidden">&#8681;</span><sub>t</sub> hn_invalid A x y&quot;
  by (sep_auto simp: hn_ctxt_def invalid_assn_def entailst_def)

lemmas b_assn_invalid_merge[sepref_frame_merge_rules] = 
  b_assn_invalid_merge1
  b_assn_invalid_merge2
  b_assn_invalid_merge3
  b_assn_invalid_merge4
  b_assn_invalid_merge5
  b_assn_invalid_merge6
  b_assn_invalid_merge7
  b_assn_invalid_merge8
  b_assn_invalid_merge9

*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>nbn_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; (nat &#215; nat) set&quot;</span></span></span><span> 
</span><span>  </span><span class="comment">&#8213; &#8249;Natural numbers with upper bound.&#8250;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nbn_rel n &#8801; b_rel nat_rel (&#955;x::nat. x&lt;n)&quot;</span></span></span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_R_comp_nbn_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a,b)&#8712;(R O nbn_rel N) &#10231; (a,b)&#8712;R &#8743; b&lt;N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>range_comp_nbn_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Range (R O nbn_rel N) = Range R &#8745; {0..&lt;N}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>b_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mk_free_b_assn</span><span class="delimiter">[</span><span>sepref_frame_free_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE A f&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE (b_assn A P) f&quot;</span></span></span><span>  
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>assms</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>MK_FREED</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>rule</span><span> </span><span>vcg</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intf_of_b_rel</span><span class="delimiter">[</span><span>synth_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;INTF_OF_REL R I &#10233; INTF_OF_REL (b_rel R P) I&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>b_assn_intf</span><span class="delimiter">[</span><span>intf_of_assn</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intf_of_assn V I &#10233; intf_of_assn (b_assn V P) I&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Introduce extra goal for bounded result&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_bassn_resI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;xs. &#10214;rdomp (fst As) xs; C xs&#10215; &#10233; a xs &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c,a)&#8712;[C]<span class="hidden">&#8681;</span><sub>a</sub> As &#8594; R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c,a)&#8712;[C]<span class="hidden">&#8681;</span><sub>a</sub> As &#8594; b_assn R P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_preI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_augment_res</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>to_hnr</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>hn_ctxt_def</span><span> </span><span>autoref_tag_defs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rdomp_def</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Tool Setup&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_relprops</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>sepref_relpropI</span><span class="delimiter">[</span><span>of</span><span> </span><span>IS_LEFT_UNIQUE</span><span class="delimiter">]</span><span>
</span><span>  </span><span>sepref_relpropI</span><span class="delimiter">[</span><span>of</span><span> </span><span>IS_RIGHT_UNIQUE</span><span class="delimiter">]</span><span>
</span><span>  </span><span>sepref_relpropI</span><span class="delimiter">[</span><span>of</span><span> </span><span>IS_LEFT_TOTAL</span><span class="delimiter">]</span><span>
</span><span>  </span><span>sepref_relpropI</span><span class="delimiter">[</span><span>of</span><span> </span><span>IS_RIGHT_TOTAL</span><span class="delimiter">]</span><span>
</span><span>  </span><span>sepref_relpropI</span><span class="delimiter">[</span><span>of</span><span> </span><span>is_pure</span><span class="delimiter">]</span><span>
</span><span>  </span><span>sepref_relpropI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;IS_PURE &#934;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>&#934;</span><span class="delimiter">]</span><span>
</span><span>  </span><span>sepref_relpropI</span><span class="delimiter">[</span><span>of</span><span> </span><span>IS_ID</span><span class="delimiter">]</span><span>
</span><span>  </span><span>sepref_relpropI</span><span class="delimiter">[</span><span>of</span><span> </span><span>IS_BELOW_ID</span><span class="delimiter">]</span><span>
</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>sepref_relprops_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;CONSTRAINT (IS_PURE IS_ID) A &#10233; CONSTRAINT (IS_PURE IS_BELOW_ID) A&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;CONSTRAINT (IS_PURE IS_ID) A &#10233; CONSTRAINT (IS_PURE IS_LEFT_TOTAL) A&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;CONSTRAINT (IS_PURE IS_ID) A &#10233; CONSTRAINT (IS_PURE IS_RIGHT_TOTAL) A&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;CONSTRAINT (IS_PURE IS_BELOW_ID) A &#10233; CONSTRAINT (IS_PURE IS_LEFT_UNIQUE) A&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;CONSTRAINT (IS_PURE IS_BELOW_ID) A &#10233; CONSTRAINT (IS_PURE IS_RIGHT_UNIQUE) A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_ID_def</span><span> </span><span>IS_BELOW_ID_def</span><span> </span><span>IS_PURE_def</span><span> </span><span>IS_LEFT_UNIQUE_def</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_TOTAL_def</span><span> </span><span>IS_RIGHT_TOTAL_def</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>single_valued_below_Id</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>True_implies_equals</span><span class="delimiter">[</span><span>sepref_relprops_simps</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>sepref_relprops_transform</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;single_valued (R&#175;) = IS_LEFT_UNIQUE R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>IS_LEFT_UNIQUE_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Default Initializers&#8250;</span></span></span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We define a generic algorithm scheme to determine the abstract counterpart of
  the \&lt;^term&gt;&#8249;init::&#39;a::llvm_rep&#8250; value wrt. an assertion. This is important for 
  initializing container data structures directly from zero-initializing &#8249;calloc&#8250;, 
  rather than having to &#8249;memset&#8250; each array.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; &#39;c::llvm_rep &#8658; assn) &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_init A i &#8801; is_pure A &#8743; (init,i) &#8712; the_pure A&quot;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_init_id_assn</span><span class="delimiter">[</span><span>sepref_gen_algo_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;GEN_ALGO init (is_init id_assn)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>GEN_ALGO_def</span><span> </span><span>is_init_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Arithmetics&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Connecting to Standard Operation Abstraction from LLVM-RS&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We will hide the connection behind an additional abstraction layer, 
  introduced by definitions. So, the definitions from this locale should not 
  be used by the end-user.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>standard_opr_abstraction</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rel &#8801; br &#945; I&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>assn_is_rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8639;assn = pure rel&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pure_def</span><span> </span><span>rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>sepref_assn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sepref_assn &#8801; pure rel&quot;</span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_un_op</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_un_op PRE cop xmop aop&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(cop,(RETURN o aop)) &#8712; [&#955;a. PRE TYPE(&#39;c) a]<span class="hidden">&#8681;</span><sub>a</sub> sepref_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; sepref_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>un_op_tmpl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_bin_op</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_bin_op PRE cop xmop aop&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry cop,uncurry (RETURN oo aop)) &#8712; [&#955;(a,b). PRE TYPE(&#39;c) a b]<span class="hidden">&#8681;</span><sub>a</sub> sepref_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sepref_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; sepref_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>bin_op_tmpl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_cmp_op</span><span class="delimiter">:</span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_cmp_op cop xmop aop&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry cop, uncurry (RETURN oo aop)) &#8712; sepref_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sepref_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool.sepref_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>bool.assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>cmp_op_tmpl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>    
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Operator Setup&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Not-Equals is an operator in LLVM, but not in HOL&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;op_neq a b &#8801; a&#8800;b&quot;</span></span></span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Maybe have this pattern rule only for certain types.
  Otherwise, op_neq has to be implemented by every type that has custom eq-operator!

  The best solution would, or course, be to have a generic algorithm!
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>op_neq_pat</span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Not$((=)$a$b) &#8801; op_neq$a$b&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>op_neq_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;op_neq :: _ word &#8658; _&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;For technical reasons, we need the operands as parameters to the operators 
  on the concrete side of refinement theorems. Thus, we define the following shortcut
  for comparison operators. &#8250;</span></span></span><span>    
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO/FIXME: This, in turn, relies on LLVM-inlining of from_bool (comparison)! 
  Perhaps we should directly generate the ll_icmp instructions
*)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lift_cmp_op c a b &#8801; from_bool (c a b)&quot;</span></span></span><span>  
</span><span>  
</span><span>
</span><span>
</span><span>   
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Boolean&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool1_rel &#8801; bool.rel&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool1_assn &#8801; (pure bool1_rel)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bool_const_refine</span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(0,False)&#8712;bool1_rel&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(1,True)&#8712;bool1_rel&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bool1_rel_def</span><span> </span><span>bool.rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_bool_ops</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_and, uncurry (RETURN &#8728;&#8728; (&#8743;))) &#8712; bool1_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_or, uncurry (RETURN &#8728;&#8728; (&#8744;))) &#8712; bool1_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_xor, uncurry (RETURN &#8728;&#8728; (op_neq))) &#8712; bool1_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(ll_not1, RETURN &#8728; Not) &#8712; bool1_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bool_bin_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>bool.hn_bin_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>bool1_rel_def</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>to_hfref_post</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bool_un_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>bool.hn_un_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>bool1_rel_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_neq_def</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We define an implies connective, using sepref&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>ll_implies</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (RETURN oo (&#10230;))&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool1_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>imp_conv_disj</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ll_implies_def</span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ll_implies.refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_init_bool</span><span class="delimiter">[</span><span>sepref_gen_algo_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;GEN_ALGO False (is_init bool1_assn)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>GEN_ALGO_def</span><span> </span><span>is_init_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bool1_rel_def</span><span> </span><span>bool.rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Direct Word Arithmetic&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_rel &#8801; (Id::(_::len word &#215; _) set)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_assn &#8801; (id_assn::_::len word &#8658; _)&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ll_not</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len word &#8658; &#39;a word llM&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ll_not a &#8801; doM { a &#8592; ll_sub 0 a; ll_sub a 1 }&quot;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_not_normalize</span><span class="delimiter">[</span><span>vcg_normalize_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ll_not a = return (~~a)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ll_not_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>NOT_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg_normalize</span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span>num</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;numeral a :: _ word&quot;</span></span></span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;0 :: _ word&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;1 :: _ word&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_numeral_param</span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(numeral a,PR_CONST (numeral a)) &#8712; word_rel&quot;</span></span></span><span>  
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(0,0)&#8712;word_rel&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(1,1)&#8712;word_rel&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  
</span><span>   
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>  </span><span>plus_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(+):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>minus_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(-):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>times_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(*):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>and_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(AND):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>or_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(OR):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>xor_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(XOR):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_param_imports</span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((+),(+)) &#8712; word_rel &#8594; word_rel &#8594; word_rel&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((-),(-)) &#8712; word_rel &#8594; word_rel &#8594; word_rel&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((*),(*)) &#8712; word_rel &#8594; word_rel &#8594; word_rel&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((AND),(AND)) &#8712; word_rel &#8594; word_rel &#8594; word_rel&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((OR),(OR)) &#8712; word_rel &#8594; word_rel &#8594; word_rel&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((XOR),(XOR)) &#8712; word_rel &#8594; word_rel &#8594; word_rel&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>  </span><span>not_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bitNOT:: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_word_NOT</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(ll_not,RETURN o bitNOT) &#8712; word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> word_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_to_hoare</span><span> </span><span>vcg</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>  </span><span>div_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(div):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>mod_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(mod):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>sdiv_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(sdiv):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>smod_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(smod):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_word_div_op</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (ll_udiv),uncurry (RETURN oo (div))) &#8712; [&#955;(_,d). d&#8800;0]<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; word_assn&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (ll_urem),uncurry (RETURN oo (mod))) &#8712; [&#955;(_,d). d&#8800;0]<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; word_assn&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (ll_sdiv),uncurry (RETURN oo (sdiv))) &#8712; [&#955;(c,d). d&#8800;0 &#8743; in_srange (sdiv) c d]<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; word_assn&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (ll_srem),uncurry (RETURN oo (smod))) &#8712; [&#955;(c,d). d&#8800;0 &#8743; in_srange (sdiv) c d]<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; word_assn&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sepref_to_hoare</span><span class="delimiter">;</span><span> </span><span>vcg</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>  </span><span>eq_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(=):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>neq_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;op_neq:: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>ult_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&lt;):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>ule_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8804;):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>slt_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&lt;s):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>sle_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&lt;=s):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_word_icmp_op</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (ll_icmp_eq), uncurry (RETURN oo (=))) &#8712; word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (ll_icmp_ne), uncurry (RETURN oo (op_neq))) &#8712; word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (ll_icmp_ult), uncurry (RETURN oo (&lt;))) &#8712; word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (ll_icmp_ule), uncurry (RETURN oo (&#8804;))) &#8712; word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (ll_icmp_slt), uncurry (RETURN oo (&#955;a b. a &lt;s b))) &#8712; word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (ll_icmp_sle), uncurry (RETURN oo (&#955;a b. a &lt;=s b))) &#8712; word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bool1_rel_def</span><span> </span><span>bool.rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>in_br_conv</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sepref_to_hoare</span><span class="delimiter">;</span><span> </span><span>vcg</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_init_word</span><span class="delimiter">[</span><span>sepref_gen_algo_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;GEN_ALGO 0 (is_init word_assn)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>GEN_ALGO_def</span><span> </span><span>is_init_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>      
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Integer by Word&#8250;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint_rel &#8801; sint.rel&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint_assn &#8801; pure sint_rel&quot;</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint_rel&#39; TYPE(&#39;a::len) &#8801; sint_rel :: (&#39;a word &#215; _) set&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint_assn&#39; TYPE(&#39;a::len) &#8801; sint_assn :: _ &#8658; &#39;a word &#8658; _&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint_const TYPE(&#39;a::len) c &#8801; (c::int)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span>int</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint_const TYPE(&#39;a::len) c&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fold_sint</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;0 = sint_const TYPE(&#39;a::len) 0&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;1 = sint_const TYPE(&#39;a::len) 1&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;-1 &#8801; (sint_const TYPE(&#39;a::len) (-1))&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;numeral n &#8801; (sint_const TYPE(&#39;a::len) (numeral n))&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;-(numeral n) &#8801; (sint_const TYPE(&#39;a::len) (-numeral n))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_sint_0</span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(0,sint_const TYPE(&#39;a) 0) &#8712; sint_rel&#39; TYPE(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sint_rel_def</span><span> </span><span>sint.rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_sint_1</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;LENGTH(&#39;a)&#8800;1 &#10233; hn_refine &#9633; (return 1) &#9633; (sint_assn&#39; TYPE(&#39;a::len)) (RETURN$PR_CONST (sint_const TYPE(&#39;a) 1))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sint_rel_def</span><span> </span><span>sint.rel_def</span><span> </span><span>in_br_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_sint_minus_1</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine &#9633; (return (-1)) &#9633; (sint_assn&#39; TYPE(&#39;a::len)) (RETURN$PR_CONST (sint_const TYPE(&#39;a) (-1)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sint_rel_def</span><span> </span><span>sint.rel_def</span><span> </span><span>in_br_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_sint_numeral</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;numeral n &#8712; sints LENGTH(&#39;a)&#10215; &#10233; 
    hn_refine &#9633; (return (numeral n)) &#9633; (sint_assn&#39; TYPE(&#39;a::len)) (RETURN$(PR_CONST (sint_const TYPE(&#39;a) (numeral n))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sint_rel_def</span><span> </span><span>sint.rel_def</span><span> </span><span>in_br_conv</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sbintrunc_mod2p</span><span> </span><span>min_sint_def</span><span> </span><span>max_sint_def</span><span> </span><span>ll_const_signed_aux</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_sint_minus_numeral</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;-numeral n &#8712; sints LENGTH(&#39;a)&#10215; &#10233; 
    hn_refine &#9633; (return (-numeral n)) &#9633; (sint_assn&#39; TYPE(&#39;a::len)) (RETURN$(PR_CONST (sint_const TYPE(&#39;a) (-numeral n))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sint_rel_def</span><span> </span><span>sint.rel_def</span><span> </span><span>in_br_conv</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sbintrunc_mod2p</span><span> </span><span>min_sint_def</span><span> </span><span>max_sint_def</span><span> </span><span>ll_const_signed_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>diff_Suc_less</span><span> </span><span>int_mod_eq&#39;</span><span> </span><span>len_gt_0</span><span> </span><span>neg_numeral_le_numeral</span><span> </span><span>power_strict_increasing_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>  </span><span>plus_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(+)::int&#8658;_&quot;</span></span></span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span>minus_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(-)::int&#8658;_&quot;</span></span></span><span>   </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span>times_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(*)::int&#8658;_&quot;</span></span></span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span>sdiv_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(sdiv)::int&#8658;_&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  </span><span>smod_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(smod)::int&#8658;_&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; int &#8658; int&quot;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>  </span><span>eq_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(=)::int&#8658;_&quot;</span></span></span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; int &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span>op_neq_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;op_neq::int&#8658;_&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; int &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span>lt_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&lt;)::int&#8658;_&quot;</span></span></span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; int &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span>le_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8804;)::int&#8658;_&quot;</span></span></span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; int &#8658; bool&quot;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sepref_register</span></span><span>    
</span><span>  </span><span>and_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(AND):: int &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>or_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(OR):: int &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>xor_int</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(XOR):: int &#8658; _&quot;</span></span></span><span>  
</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>sint_cmp_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sint.hn_cmp_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>sint_rel_def</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>to_hfref_post</span><span class="delimiter">]</span><span>  
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>sint_bin_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sint.hn_bin_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>sint_rel_def</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>to_hfref_post</span><span class="delimiter">]</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_sint_ops</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_add, uncurry (RETURN &#8728;&#8728; (+)))
    &#8712; [&#955;(a, b). a + b &#8712; sints LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; sint_assn&#39; TYPE(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_sub, uncurry (RETURN &#8728;&#8728; (-)))
    &#8712; [&#955;(a, b). a - b &#8712; sints LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; sint_assn&#39; TYPE(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_mul, uncurry (RETURN &#8728;&#8728; (*)))
    &#8712; [&#955;(a, b). a * b &#8712; sints LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; sint_assn&#39; TYPE(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_sdiv, uncurry (RETURN &#8728;&#8728; (sdiv)))
    &#8712; [&#955;(a, b). b &#8800; 0 &#8743; a sdiv b &#8712; sints LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; sint_assn&#39; TYPE(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_srem, uncurry (RETURN &#8728;&#8728; (smod)))
    &#8712; [&#955;(a, b). b &#8800; 0 &#8743; a sdiv b &#8712; sints LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; sint_assn&#39; TYPE(&#39;a::len)&quot;</span></span></span><span>
</span><span>    
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_eq, uncurry (RETURN &#8728;&#8728; (=))) &#8712; sint_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_ne, uncurry (RETURN &#8728;&#8728; (op_neq))) &#8712; sint_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_sle, uncurry (RETURN &#8728;&#8728; (&#8804;))) &#8712; sint_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_slt, uncurry (RETURN &#8728;&#8728; (&lt;))) &#8712; sint_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> sint_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_neq_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sint_bin_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sint.hn_bin_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>sint_rel_def</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>to_hfref_post</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sint_cmp_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sint.hn_cmp_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>sint_rel_def</span><span> </span><span>bool1_rel_def</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>to_hfref_post</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>      
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint_init TYPE(&#39;a::len) &#8801; 0::int&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Add rule for 0 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_init_sint</span><span class="delimiter">[</span><span>sepref_gen_algo_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;GEN_ALGO (sint_init TYPE(&#39;a::len)) (is_init (sint_assn&#39; TYPE(&#39;a)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>GEN_ALGO_def</span><span> </span><span>sint_init_def</span><span> </span><span>is_init_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sint_rel_def</span><span> </span><span>sint.rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_init_sint0</span><span class="delimiter">[</span><span>sepref_gen_algo_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;GEN_ALGO (sint_const TYPE(&#39;a::len) 0) (is_init (sint_assn&#39; TYPE(&#39;a)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_init_sint</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">=</span><span class="tfree">&#39;a</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Natural Numbers by Unsigned Word&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>  </span><span>plus_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(+)::nat&#8658;_&quot;</span></span></span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span>minus_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(-)::nat&#8658;_&quot;</span></span></span><span>   </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span>times_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(*)::nat&#8658;_&quot;</span></span></span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span>div_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(div)::nat&#8658;_&quot;</span></span></span><span>   </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span>mod_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(mod)::nat&#8658;_&quot;</span></span></span><span>   </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; nat&quot;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>  </span><span>eq_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(=)::nat&#8658;_&quot;</span></span></span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span>op_neq_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;op_neq::nat&#8658;_&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span>lt_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&lt;)::nat&#8658;_&quot;</span></span></span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span>le_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8804;)::nat&#8658;_&quot;</span></span></span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; bool&quot;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sepref_register</span></span><span>    
</span><span>  </span><span>and_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(AND):: nat &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>or_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(OR):: nat &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>xor_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(XOR):: nat &#8658; _&quot;</span></span></span><span>  
</span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unat_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::len word &#215; nat) set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_rel &#8801; unat.rel&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_assn &#8801; pure unat_rel&quot;</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_rel&#39; TYPE(&#39;a::len) &#8801; unat_rel :: (&#39;a word &#215; _) set&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_assn&#39; TYPE(&#39;a::len) &#8801; unat_assn :: _ &#8658; &#39;a word &#8658; _&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_const TYPE(&#39;a::len) c &#8801; (c::nat)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_const TYPE(&#39;a::len) c&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fold_unat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;0 = unat_const TYPE(&#39;a::len) 0&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;1 = unat_const TYPE(&#39;a::len) 1&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;numeral n &#8801; (unat_const TYPE(&#39;a::len) (numeral n))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_unat_0</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine &#9633; (return 0) &#9633; (unat_assn&#39; TYPE(&#39;a::len)) (RETURN$PR_CONST (unat_const TYPE(&#39;a) 0))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat_rel_def</span><span> </span><span>unat.rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_unat_1</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine &#9633; (return 1) &#9633; (unat_assn&#39; TYPE(&#39;a::len)) (RETURN$PR_CONST (unat_const TYPE(&#39;a) 1))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat_rel_def</span><span> </span><span>unat.rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_unat_numeral</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;numeral n &#8712; unats LENGTH(&#39;a)&#10215; &#10233; 
    hn_refine &#9633; (return (numeral n)) &#9633; (unat_assn&#39; TYPE(&#39;a::len)) (RETURN$(PR_CONST (unat_const TYPE(&#39;a) (numeral n))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat_rel_def</span><span> </span><span>unat.rel_def</span><span> </span><span>in_br_conv</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_unats_conv</span><span> </span><span>int_nat_eq</span><span> </span><span>of_nat_numeral</span><span> </span><span>uint_nonnegative</span><span> </span><span>unat_bintrunc</span><span> </span><span>unat_def</span><span> </span><span>word_of_int_numeral</span><span> </span><span>word_uint.Rep_inverse&#39;</span><span> </span><span>word_unat.Rep_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_unat_ops</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_add, uncurry (RETURN &#8728;&#8728; (+))) &#8712; [&#955;(a, b). a + b &lt; max_unat LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; unat_assn&#39; TYPE(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_sub, uncurry (RETURN &#8728;&#8728; (-))) &#8712; [&#955;(a, b). b &#8804; a]<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; unat_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_mul, uncurry (RETURN &#8728;&#8728; (*))) &#8712; [&#955;(a, b). a * b &lt; max_unat LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; unat_assn&#39; TYPE(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_udiv, uncurry (RETURN &#8728;&#8728; (div))) &#8712; [&#955;(a, b). b &#8800; 0]<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; unat_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_urem, uncurry (RETURN &#8728;&#8728; (mod))) &#8712; [&#955;(a, b). b &#8800; 0]<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; unat_assn&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_and, uncurry (RETURN &#8728;&#8728; (AND))) &#8712; unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> unat_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_or, uncurry (RETURN &#8728;&#8728; (OR))) &#8712; unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> unat_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_xor, uncurry (RETURN &#8728;&#8728; (XOR))) &#8712; unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> unat_assn&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_eq, uncurry (RETURN &#8728;&#8728; (=))) &#8712; unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_ne, uncurry (RETURN &#8728;&#8728; (op_neq))) &#8712; unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_ule, uncurry (RETURN &#8728;&#8728; (&#8804;))) &#8712; unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_ult, uncurry (RETURN &#8728;&#8728; (&lt;))) &#8712; unat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_neq_def</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unat_bin_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>unat.hn_bin_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>unat_rel_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>unat_bin_ops_bitwise</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>unat.hn_bin_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>unat_rel_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>unat_cmp_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>unat.hn_cmp_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>unat_rel_def</span><span> </span><span>bool1_rel_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prod_casesK</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_init TYPE(&#39;a::len) &#8801; 0::nat&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_init_unat</span><span class="delimiter">[</span><span>sepref_gen_algo_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;GEN_ALGO (unat_init TYPE(&#39;a::len)) (is_init (unat_assn&#39; TYPE(&#39;a)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>GEN_ALGO_def</span><span> </span><span>unat_init_def</span><span> </span><span>is_init_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat_rel_def</span><span> </span><span>unat.rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_init_unat0</span><span class="delimiter">[</span><span>sepref_gen_algo_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;GEN_ALGO (unat_const TYPE(&#39;a::len2) 0) (is_init (unat_assn&#39; TYPE(&#39;a)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_init_unat</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">=</span><span class="tfree">&#39;a</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>      
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Natural Numbers by Signed Word&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>snat_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::len2 word &#215; nat) set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_rel &#8801; snat.rel&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_assn &#8801; pure snat_rel&quot;</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_rel&#39; TYPE(&#39;a::len2) &#8801; snat_rel :: (&#39;a word &#215; _) set&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_assn&#39; TYPE(&#39;a::len2) &#8801; snat_assn :: _ &#8658; &#39;a word &#8658; _&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Too many snat_rel_ &lt; max_snat lemma variants! *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_rel_range</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Range (snat_rel&#39; TYPE(&#39;l)) = {0..&lt;max_snat LENGTH(&#39;l::len2)}&quot;</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Clean up proof! *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Range_iff</span><span> </span><span>snat_rel_def</span><span> </span><span>snat.rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;word_of_int (int x)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_snat_def</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snat_in_bounds_aux</span><span> </span><span>unat_of_nat_eq</span><span> </span><span>word_of_nat</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Word_Lemmas.of_nat_power</span><span> </span><span>diff_less</span><span> </span><span>len_gt_0</span><span> </span><span>max_unat_def</span><span> </span><span>n_less_equal_power_2</span><span> </span><span>not_msb_from_less</span><span> </span><span>power_0</span><span> </span><span>word_of_nat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_const TYPE(&#39;a::len2) c &#8801; (c::nat)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_const TYPE(&#39;a::len2) c&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fold_snat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;0 = snat_const TYPE(&#39;a::len2) 0&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;1 = snat_const TYPE(&#39;a::len2) 1&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;numeral n &#8801; (snat_const TYPE(&#39;a::len2) (numeral n))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move, and use for proofs about snat in LLVM_Shallow_RS *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_invar_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_invar (0)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_invar_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_invar (1)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_invar_numeral</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; numeral a &lt; max_snat LENGTH(&#39;a::len2) &#10215; &#10233;
  snat_invar (numeral a::&#39;a word)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>ll_const_signed_nat_aux2</span><span> </span><span>max_snat_def</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_snat_0</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine &#9633; (return 0) &#9633; (snat_assn&#39; TYPE(&#39;a::len2)) (RETURN$PR_CONST (snat_const TYPE(&#39;a) 0))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snat_rel_def</span><span> </span><span>snat.rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>snat_invar_0</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_snat_1</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine &#9633; (return 1) &#9633; (snat_assn&#39; TYPE(&#39;a::len2)) (RETURN$PR_CONST (snat_const TYPE(&#39;a) 1))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snat_rel_def</span><span> </span><span>snat.rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>snat_invar_1</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_snat_numeral</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;numeral n &#8712; snats LENGTH(&#39;a)&#10215; &#10233; 
    hn_refine &#9633; (return (numeral n)) &#9633; (snat_assn&#39; TYPE(&#39;a::len2)) (RETURN$(PR_CONST (snat_const TYPE(&#39;a) (numeral n))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snat_rel_def</span><span> </span><span>snat.rel_def</span><span> </span><span>in_br_conv</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>snat_invar_numeral</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_snat_ops</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_add, uncurry (RETURN &#8728;&#8728; (+))) &#8712; [&#955;(a, b). a + b &lt; max_snat LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; snat_assn&#39; TYPE(&#39;a::len2)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_sub, uncurry (RETURN &#8728;&#8728; (-))) &#8712; [&#955;(a, b). b &#8804; a]<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; snat_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_mul, uncurry (RETURN &#8728;&#8728; (*))) &#8712; [&#955;(a, b). a * b &lt; max_snat LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; snat_assn&#39; TYPE(&#39;a::len2)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_udiv, uncurry (RETURN &#8728;&#8728; (div))) &#8712; [&#955;(a, b). b &#8800; 0]<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; snat_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_urem, uncurry (RETURN &#8728;&#8728; (mod))) &#8712; [&#955;(a, b). b &#8800; 0]<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; snat_assn&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_eq, uncurry (RETURN &#8728;&#8728; (=))) &#8712; snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_ne, uncurry (RETURN &#8728;&#8728; (op_neq))) &#8712; snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_sle, uncurry (RETURN &#8728;&#8728; (&#8804;))) &#8712; snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_icmp_slt, uncurry (RETURN &#8728;&#8728; (&lt;))) &#8712; snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_neq_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snat_bin_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>snat.hn_bin_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>snat_rel_def</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>snat_cmp_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>snat.hn_cmp_op</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>snat_rel_def</span><span> </span><span>bool1_rel_def</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_init TYPE(&#39;a::len) &#8801; 0::nat&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_init_snat</span><span class="delimiter">[</span><span>sepref_gen_algo_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;GEN_ALGO (snat_init TYPE(&#39;a::len2)) (is_init (snat_assn&#39; TYPE(&#39;a)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>GEN_ALGO_def</span><span> </span><span>snat_init_def</span><span> </span><span>is_init_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snat_rel_def</span><span> </span><span>snat.rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>snat_invar_0</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_init_snat0</span><span class="delimiter">[</span><span>sepref_gen_algo_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;GEN_ALGO (snat_const TYPE(&#39;a::len2) 0) (is_init (snat_assn&#39; TYPE(&#39;a)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_init_snat</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">=</span><span class="tfree">&#39;a</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Ad-Hoc Method to Annotate Number Constructors&#8250;</span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_num_const_cong</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a b. snat_const a b = snat_const a b&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a b. sint_const a b = sint_const a b&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a b. unat_const a b = unat_const a b&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;ASSERT &#934; = ASSERT &#934;&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;WHILEIT I = WHILEIT I&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_const_fold</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;0 = unat_const TYPE(&#39;a::len) 0&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;1 = unat_const TYPE(&#39;a::len) 1&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;numeral n = unat_const TYPE(&#39;a::len) (numeral n)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_const_fold</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;0 = snat_const TYPE(&#39;a::len2) 0&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;1 = snat_const TYPE(&#39;a::len2) 1&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;numeral n = snat_const TYPE(&#39;a::len2) (numeral n)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_const_fold</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;0 = sint_const TYPE(&#39;a::len) 0&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;1 = sint_const TYPE(&#39;a::len) 1&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;numeral n = sint_const TYPE(&#39;a::len) (numeral n)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;-sint_const TYPE(&#39;a::len) c = sint_const TYPE(&#39;a::len) (-c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hfref_absfun_convI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CNV g g&#39; &#10233; (f,g&#39;) &#8712; hfref P A R &#10233; (f,g) &#8712; hfref P A R&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>annot_sint_const</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len itself&quot;</span></span></span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_absfun_convI</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>  </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>sint_const_fold</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">=</span><span class="tfree">&#39;a</span><span class="delimiter">]</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>annot_num_const_cong</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CNV_I</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>annot_snat_const</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len2 itself&quot;</span></span></span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_absfun_convI</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>  </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>snat_const_fold</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">=</span><span class="tfree">&#39;a</span><span class="delimiter">]</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>annot_num_const_cong</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CNV_I</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>annot_unat_const</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len itself&quot;</span></span></span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_absfun_convI</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>  </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>unat_const_fold</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">=</span><span class="tfree">&#39;a</span><span class="delimiter">]</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>annot_num_const_cong</span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CNV_I</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Casting&#8250;</span></span></span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Add other casts *)</span></span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len2 itself&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_snat_upcast_aux &#8801; let _=TYPE(&#39;a) in id::nat&#8658;nat&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>unat_snat_upcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_snat_upcast_aux&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat_rel &#8594; nat_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len itself&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_unat_downcast_aux &#8801; let _=TYPE(&#39;a) in id::nat&#8658;nat&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>snat_unat_downcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_unat_downcast_aux&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat_rel &#8594; nat_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len2 itself&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_snat_upcast_aux &#8801; let _=TYPE(&#39;a) in id::nat&#8658;nat&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>snat_snat_upcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_snat_upcast_aux&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat_rel &#8594; nat_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_snat_downcast_aux &#8801; let _=TYPE(&#39;a) in id::nat&#8658;nat&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>snat_snat_downcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_snat_downcast_aux&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat_rel &#8594; nat_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len itself&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_unat_upcast_aux &#8801; let _=TYPE(&#39;a) in id::nat&#8658;nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_unat_downcast_aux &#8801; let _=TYPE(&#39;a) in id::nat&#8658;nat&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>unat_unat_upcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_unat_upcast_aux&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat_rel &#8594; nat_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>unat_unat_downcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_unat_downcast_aux&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat_rel &#8594; nat_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>unat_snat_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id::nat&#8658;_&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat_rel &#8594; nat_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>snat_unat_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;id::nat&#8658;_&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat_rel &#8594; nat_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_unat_snat_upcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = op_unat_snat_upcast TYPE(&#39;l::len2) x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_snat_unat_downcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = op_snat_unat_downcast TYPE(&#39;l::len) x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_snat_snat_upcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = op_snat_snat_upcast TYPE(&#39;l::len2) x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_snat_snat_downcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = op_snat_snat_downcast TYPE(&#39;l::len2) x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_unat_snat_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = op_unat_snat_conv x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_unat_unat_upcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = op_unat_unat_upcast TYPE(&#39;l::len) x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_unat_unat_downcast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = op_unat_unat_downcast TYPE(&#39;l::len) x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_snat_unat_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = op_snat_unat_conv x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_unat_rel_conv_assn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8593;((xi, x) &#8712; unat_rel) = &#8639;unat.assn x xi&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_rel_def</span><span> </span><span>unat.assn_is_rel</span><span> </span><span>pure_app_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_snat_rel_conv_assn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8593;((xi, x) &#8712; snat_rel) = &#8639;snat.assn x xi&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_rel_def</span><span> </span><span>snat.assn_is_rel</span><span> </span><span>pure_app_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>BIG</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;big::len2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SMALL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;small::len&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_snat_upcast_refine</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(unat_snat_upcast TYPE(&#39;big::len2), PR_CONST (mop_unat_snat_upcast TYPE(&#39;big::len2))) &#8712; [&#955;_. is_up&#39; UCAST(&#39;small &#8594; &#39;big)]<span class="hidden">&#8681;</span><sub>a</sub> (unat_assn&#39; TYPE(&#39;small::len))<span class="hidden">&#8679;</span><sup>k</sup> &#8594; snat_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>in_unat_rel_conv_assn</span><span> </span><span>in_snat_rel_conv_assn</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>unat_snat_upcast_refine</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="tfree">&#39;big</span><span> </span><span class="tfree">&#39;small</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_unat_downcast_refine</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(snat_unat_downcast TYPE(&#39;small), PR_CONST (mop_snat_unat_downcast TYPE(&#39;small))) 
      &#8712; [&#955;x. is_down&#39; UCAST(&#39;big &#8594; &#39;small) &#8743; x&lt;max_unat LENGTH(&#39;small)]<span class="hidden">&#8681;</span><sub>a</sub> (snat_assn&#39; TYPE(&#39;big))<span class="hidden">&#8679;</span><sup>k</sup> &#8594; unat_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>in_unat_rel_conv_assn</span><span> </span><span>in_snat_rel_conv_assn</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>snat_unat_downcast_refine</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="tfree">&#39;big</span><span> </span><span class="tfree">&#39;small</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>BIG</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;big::len2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SMALL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;small::len2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_snat_upcast_refine</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(snat_snat_upcast TYPE(&#39;big::len2), PR_CONST (mop_snat_snat_upcast TYPE(&#39;big::len2))) &#8712; [&#955;_. is_up&#39; UCAST(&#39;small &#8594; &#39;big)]<span class="hidden">&#8681;</span><sub>a</sub> (snat_assn&#39; TYPE(&#39;small::len2))<span class="hidden">&#8679;</span><sup>k</sup> &#8594; snat_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>in_unat_rel_conv_assn</span><span> </span><span>in_snat_rel_conv_assn</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>snat_snat_upcast_refine</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="tfree">&#39;big</span><span> </span><span class="tfree">&#39;small</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_snat_downcast_refine</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(snat_snat_downcast TYPE(&#39;small), PR_CONST (mop_snat_snat_downcast TYPE(&#39;small))) 
      &#8712; [&#955;x. is_down&#39; UCAST(&#39;big &#8594; &#39;small) &#8743; x&lt;max_snat LENGTH(&#39;small)]<span class="hidden">&#8681;</span><sub>a</sub> (snat_assn&#39; TYPE(&#39;big))<span class="hidden">&#8679;</span><sup>k</sup> &#8594; snat_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>in_unat_rel_conv_assn</span><span> </span><span>in_snat_rel_conv_assn</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>snat_snat_downcast_refine</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="tfree">&#39;big</span><span> </span><span class="tfree">&#39;small</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>BIG</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;big::len&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>SMALL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;small::len&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_unat_upcast_refine</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(unat_unat_upcast TYPE(&#39;big), PR_CONST (mop_unat_unat_upcast TYPE(&#39;big))) &#8712; [&#955;_. is_up&#39; UCAST(&#39;small &#8594; &#39;big)]<span class="hidden">&#8681;</span><sub>a</sub> (unat_assn&#39; TYPE(&#39;small::len))<span class="hidden">&#8679;</span><sup>k</sup> &#8594; unat_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>in_unat_rel_conv_assn</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>unat_unat_upcast_refine</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="tfree">&#39;big</span><span> </span><span class="tfree">&#39;small</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_unat_downcast_refine</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(unat_unat_downcast TYPE(&#39;small), PR_CONST (mop_unat_unat_downcast TYPE(&#39;small))) 
      &#8712; [&#955;x. is_down&#39; UCAST(&#39;big &#8594; &#39;small) &#8743; x&lt;max_unat LENGTH(&#39;small)]<span class="hidden">&#8681;</span><sub>a</sub> (unat_assn&#39; TYPE(&#39;big::len))<span class="hidden">&#8679;</span><sup>k</sup> &#8594; unat_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>in_unat_rel_conv_assn</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>unat_unat_downcast_refine</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="tfree">&#39;big</span><span> </span><span class="tfree">&#39;small</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>T</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;l::len2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_snat_conv_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;x. x, op_unat_snat_conv) 
    &#8712; [&#955;x. x&lt;max_snat LENGTH(&#39;l::len2)]<span class="hidden">&#8681;</span><sub>f</sub> unat_rel&#39; TYPE(&#39;l) &#8594; snat_rel&#39; TYPE(&#39;l)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> 
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>frefI</span><span> 
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_rel_def</span><span> </span><span>unat_rel_def</span><span> </span><span>snat.rel_def</span><span> </span><span>unat.rel_def</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span> </span><span>max_snat_def</span><span> </span><span>snat_invar_alt</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">)</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span>unat_snat_conv_refine</span><span class="delimiter">[</span><span>sepref_param</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="tfree">&#39;l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_unat_conv_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;x. x, op_snat_unat_conv)
    &#8712; snat_rel&#39; TYPE(&#39;l) &#8594; unat_rel&#39; TYPE(&#39;l)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>frefI</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_rel_def</span><span> </span><span>unat_rel_def</span><span> </span><span>snat.rel_def</span><span> </span><span>unat.rel_def</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span> </span><span>max_snat_def</span><span> </span><span>snat_invar_alt</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span>snat_unat_conv_refine</span><span class="delimiter">[</span><span>sepref_param</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="tfree">&#39;l</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Converting to Word&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;of_nat :: _ &#8658; _ word &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_nat_word_refine</span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(id,of_nat) &#8712; unat_rel&#39; TYPE(&#39;a::len) &#8594; word_rel&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_rel_def</span><span> </span><span>unat.rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Bit-Shifting&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> 
</span><span>  </span><span>shl_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&lt;&lt;):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>lshr_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&gt;&gt;):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>  </span><span>ashr_word</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&gt;&gt;&gt;):: _ word &#8658; _&quot;</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shl_hnr_unat</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_shl,uncurry (RETURN oo (&lt;&lt;))) &#8712; [&#955;(a,b). b &lt; LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> (word_assn :: &#39;a::len word &#8658; _)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; word_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat_rel_def</span><span> </span><span>unat.assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>unat.assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lshr_hnr_unat</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_lshr,uncurry (RETURN oo (&gt;&gt;))) &#8712; [&#955;(a,b). b &lt; LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> (word_assn :: &#39;a::len word &#8658; _)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; word_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat_rel_def</span><span> </span><span>unat.assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>unat.assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ashr_hnr_unat</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_ashr,uncurry (RETURN oo (&gt;&gt;&gt;))) &#8712; [&#955;(a,b). b &lt; LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> (word_assn :: &#39;a::len word &#8658; _)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> unat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; word_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat_rel_def</span><span> </span><span>unat.assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>unat.assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shl_hnr_snat</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_shl,uncurry (RETURN oo (&lt;&lt;))) &#8712; [&#955;(a,b). b &lt; LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> (word_assn :: &#39;a::len2 word &#8658; _)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; word_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snat_rel_def</span><span> </span><span>snat.assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>snat.assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>snat_eq_unat</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lshr_hnr_snat</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_lshr,uncurry (RETURN oo (&gt;&gt;))) &#8712; [&#955;(a,b). b &lt; LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> (word_assn :: &#39;a::len2 word &#8658; _)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; word_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snat_rel_def</span><span> </span><span>snat.assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>snat.assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>snat_eq_unat</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ashr_hnr_snat</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry ll_ashr,uncurry (RETURN oo (&gt;&gt;&gt;))) &#8712; [&#955;(a,b). b &lt; LENGTH(&#39;a)]<span class="hidden">&#8681;</span><sub>a</sub> (word_assn :: &#39;a::len2 word &#8658; _)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; word_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snat_rel_def</span><span> </span><span>snat.assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>snat.assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>snat_eq_unat</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  
</span><span>      
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Bounds Solver Setup&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_unat_rel_boundsD</span><span class="delimiter">[</span><span>sepref_bounds_dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(w, n) &#8712; unat_rel&#39; TYPE(&#39;l) &#10233; n &lt; max_unat LENGTH(&#39;l::len)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unat_rel_def</span><span> </span><span>unat.rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma snat_rel_imp_less_max_snat: 
  &quot;&#10214;(x,n)&#8712;snat_rel&#39; TYPE(&#39;l::len2); L = LENGTH(&#39;l)&#10215; &#10233; n&lt;max_snat L&quot;
  by (auto simp: snat_rel_def snat.rel_def in_br_conv)
*)</span></span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_snat_rel_boundsD</span><span class="delimiter">[</span><span>sepref_bounds_dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(w, n) &#8712; snat_rel&#39; TYPE(&#39;l) &#10233; n &lt; max_snat LENGTH(&#39;l::len2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_rel_def</span><span> </span><span>snat.rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_sint_rel_boundsD</span><span class="delimiter">[</span><span>sepref_bounds_dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(w,i)&#8712;sint_rel&#39; TYPE(&#39;l::len) &#10233; min_sint LENGTH(&#39;l) &#8804; i &#8743; i &lt; max_sint LENGTH(&#39;l)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sint_rel_def</span><span> </span><span>sint.rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_bounds_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>max_snat_def</span><span> </span><span>max_unat_def</span><span> </span><span>max_sint_def</span><span> </span><span>min_sint_def</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Default Inlinings&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>id_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;HOL Combinators&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;If&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_if_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; hn_val bool1_rel a a&#39; ** &#915;1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>RT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#10233; hn_refine (hn_val bool1_rel a a&#39; ** &#915;1) b&#39; &#915;2b R b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>RE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;a &#10233; hn_refine (hn_val bool1_rel a a&#39; ** &#915;1) c&#39; &#915;2c R c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>MERGE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MERGE &#915;2b fb &#915;2c fc &#915;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine &#915; 
    (llc_if a&#39; (doM {r&#8592;b&#39;; fb; return r}) (doM {r&#8592;c&#39;; fc; return r})) 
    &#915;&#39; R (if a then b else c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_nofailI</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nofail (if a then b else c)&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>vcg_normalize_simps</span><span class="delimiter">,</span><span> </span><span>fri_prepare_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_val bool1_rel = &#8639;bool.assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bool1_rel_def</span><span> </span><span>bool.assn_is_rel</span><span> </span><span>hn_ctxt_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>MERGED</span><span class="delimiter">[</span><span>OF</span><span> </span><span>MERGE</span><span class="delimiter">]</span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NF</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nofail b&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>RT</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>hn_refineD</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>rule</span><span> </span><span>vcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NF</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nofail c&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>RE</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>hn_refineD</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>rule</span><span> </span><span>vcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_if</span><span class="delimiter">[</span><span>sepref_comb_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; hn_val bool1_rel a a&#39; ** &#915;1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>RT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#10233; hn_refine (hn_val bool1_rel a a&#39; ** &#915;1) b&#39; &#915;2b R b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>RE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;a &#10233; hn_refine (hn_val bool1_rel a a&#39; ** &#915;1) c&#39; &#915;2c R c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>MERGE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TERM If &#10233; MERGE &#915;2b fb &#915;2c fc &#915;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine &#915; 
    (llc_if a&#39; (doM {r&#8592;b&#39;; fb; return r}) (doM {r&#8592;c&#39;; fc; return r})) 
    &#915;&#39; R (If$a$b$c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P</span><span> </span><span>RT</span><span> </span><span>RE</span><span> </span><span>MERGE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>TERMI</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>APP_def</span><span> </span><span>PROTECT2_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_if_aux</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;While&#8250;</span></span></span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move WHILE-stuff to HOL-Bindings Theory *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WHILEIT_pat</span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;WHILEIT$I &#8801; UNPROTECT (WHILEIT I)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;WHILET &#8801; PR_CONST (WHILEIT (&#955;_. True))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>WHILET_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>id_WHILEIT</span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;PR_CONST (WHILEIT I) ::<span class="hidden">&#8681;</span><sub>i</sub> TYPE((&#39;a &#8658; bool) &#8658; (&#39;a &#8658; &#39;a nres) &#8658; &#39;a &#8658; &#39;a nres)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WHILE_arities</span><span class="delimiter">[</span><span>sepref_monadify_arity</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&quot;WHILET &#8801; WHILEIT$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>_. True)&quot;*)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;PR_CONST (WHILEIT I) &#8801; &#955;<span class="hidden">&#8681;</span><sub>2</sub>b f s. SP (PR_CONST (WHILEIT I))$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>s. b$s)$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>s. f$s)$s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>WHILET_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WHILEIT_comb</span><span class="delimiter">[</span><span>sepref_monadify_comb</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;PR_CONST (WHILEIT I)$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>x. b x)$f$s &#8801; 
    Refine_Basic.bind$(EVAL$s)$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>s. 
      SP (PR_CONST (monadic_WHILEIT I))$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>x. (EVAL$(b x)))$f$s
    )&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>WHILEIT_to_monadic</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monadic_WHILEIT_pat</span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;monadic_WHILEIT$I &#8801; UNPROTECT (monadic_WHILEIT I)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>id_monadic_WHILEIT</span><span class="delimiter">[</span><span>id_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;PR_CONST (monadic_WHILEIT I) ::<span class="hidden">&#8681;</span><sub>i</sub> TYPE((&#39;a &#8658; bool nres) &#8658; (&#39;a &#8658; &#39;a nres) &#8658; &#39;a &#8658; &#39;a nres)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monadic_WHILEIT_arities</span><span class="delimiter">[</span><span>sepref_monadify_arity</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;PR_CONST (monadic_WHILEIT I) &#8801; &#955;<span class="hidden">&#8681;</span><sub>2</sub>b f s. SP (PR_CONST (monadic_WHILEIT I))$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>s. b$s)$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>s. f$s)$s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monadic_WHILEIT_comb</span><span class="delimiter">[</span><span>sepref_monadify_comb</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;PR_CONST (monadic_WHILEIT I)$b$f$s &#8801; 
    Refine_Basic.bind$(EVAL$s)$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>s. 
      SP (PR_CONST (monadic_WHILEIT I))$b$f$s
    )&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_refine_add_invalid</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Very customized rule for manual derivation of while *)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine (hn_ctxt Rs a b ** &#915;) c &#915;&#39; R m &#10233; hn_refine (hn_ctxt Rs a b ** &#915;) c (hn_invalid Rs a b ** &#915;&#39;) R m&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>hn_refine_frame&#39;</span><span> </span><span>invalidate_clone&#39;</span><span> </span><span>sep_conj_commute</span><span> </span><span>sep_conj_left_commute</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_monadic_WHILE_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8866; hn_ctxt Rs s&#39; s ** &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b_ref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;s s&#39;. I s&#39; &#10233; hn_refine 
    (hn_ctxt Rs s&#39; s ** &#915;)
    (b s)
    (&#915;b s&#39; s)
    (pure bool1_rel)
    (b&#39; s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b_fr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;s&#39; s. &#915;b s&#39; s &#8866; hn_ctxt Rs s&#39; s ** &#915;&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f_ref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;s&#39; s. &#10214;I s&#39;&#10215; &#10233; hn_refine
    (hn_ctxt Rs s&#39; s ** &#915;)
    (f s)
    (&#915;f s&#39; s)
    Rs
    (f&#39; s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f_fr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;s&#39; s. &#915;f s&#39; s &#8866; hn_ctxt Rsf s&#39; s ** &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>free</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE Rsf fr&quot;</span></span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*assumes PREC: &quot;precise Rs&quot;*)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine (P) (llc_while b (&#955;s. doM {r &#8592; f s; fr s; return r}) s) (hn_invalid Rs s&#39; s ** &#915;) Rs (monadic_WHILEIT I b&#39; f&#39; s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FR</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_add_invalid</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_synthI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>monadic_WHILEIT_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">focus</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hnr_RECT</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>F&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;s&#39; s. &#915;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ry</span><span class="delimiter">=</span><span>Rs</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hnr_ASSERT</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">focus</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hnr_bind_manual_free</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>b_ref</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons_pre</span><span class="delimiter">,</span><span> </span><span>sep_drule</span><span> </span><span>b_fr</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>entails_refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">focus</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_if_aux</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>MERGE_triv</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fri_rotate</span><span> </span><span>entails_pre_cong</span><span> </span><span class="delimiter">:</span><span>-</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conj_entails_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>entails_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>entails_refl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">focus</span></span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Then-Part *)</span></span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons_pre</span><span class="delimiter">,</span><span> </span><span>sep_drule</span><span> </span><span>drop_hn_val</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>entails_refl</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hnr_bind_manual_free</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>f_ref</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons_pre</span><span class="delimiter">,</span><span> </span><span>sep_drule</span><span> </span><span>f_fr</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>entails_refl</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hnr_freeI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>free</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons_pre</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sep_conj_ac</span><span class="delimiter">;</span><span> </span><span>rule</span><span> </span><span>entails_refl</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">solved</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">focus</span></span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Else-Part *)</span></span></span></span></span><span>  
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons_post</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_frame</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hnr_RETURN_pass</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fri_rotate</span><span> </span><span>entails_pre_cong</span><span> </span><span class="delimiter">:</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>entails_refl</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_drule</span><span> </span><span>drop_hn_invalid</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_drule</span><span> </span><span>drop_hn_val</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">solved</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">solved</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">solved</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">focus</span></span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>pf_mono_prover</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">solved</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">solved</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>llc_while_def</span><span> </span><span>mwhile_def</span><span> </span><span>llc_if_def</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_monadic_WHILE_lin</span><span class="delimiter">[</span><span>sepref_comb_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;INDEP Rs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8866; hn_ctxt Rs s&#39; s ** &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b_ref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;s s&#39;. I s&#39; &#10233; hn_refine 
    (hn_ctxt Rs s&#39; s ** &#915;)
    (b s)
    (&#915;b s&#39; s)
    (pure bool1_rel)
    (b&#39; s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>b_fr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;s&#39; s. TERM (monadic_WHILEIT,&#39;&#39;cond&#39;&#39;) &#10233; &#915;b s&#39; s &#8866; hn_ctxt Rs s&#39; s ** &#915;&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f_ref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;s&#39; s. I s&#39; &#10233; hn_refine
    (hn_ctxt Rs s&#39; s ** &#915;)
    (f s)
    (&#915;f s&#39; s)
    Rs
    (f&#39; s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f_fr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;s&#39; s. TERM (monadic_WHILEIT,&#39;&#39;body&#39;&#39;) &#10233; &#915;f s&#39; s &#8866; hn_ctxt Rsf s&#39; s ** &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>free</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TERM (monadic_WHILEIT,&#39;&#39;free-old-state&#39;&#39;) &#10233; MK_FREE Rsf fr&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine 
    P 
    (llc_while b (&#955;s. doM {r &#8592; f s; fr s; return r}) s) 
    (hn_invalid Rs s&#39; s ** &#915;)
    Rs 
    (PR_CONST (monadic_WHILEIT I)$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>s&#39;. b&#39; s&#39;)$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>s&#39;. f&#39; s&#39;)$(s&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span>-</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>APP_def</span><span> </span><span>PROTECT2_def</span><span> </span><span>CONSTRAINT_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_monadic_WHILE_aux</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Let&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_let</span><span class="delimiter">[</span><span>sepref_comb_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine &#915; c &#915;&#39; R (Refine_Basic.bind$(PASS$v)$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>x. f x)) &#10233; hn_refine &#915; c &#915;&#39; R (Let$v$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>x. f x))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Unit&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unit_hnr</span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((),())&#8712;unit_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Product&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_rewrite</span><span class="delimiter">,</span><span> </span><span>sepref_frame_normrel_eqs</span><span class="delimiter">,</span><span> </span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>prod_assn_pure_conv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO Add corresponding rules for other types and add to datatype snippet *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>intf_of_prod_assn</span><span class="delimiter">[</span><span>intf_of_assn</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intf_of_assn A TYPE(&#39;a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intf_of_assn B TYPE(&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;intf_of_assn (prod_assn A B) TYPE(&#39;a * &#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_prod</span><span class="delimiter">[</span><span>constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure P1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure P2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure (prod_assn P1 P2)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P1</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P1&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P1&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x x&#39;. P1 x x&#39; = &#8593;(P1&#39; x x&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_pureE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P2</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P2&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x x&#39;. P2 x x&#39; = &#8593;(P2&#39; x x&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_pureE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>x&#39;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prod_assn P1 P2 x x&#39; =
         &#8593; (case (x, x&#39;) of ((a1, a2), c1, c2) &#8658; P1&#39; a1 c1 &#8743; P2&#39; a2 c2)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prod_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>P1&#39;</span><span> </span><span>P2&#39;</span><span> </span><span>sep_algebra_simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prod_frame_match</span><span class="delimiter">[</span><span>sepref_frame_match_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt A (fst x) (fst y) &#8866; hn_ctxt A&#39; (fst x) (fst y)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt B (snd x) (snd y) &#8866; hn_ctxt B&#39; (snd x) (snd y)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_ctxt (prod_assn A B) x y &#8866; hn_ctxt (prod_assn A&#39; B&#39;) x y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>y</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conj_entails_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prod_frame_merge</span><span class="delimiter">[</span><span>sepref_frame_merge_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MERGE1 A frl1 A&#39; frr1 Am&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MERGE1 B frl2 B&#39; frr2 Bm&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MERGE1 
    (prod_assn A B) (&#955;(a,b). doM {frl1 a; frl2 b}) 
    (prod_assn A&#39; B&#39;) (&#955;(a,b). doM {frr1 a; frr2 b}) 
    (prod_assn Am Bm)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>MERGE1D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>MERGE1D</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>rule</span><span> </span><span>vcg</span><span>
</span><span>    
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entt_invalid_prod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_invalid (prod_assn A B) p p&#39; &#8866; hn_ctxt (prod_assn (invalid_assn A) (invalid_assn B)) p p&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hn_ctxt_def</span><span> </span><span>invalid_assn_def</span><span> </span><span>prod_assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>entails_def</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>pure_part_split_conj</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_merge_cons_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;L&#8866;L&#39; &#10233; MERGE L&#39; fl R fr M &#10233; MERGE L fl R fr M&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>MERGE_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>cons_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q&#39;</span><span class="delimiter">=</span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span>entails_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_merge_cons_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;R&#8866;R&#39; &#10233; MERGE L fl R&#39; fr M &#10233; MERGE L fl R fr M&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>MERGE_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>cons_rule</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q&#39;</span><span class="delimiter">=</span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span>entails_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>gen_merge_cons</span><span> </span><span class="delimiter">=</span><span> </span><span>gen_merge_cons_left</span><span> </span><span>gen_merge_cons_right</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>invalid_prod_merge</span><span class="delimiter">[</span><span>sepref_frame_merge_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>gen_merge_cons</span><span class="delimiter">[</span><span>OF</span><span> </span><span>entt_invalid_prod</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prod_assn_ctxt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prod_assn A1 A2 x y = z &#10233; hn_ctxt (prod_assn A1 A2) x y = z&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>drop_pureD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure A &#10233; hn_ctxt A a b &#8866; &#9633;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_pure_def</span><span> </span><span>entails_def</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_case_prod_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; hn_ctxt (prod_assn P1 P2) p&#39; p ** &#915;1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a1 a2 a1&#39; a2&#39;. &#10214;p&#39;=(a1&#39;,a2&#39;)&#10215; 
    &#10233; hn_refine (hn_ctxt P1 a1&#39; a1 ** hn_ctxt P2 a2&#39; a2 ** &#915;1 ** hn_invalid (prod_assn P1 P2) p&#39; p) (f a1 a2) 
          (hn_ctxt P1&#39; a1&#39; a1 ** hn_ctxt P2&#39; a2&#39; a2 ** hn_ctxt XX1 p&#39; p ** &#915;1&#39;) R (f&#39; a1&#39; a2&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PURE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Sepref_Basic.is_pure XX1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine &#915; (case_prod f p) (hn_ctxt (prod_assn P1&#39; P2&#39;) p&#39; p ** &#915;1&#39;)
    R (case_prod f&#39; p&#39;)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?G &#915;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FR</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span>extract_hnr_invalids</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>p&#39;</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prod_assn_pair_conv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>prod_assn_ctxt</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>Pair</span><span> </span><span>_</span><span> </span><span>entails_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PURE</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>sep_drule</span><span> </span><span>drop_pureD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>PURE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span> </span><span>sep_conj_ac</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>    
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_case_prod&#39;</span><span class="delimiter">[</span><span>sepref_comb_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866; hn_ctxt (prod_assn P1 P2) p&#39; p ** &#915;1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a1 a2 a1&#39; a2&#39;. &#10214;p&#39;=(a1&#39;,a2&#39;)&#10215; 
    &#10233; hn_refine (hn_ctxt P1 a1&#39; a1 ** hn_ctxt P2 a2&#39; a2 ** &#915;1 ** hn_invalid (prod_assn P1 P2) p&#39; p) (f a1 a2) 
          (&#915;2 a1 a2 a1&#39; a2&#39;) R (f&#39; a1&#39; a2&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FR2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a1 a2 a1&#39; a2&#39;. &#915;2 a1 a2 a1&#39; a2&#39; &#8866; hn_ctxt P1&#39; a1&#39; a1 ** hn_ctxt P2&#39; a2&#39; a2 ** hn_ctxt XX1 p&#39; p ** &#915;1&#39;&quot;</span></span></span><span>        
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>PURE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;CONSTRAINT Sepref_Basic.is_pure XX1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hn_refine &#915; (case_prod f p) (hn_ctxt (prod_assn P1&#39; P2&#39;) p&#39; p ** &#915;1&#39;)
    R (case_prod$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>a b. f&#39; a b)$p&#39;)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?G &#915;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>autoref_tag_defs</span><span> </span><span>PROTECT2_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_case_prod_aux</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>hn_refine_cons_post</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FR2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PURE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_Pair</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry (return oo Pair), uncurry (RETURN oo Pair)) &#8712; A<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> B<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> A&#215;<span class="hidden">&#8681;</span><sub>a</sub>B&quot;</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_to_hoare</span><span> </span><span>vcg</span><span>
</span><span>    
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma fst_hnr[sepref_fr_rules]: &quot;(return o fst,RETURN o fst) &#8712; (prod_assn A B)<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> A&quot;
  by sepref_to_hoare vcg
lemma snd_hnr[sepref_fr_rules]: &quot;(return o snd,RETURN o snd) &#8712; (prod_assn A B)<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> B&quot;
  by sepref_to_hoare sep_auto
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>constraint_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>prod_assn_pure_conv</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>param_prod_swap</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rdomp_prodD</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rdomp (prod_assn A B) (a,b) &#10233; rdomp A a &#8743; rdomp B b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rdomp_def</span><span> </span><span>prod_assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_conj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Option&#8250;</span></span></span><span>  
</span><span>
</span><span>   
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>option_patterns</span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(=)$x$None &#8801; is_None$x&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(=)$None$x &#8801; is_None$x&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;op_neq$x$None &#8801; Not$(is_None$x)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;op_neq$None$x &#8801; Not$(is_None$x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rule eq_reflection&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Option type via unused implementation value&#8250;</span></span></span><span>  
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dflt_option</span><span> </span><span class="delimiter">=</span><span>   
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>dflt</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;c::llvm_rep &#8658; assn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>is_dflt</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>UU</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A a dflt = sep_false&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>CMP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple &#9633; (is_dflt k) (&#955;r. &#8639;bool.assn (k=dflt) r)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;option_assn a c &#8801; if c=dflt then &#8593;(a=None) else EXS aa. &#8593;(a=Some aa) ** A aa c&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_None</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry0 (return dflt), uncurry0 (RETURN None)) &#8712; unit_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> option_assn&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>option_assn_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_Some</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(return, RETURN o Some) &#8712; A<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> option_assn&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>c</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c=dflt&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UU</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>option_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_the</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(return, RETURN o the) &#8712; [&#955;x. x &#8800; None]<span class="hidden">&#8681;</span><sub>a</sub> option_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>option_assn_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_is_None</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(is_dflt, RETURN o is_None) &#8712; option_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bool1_rel_def</span><span> </span><span>bool.assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>option_assn_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>CMP</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;free_option fr c &#8801; doM { d&#8592;is_dflt c; llc_if d (return ()) (fr c) }&quot;</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mk_free_option</span><span class="delimiter">[</span><span>sepref_frame_free_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>MK_FREED</span><span class="delimiter">,</span><span> </span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE A fr&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE option_assn (free_option fr)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_option_def</span><span> </span><span>option_assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>CMP</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>option_assn_pure</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure A&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure option_assn&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A = (&#955;a c. &#8593;(P a c))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_pure_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_pureI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a c. if c=dflt then a=None else &#8707;aa. a=Some aa &#8743; P aa c&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>option_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>    
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>named_ss</span><span> </span><span>llvm_inline</span><span> </span><span>cong</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dflt_option.free_option _&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dflt_pure_option</span><span> </span><span class="delimiter">=</span><span> </span><span>dflt_option</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A_pure</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span>MK_FREE</span><span> </span><span>is_pure</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_free</span><span class="delimiter">[</span><span>sepref_frame_free_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE A (&#955;_. return ())&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mk_free_is_pure</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A_pure</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Redundancies with dflt_option *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Setup id-op phase to identify those operations *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Option type via unused implementation value, own set of operations.&#8250;</span></span></span><span>  
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dflt_option_private</span><span> </span><span class="delimiter">=</span><span>   
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>dflt</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;c::llvm_rep &#8658; assn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>is_dflt</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>UU</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A a dflt = sep_false&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>CMP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple &#9633; (is_dflt k) (&#955;r. &#8639;bool.assn (k=dflt) r)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;option_assn a c &#8801; if c=dflt then &#8593;(a=None) else EXS aa. &#8593;(a=Some aa) ** A aa c&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>None</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;None &#8801; Option.None&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Some</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Some &#8801; Option.Some&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>the</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the &#8801; Option.the&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_None</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_None &#8801; Autoref_Bindings_HOL.is_None&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fold_None</span><span> </span><span class="delimiter">=</span><span> </span><span>None_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fold_Some</span><span> </span><span class="delimiter">=</span><span> </span><span>Some_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fold_the</span><span> </span><span class="delimiter">=</span><span> </span><span>the_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fold_is_None</span><span> </span><span class="delimiter">=</span><span> </span><span>is_None_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fold_is_None2</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;a = None &#10231; is_None a&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;None = a &#10231; is_None a&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_None_def</span><span> </span><span>None_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fold_option</span><span> </span><span class="delimiter">=</span><span> </span><span>fold_None</span><span> </span><span>fold_Some</span><span> </span><span>fold_the</span><span> </span><span>fold_is_None</span><span> </span><span>fold_is_None2</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>None</span><span> </span><span>Some</span><span> </span><span>the</span><span> </span><span>is_None</span><span>
</span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_None</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry0 (return dflt), uncurry0 (RETURN None)) &#8712; unit_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> option_assn&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>option_assn_def</span><span> </span><span>None_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_Some</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(return, RETURN o Some) &#8712; A<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> option_assn&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>c</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c=dflt&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UU</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>option_assn_def</span><span> </span><span>Some_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_the</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(return, RETURN o the) &#8712; [&#955;x. x &#8800; Option.None]<span class="hidden">&#8681;</span><sub>a</sub> option_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>option_assn_def</span><span> </span><span>the_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_is_None</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(is_dflt, RETURN o is_None) &#8712; option_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bool1_rel_def</span><span> </span><span>bool.assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>option_assn_def</span><span> </span><span>is_None_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>CMP</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;free_option fr c &#8801; doM { d&#8592;is_dflt c; llc_if d (return ()) (fr c) }&quot;</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mk_free_option</span><span class="delimiter">[</span><span>sepref_frame_free_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>MK_FREED</span><span class="delimiter">,</span><span> </span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE A fr&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE option_assn (free_option fr)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>free_option_def</span><span> </span><span>option_assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>CMP</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>option_assn_pure</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure A&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure option_assn&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A = (&#955;a c. &#8593;(P a c))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_pure_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_pureI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a c. if c=dflt then a=Option.None else &#8707;aa. a=Option.Some aa &#8743; P aa c&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>option_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>    
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>named_ss</span><span> </span><span>llvm_inline</span><span> </span><span>cong</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>refl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dflt_option_private.free_option _&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dflt_pure_option_private</span><span> </span><span class="delimiter">=</span><span> </span><span>dflt_option_private</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A_pure</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_free</span><span class="delimiter">[</span><span>sepref_frame_free_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE A (&#955;_. return ())&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mk_free_is_pure</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A_pure</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>snat</span><span class="delimiter">:</span><span> </span><span>dflt_pure_option</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;-1&quot;</span></span></span><span> </span><span>snat_assn</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ll_icmp_eq (-1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_rel_def</span><span> </span><span>pure_def</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat.rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bool.assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>snat_option_assn&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a itself &#8658; nat option &#8658; &#39;a::len2 word &#8658; llvm_amemory &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat_option_assn&#39; _ &#8801; snat.option_assn&quot;</span></span></span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Additional Operations&#8250;</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Additional operations, for which we need the basic framework already set up.&#8250;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Subtraction that Saturates at 0 on Underflow&#8250;</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>op_nat_sub_ovf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;op_nat_sub_ovf a b &#8801; if a&#8804;b then 0 else a-b&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>op_nat_sub_ovf_is_sub</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;op_nat_sub_ovf = (-)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_nat_sub_ovf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fold_nat_sub_ovf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(-) = op_nat_sub_ovf&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>snat_sub_ovf_impl</span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (RETURN oo op_nat_sub_ovf)&quot;</span></span></span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(snat_assn&#39; TYPE(&#39;l::len2))<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (snat_assn&#39; TYPE(&#39;l::len2))<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> snat_assn&#39; TYPE(&#39;l::len2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_nat_sub_ovf_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>snat_sub_ovf_impl.refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span>    
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Ad-Hoc Regression Tests&#8250;</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>example1</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;x. ASSERT (x&#8712;{-10..10}) &#10914; 
    RETURN (x&lt;5 &#8743; x&#8800;2 &#10230; x-2 &#8800; 0)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(sint_assn&#39; TYPE(7))<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> (bool1_assn)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_sint_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(7)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>example2</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;x. ASSERT (x&#8712;{-10..10}) &#10914; RETURN (x+(-1) * (7 smod 15) - 3 sdiv 2)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(sint_assn&#39; TYPE(7))<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> (sint_assn&#39; TYPE(7))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_sint_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(7)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>example1n</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;x. ASSERT (x&#8712;{2..10}) &#10914; 
    RETURN (x&lt;5 &#8743; x&#8800;2 &#10230; x-2 &#8800; 0)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(snat_assn&#39; TYPE(7))<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> (bool1_assn)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(7)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>example2n</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;x. ASSERT (x&#8712;{5..10}) &#10914; RETURN ((x-1) * (7 mod 15) - 3 div 2)&quot;</span></span></span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(snat_assn&#39; TYPE(7))<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> (snat_assn&#39; TYPE(7))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(7)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>      
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>llvm_code</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>example1_def</span><span> </span><span>example2_def</span><span> </span><span>example1n_def</span><span> </span><span>example2n_def</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">llvm_deps</span></span><span> </span><span>example1</span><span> </span><span>example2</span><span> </span><span>example1n</span><span> </span><span>example2n</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_llvm</span></span><span> </span><span>example1</span><span> </span><span>example2</span><span> </span><span>example1n</span><span> </span><span>example2n</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>example3_abs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len word &#8658; &#39;a word &#8658; &#39;a word nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;example3_abs a b &#8801; do {
    (a,b) &#8592; WHILET (&#955;(a,b). a&#8800;b) (&#955;(a,b). if a&lt;b then RETURN (a,b-a) else RETURN (a-b,b)) (a,b);
    RETURN a
  }&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>example3</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry example3_abs&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> word_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> word_assn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>example3_abs_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_dbg_keep</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>example3n_abs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; nat nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;example3n_abs a b &#8801; do {
    (a,b) &#8592; WHILET (&#955;(a,b). a&#8800;b) (&#955;(a,b). if a&lt;b then RETURN (a,b-a) else RETURN (a-b,b)) (a,b);
    RETURN a
  }&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>example3n</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry example3n_abs&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(snat_assn&#39; TYPE(32))<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (snat_assn&#39; TYPE(32))<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> (snat_assn&#39; TYPE(32))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>example3n_abs_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_dbg_keep</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  
</span><span>    
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>llvm_code</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>example3_def</span><span> </span><span>example3n_def</span><span>  
</span><span class="keyword1"><span class="command">export_llvm</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;example3 :: 32 word &#8658; _&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;example3 :: 64 word &#8658; _&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;example3n&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Characters as i8 *)</span></span></span></span></span><span>  
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


