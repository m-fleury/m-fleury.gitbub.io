<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory IICF_Impl_Heapmap (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory IICF_Impl_Heapmap</h1>

<span class="command">theory</span> <span class="name">IICF_Impl_Heapmap</span><br/>
<span class="keyword">imports</span> <a href="IICF_Abs_Heapmap.html"><span class="name">IICF_Abs_Heapmap</span></a> <a href="IICF_Array_List.html"><span class="name">IICF_Array_List</span></a> <a href="IICF_Array_Map_Total.html"><span class="name">IICF_Array_Map_Total</span></a> <a href="IICF_Indexed_Array_List.html"><span class="name">IICF_Indexed_Array_List</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Implementation of Heaps by Arrays&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IICF_Impl_Heapmap</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> 
</span><span>  </span><span>IICF_Abs_Heapmap</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;../IICF_Array&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;../IICF_Array_List&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;../IICF_Array_Map_Total&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;../IICF_Indexed_Array_List&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>hm_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>hmstruct</span><span> </span><span>prio</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>prio</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;e &#8658; &#39;p::linorder&quot;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>prio_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;p &#8658; &#39;pi::llvm_rep &#8658; assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>elem_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;e &#8658; &#39;ei::llvm_rep &#8658; assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>prio_impl</span><span> </span><span>le_prio_impl</span><span> </span><span>lt_prio_impl</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ltype</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;l::len2 itself&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prio_is_pure</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure prio_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>elem_is_pure</span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure elem_assn&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prio_impl_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(prio_impl, RETURN o prio)&#8712;elem_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> prio_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>le_prio_impl_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry le_prio_impl, uncurry (RETURN oo (&#8804;))) &#8712; prio_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> prio_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lt_prio_impl_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry lt_prio_impl, uncurry (RETURN oo (&lt;))) &#8712; prio_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> prio_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>      
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;idx_assn &#8801; snatb_assn&#39; TYPE(&#39;l) N&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;idx1_assn &#8801; snatb_assn&#39; TYPE(&#39;l) (Suc N)&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>prio</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8804;) :: &#39;p &#8658; &#39;p &#8658; bool&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&lt;) :: &#39;p &#8658; &#39;p &#8658; bool&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_frame_free_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>      </span><span>mk_free_is_pure</span><span class="delimiter">[</span><span>OF</span><span> </span><span>prio_is_pure</span><span class="delimiter">]</span><span>
</span><span>      </span><span>mk_free_is_pure</span><span class="delimiter">[</span><span>OF</span><span> </span><span>elem_is_pure</span><span class="delimiter">]</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn &#8801; b_assn (ial_assn&#39; TYPE(&#39;l) N &#215;<span class="hidden">&#8681;</span><sub>a</sub> amt_assn elem_assn N) (&#955;_. 4&lt;LENGTH(&#39;l) &#8743; N&lt;max_snat LENGTH(&#39;l))&quot;</span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm2_assn_rdomp_boundsI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rdomp (hm2_assn) (ag, bq) &#10233; 4&lt;LENGTH(&#39;l) &#8743; N&lt;max_snat LENGTH(&#39;l)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm2_assn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span>amt_assn</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_append_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry2 hm_append_op&quot;</span></span></span><span>
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>d</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>elem_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_append_op_def</span><span> </span><span>hm2_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_append_impl.refine</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_length_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RETURN o hm_length&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> snatb_assn&#39; TYPE(&#39;l) (N+1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_length_def</span><span> </span><span>hm2_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_length_impl.refine</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>hm2_assn</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_key_of_op</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_key_of_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry hm_key_of_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> idx1_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> idx_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_key_of_op_def</span><span> </span><span>hm2_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_key_of_impl.refine</span><span>
</span><span>      
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Optimization *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_the_lookup_op&#39; k hm &#8801; do {
      let (pq,ml) = hm;
      v &#8592; mop_map_the_lookup k ml;
      RETURN v
    }&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_the_lookup_op&#39;_refine</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_the_lookup_op&#39;, hm_the_lookup_op) &#8712; nat_rel &#8594; Id &#8594; &#10216;Id&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_the_lookup_op&#39;_def</span><span> </span><span>hm_the_lookup_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hmr_invar_def</span><span> </span><span>restrict_map_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_the_lookup_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry hm_the_lookup_op&#39;&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;idx_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>hm2_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> elem_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_the_lookup_op&#39;_def</span><span> </span><span>hm2_assn_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_the_lookup_impl_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="delimiter">=</span><span> </span><span>hm_the_lookup_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>hm_the_lookup_op&#39;_refine</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_val_of_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry hm_val_of_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> elem_assn&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_val_of_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_val_of_impl.refine</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_prio_of_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_prio_of_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (PR_CONST hm_prio_of_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> prio_assn&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_prio_of_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_prio_of_impl.refine</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;parent_valid h i &#8801; hm_valid h (h.parent i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;parent_valid&#39; h i &#8801; i&gt;(1::nat)&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_parent_pat</span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_valid$h$(h.parent$i) &#8801; parent_valid$h$i&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>parent_valid_def</span><span> </span><span>autoref_tag_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parent_valid&#39;_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry parent_valid&#39;,uncurry parent_valid) &#8712; [&#955;(h,i). hm_valid h i]<span class="hidden">&#8681;</span><sub>f</sub> Id&#215;<span class="hidden">&#8681;</span><sub>r</sub>Id&#8594;Id&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_valid_def</span><span> </span><span>parent_valid_def</span><span> </span><span>parent_valid&#39;_def</span><span> </span><span>hm_length_def</span><span> </span><span>h.parent_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>parent_valid_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (RETURN oo parent_valid&#39;)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>parent_valid&#39;_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>parent_valid_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>parent_valid&#39;_refine</span><span class="delimiter">]</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_exch_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry2 hm_exch_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>d</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>d</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_exch_op_def</span><span> </span><span>hm2_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_valid_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_exch_impl.refine</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>parent_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RETURN o h.parent&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#955;_. 4&lt;LENGTH(&#39;l)]<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594; idx1_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h.parent_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_bassn_resI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>parent_impl.refine</span><span>    
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span>hm_swim_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>h.parent</span><span> </span><span>hm_exch_op</span><span>
</span><span>    
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Very specialized workaround lemma, to work around invalid-recombination
      problem for case that B is pure. DUP in IICF_Heap_Impl.thy
    *)</span></span></span></span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>workaround_invalid_recombine_pure3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_pure B &#10233; hn_ctxt (invalid_assn A &#215;<span class="hidden">&#8681;</span><sub>a</sub> invalid_assn B) ax px &#8866; hn_invalid (A &#215;<span class="hidden">&#8681;</span><sub>a</sub> B) ax px&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hn_ctxt_def</span><span> </span><span>invalid_assn_def</span><span> </span><span>prod_assn_def</span><span> </span><span>entails_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>is_pureE</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pure_part_pure_conj_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span>argo</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span>is_pure</span><span> </span><span>b_assn</span><span>  
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_swim_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_swim_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (PR_CONST hm_swim_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>d</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_swim_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Workaround/Hack *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>X</span><span class="delimiter">[</span><span>sepref_frame_match_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>workaround_invalid_recombine_pure3</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;snatb_assn _&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm2_assn_rdomp_boundsI</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_swim_impl.refine</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_insert_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_insert_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry2 (PR_CONST hm_insert_op)&quot;</span></span></span><span> 
</span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;idx_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>elem_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>hm2_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_insert_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_insert_impl.refine</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rewr_2kleN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;2*k &#8804; n &#10231; k &#8804; n div 2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_has_child_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (RETURN oo hm_has_child_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_has_child_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>rewr_2kleN</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>dest</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm2_assn_rdomp_boundsI</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_has_child_impl.refine</span><span>    
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_left_child_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RETURN o hm_left_child_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#955;i. 2*i&#8804;N &#8743; N&lt;max_snat LENGTH(&#39;l) &#8743; 4&lt;LENGTH(&#39;l)]<span class="hidden">&#8681;</span><sub>a</sub> idx1_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594; idx1_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_left_child_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_bassn_resI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_left_child_impl.refine</span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rewr_kp1len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k+1 &#8804; n &#10231; k&lt;(n::nat)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_has_next_child_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (RETURN oo hm_has_next_child_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_has_next_child_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>rewr_kp1len</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_has_next_child_impl.refine</span><span>    
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_next_child_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RETURN o hm_next_child_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#955;i. i&lt;N &#8743; N&lt;max_snat LENGTH(&#39;l) &#8743; 4&lt;LENGTH(&#39;l)]<span class="hidden">&#8681;</span><sub>a</sub> idx1_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594; idx1_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_next_child_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_bassn_resI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_next_child_impl.refine</span><span>  
</span><span>    
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sink_sepref_aux2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hm_has_child_op (ag, bq) a2&#39;; rdomp hm2_assn (ag, bq)&#10215;
       &#10233; 2 * a2&#39; &#8804; N&quot;</span></span></span><span>   
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_has_child_op_def</span><span> </span><span>hm2_assn_def</span><span> </span><span>hm_length_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_bounds</span><span>
</span><span>       
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sink_sepref_aux3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hm_has_next_child_op (ag, bq) i; rdomp hm2_assn (ag, bq)&#10215; &#10233; i&lt;N&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_has_next_child_op_def</span><span> </span><span>hm2_assn_def</span><span> </span><span>hm_length_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_bounds</span><span>
</span><span>       
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_sink_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_sink_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (PR_CONST hm_sink_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>d</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_sink_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_length_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>sink_sepref_aux2</span><span> </span><span>sink_sepref_aux3</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>X</span><span class="delimiter">[</span><span>sepref_frame_match_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>workaround_invalid_recombine_pure3</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>B</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;snatb_assn _&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>dest</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm2_assn_rdomp_boundsI</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_sink_impl.refine</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_repair_op</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_repair_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (PR_CONST hm_repair_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>d</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_repair_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_repair_impl.refine</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_is_empty_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_is_empty_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_is_empty_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Cannot do lookup, unless we have option type! 
      &#8594; Do contains_key and the_lookup instead!
    sepref_definition hm_lookup_impl is &quot;uncurry hm_lookup&quot; :: &quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> elem_assn&quot;
    *)</span></span></span></span></span><span>  
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_contains_key_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_contains_key_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (PR_CONST hm_contains_key_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;idx_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_contains_key_op_def</span><span> </span><span>hm2_assn_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_contains_key_impl.refine</span><span>  
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_index_impl_aux1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;b &#8712; set a1&#39;; rdomp (ial_assn N) a1&#39;; N&lt;max_snat LENGTH(&#39;l)&#10215;
       &#10233; Suc (index a1&#39; b) &lt; max_snat LENGTH(&#39;l)&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_bounds</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>index_less</span><span> </span><span>less_trans_Suc</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_index_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry hm_index_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx_assn<span class="hidden">&#8679;</span><sup>d</sup>&#8594;<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_index_op_def</span><span> </span><span>hm2_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_bassn_resI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uncurry_def</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_bounds</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>restrict_map_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>restrict_map_eq</span><span> </span><span>hm_index_impl_aux1</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_index_impl.refine</span><span>  
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>hm_update_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_update_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry2 hm_update_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>d</sup>*<span class="hidden">&#8681;</span><sub>a</sub>idx1_assn<span class="hidden">&#8679;</span><sup>d</sup>*<span class="hidden">&#8681;</span><sub>a</sub>elem_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_update_op_def</span><span> </span><span>hm2_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_valid_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_update_impl.refine</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_decrease_key_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_decrease_key_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry2 (PR_CONST hm_decrease_key_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;idx_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> elem_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn &quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_decrease_key_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_decrease_key_impl.refine</span><span>
</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_increase_key_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_increase_key_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry2 (PR_CONST hm_increase_key_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;idx_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> elem_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn &quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_increase_key_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_increase_key_impl.refine</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_change_key_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_change_key_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry2 (PR_CONST hm_change_key_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;idx_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> elem_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn &quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_change_key_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_change_key_impl.refine</span><span>
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_set_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_set_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry2 (PR_CONST hm_set_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;idx_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>elem_assn<span class="hidden">&#8679;</span><sup>k</sup>*<span class="hidden">&#8681;</span><sub>a</sub>hm2_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_set_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_set_impl.refine</span><span>
</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_butlast_op</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_butlast_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_butlast_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_butlast_op_def</span><span> </span><span>hm2_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_butlast_impl.refine</span><span>      
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_pop_min_impl_aux1</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hm_valid (pq, m) (Suc 0); rdomp hm2_assn (pq, m)&#10215; &#10233; 0&lt;N&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm2_assn_def</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pq</span><span class="delimiter">;</span><span> </span><span>sepref_bounds</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_pop_min_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_pop_min_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;PR_CONST hm_pop_min_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> (idx_assn &#215;<span class="hidden">&#8681;</span><sub>a</sub> elem_assn) &#215;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_pop_min_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_pop_min_impl_aux1</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_pop_min_impl.refine</span><span>      
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_remove_op</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_remove_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry (PR_CONST hm_remove_op)&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;idx_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_remove_op_def</span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO Hack/Workaround: Prevents b_assn to be degraded when comparing.
        Deeper problem to fix: Do not degrade b_assn, even if operation is on basic assn!
      *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;if &#8977;&#8800;_ then _ else _&quot;</span></span></span><span> </span><span>fold_COPY</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_remove_impl.refine</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>hm_peek_min_op</span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_peek_min_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_peek_min_op&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm2_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> idx_assn&#215;<span class="hidden">&#8681;</span><sub>a</sub>elem_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_peek_min_op_def</span><span> </span><span>hm_kv_of_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_pop_min_impl_aux1</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_peek_min_impl.refine</span><span>
</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>    
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>hm_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;_::nat. op_map_empty&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat_rel &#8594; &#10216;K,V&#10217;map_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>hm_empty_fixed</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;op_hm_empty N&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10216;K,V&#10217;map_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>    
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fold_custom_hm_empty</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;Map.empty = op_hm_empty N&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;RETURN Map.empty = mop_hm_empty N&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;mop_map_empty = mop_hm_empty N&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fold_custom_hm_empty_fixed</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;Map.empty = op_hm_empty_fixed N&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;RETURN Map.empty = mop_hm_empty_fixed N&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;mop_map_empty = mop_hm_empty_fixed N&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>hm_empty_op</span><span>   
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_empty_op&#39; N &#8801; do { m&#8592;mop_amt_empty N; RETURN (op_ial_empty N,m) }&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_empty_op_N</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_empty_op&#39; N = hm_empty_op&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_empty_op_def</span><span> </span><span>hm_empty_op&#39;_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_empty_op&#39;_aref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_empty_op&#39;, mop_hm_empty) &#8712; nat_rel &#8594; &#10216;heapmap_rel&#10217;nres_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hm_empty_op_aref</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_empty_op_N</span><span class="delimiter">)</span><span>
</span><span>          
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>hm_empty_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_empty_op&#39;&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#955;_. 4&lt;LENGTH(&#39;l)]<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>d</sub> (snat_assn&#39; TYPE(&#39;l))<span class="hidden">&#8679;</span><sup>k</sup> &#8594; hm2_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_empty_op_def</span><span> </span><span>hm_empty_op&#39;_def</span><span> </span><span>hm2_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_with_rdomI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm12_assn &#8801; hrr_comp nat_rel hm2_assn (&#955;_. heapmap_rel)&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm12_assn_fold&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hr_comp (hm2_assn N) heapmap_rel = hm12_assn N&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm12_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm12_assn_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>hm12_assn_fold&#39;</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_empty_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_empty_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>hm_empty_op&#39;_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_insert_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_insert_impl.refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span> </span><span>FCOMP</span><span> </span><span>hm_insert_op_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_is_empty_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_is_empty_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>hm_is_empty_op_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_the_lookup_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_the_lookup_impl_refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>hm_the_lookup_op_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_contains_key_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_contains_key_impl.refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span> </span><span>FCOMP</span><span> </span><span>hm_contains_key_op_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_decrease_key_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_decrease_key_impl.refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span> </span><span>FCOMP</span><span> </span><span>hm_decrease_key_op_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_increase_key_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_increase_key_impl.refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span> </span><span>FCOMP</span><span> </span><span>hm_increase_key_op_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_change_key_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_change_key_impl.refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span> </span><span>FCOMP</span><span> </span><span>hm_change_key_op_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_set_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_set_impl.refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span> </span><span>FCOMP</span><span> </span><span>hm_set_op_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_pop_min_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_pop_min_impl.refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span> </span><span>FCOMP</span><span> </span><span>hm_pop_min_op_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_remove_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_remove_impl.refine</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span> </span><span>FCOMP</span><span> </span><span>hm_remove_op_aref</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_peek_min_ref12</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_peek_min_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>hm_peek_min_op_aref</span><span class="delimiter">]</span><span>
</span><span>            
</span><span>    </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_assn N &#8801; hr_comp (hm12_assn N) (&#10216;nat_rel, Id&#10217;map_rel)&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_assn_fold&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hrr_comp nat_rel hm12_assn (&#955;x. &#10216;nat_rel, Id&#10217;map_rel) = hm_assn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_assn_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_assn_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>hm_assn_fold&#39;</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemmas hm_empty_hnr = hm_empty_ref12[FCOMP mop_hm_empty_fref]*)</span></span></span></span></span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_empty_ref12</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_hm_empty.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="tfree">&#39;l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>parametricity</span><span> </span><span>simp</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ni</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;l word&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Ni_ref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Ni,N)&#8712;snat_rel&#39; TYPE(&#39;l)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_empty_fixed_ref</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry0 (hm_empty_impl Ni), uncurry0 (PR_CONST (mop_hm_empty_fixed N))) &#8712; [&#955;_. 4 &lt; LENGTH(&#39;l)]<span class="hidden">&#8681;</span><sub>a</sub> unit_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; hm12_assn N&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>hfrefD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hm_empty_ref12</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>N</span><span> </span><span>Ni</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ni_ref</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>        </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">,</span><span>no_register</span><span class="delimiter">)</span><span> </span><span>hm_empty_fixed</span><span class="delimiter">:</span><span> </span><span>hm_empty_fixed_ref</span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_hm_empty_fixed.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span class="tfree">&#39;l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>parametricity</span><span> </span><span>simp</span><span>
</span><span>          
</span><span>      </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_insert_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_map_update_new.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_is_empty_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_map_is_empty.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_the_lookup_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_map_the_lookup.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_contains_key_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_map_contains_key.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_decrease_key_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_pm_decrease_key.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_increase_key_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_pm_increase_key.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_change_key_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_map_update_ex.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_set_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_map_update.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_pop_min_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_pm_pop_min.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_remove_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_map_delete_ex.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>ismop</span><span class="delimiter">)</span><span> </span><span>hm_peek_min_ref12</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>mop_pm_peek_min.fref</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>K</span><span class="delimiter">=</span><span>Id</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">=</span><span>Id</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">end</span></span><span>    
</span><span>        
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>      
</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">global_interpretation</span></span><span> 
</span><span>    </span><span>HM</span><span class="delimiter">:</span><span> </span><span>hm_impl</span><span> </span><span>id</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_assn&#39; TYPE(&#39;l)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_assn&#39; TYPE(&#39;l)&quot;</span></span></span><span> </span><span>return</span><span> </span><span>ll_icmp_sle</span><span> </span><span>ll_icmp_slt</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(&#39;l::len2)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">defines</span></span><span> 
</span><span>           </span><span>hm_empty_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_empty_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_append_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_append_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_insert_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_insert_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_length_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_length_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_swim_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_swim_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_sink_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_sink_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_is_empty_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_is_empty_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_the_lookup_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_the_lookup_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_contains_key_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_contains_key_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_decrease_key_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_decrease_key_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_increase_key_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_increase_key_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_change_key_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_change_key_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_parent_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.parent_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_parent_valid_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.parent_valid_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_next_child_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_next_child_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_has_next_child_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_has_next_child_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_left_child_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_left_child_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_has_child_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_has_child_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_repair_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_repair_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_set_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_set_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_pop_min_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_pop_min_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_remove_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_remove_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_peek_min_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_peek_min_impl</span><span>
</span><span>       
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_exch_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_exch_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_update_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_update_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_index_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_index_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_prio_of_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_prio_of_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_val_of_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_val_of_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_key_of_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_key_of_impl</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hm_butlast_impl</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_butlast_impl</span><span>
</span><span>    
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>pure_pure</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;l</span><span> </span><span>heapmap</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;l ial &#215; &#39;l word amt&quot;</span></span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hm_assn&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_assn&#39; TYPE(&#39;l::len2) &#8801; HM.hm_assn :: _ &#8658; _ &#8658; &#39;l heapmap &#8658; _&quot;</span></span></span><span>
</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">schematic_goal</span></span><span> </span><span class="delimiter">[</span><span>sepref_frame_free_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;MK_FREE (HM.hm_assn N) (?fr)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>HM.hm_assn_def</span><span> </span><span>HM.hm12_assn_def</span><span> </span><span>HM.hm2_assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_dbg_side_keep</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span>  </span><span>HM.hm_assn</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_assn_intf</span><span class="delimiter">[</span><span>intf_of_assn</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;intf_of_assn (HM.hm_assn N) (TYPE((nat,nat)i_map))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>llvm_code</span><span class="delimiter">,</span><span>llvm_inline</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>HM.hm_append_impl_def</span><span>
</span><span>    </span><span>HM.hm_is_empty_impl_def</span><span>
</span><span>    </span><span>HM.hm_length_impl_def</span><span>
</span><span>    </span><span>HM.hm_the_lookup_impl_def</span><span>
</span><span>    </span><span>HM.hm_contains_key_impl_def</span><span>
</span><span>    </span><span>HM.parent_impl_def</span><span>
</span><span>    </span><span>HM.parent_valid_impl_def</span><span>
</span><span>    </span><span>HM.hm_prio_of_impl_def</span><span>
</span><span>    </span><span>HM.hm_val_of_impl_def</span><span>
</span><span>    </span><span>HM.hm_key_of_impl_def</span><span>
</span><span>    </span><span>HM.hm_next_child_impl_def</span><span>
</span><span>    </span><span>HM.hm_has_next_child_impl_def</span><span>
</span><span>    </span><span>HM.hm_left_child_impl_def</span><span>
</span><span>    </span><span>HM.hm_has_child_impl_def</span><span>
</span><span>    </span><span>HM.hm_butlast_impl_def</span><span>
</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>llvm_code</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>HM.hm_insert_impl_def</span><span>
</span><span>    </span><span>HM.hm_decrease_key_impl_def</span><span>
</span><span>    </span><span>HM.hm_increase_key_impl_def</span><span>
</span><span>    </span><span>HM.hm_change_key_impl_def</span><span>
</span><span>    </span><span>HM.hm_swim_impl_def</span><span>
</span><span>    </span><span>HM.hm_sink_impl_def</span><span>
</span><span>    </span><span>HM.hm_exch_impl_def</span><span>
</span><span>    </span><span>HM.hm_update_impl_def</span><span>
</span><span>    </span><span>HM.hm_index_impl_def</span><span>
</span><span>    </span><span>HM.hm_repair_impl_def</span><span>
</span><span>    </span><span>HM.hm_set_impl_def</span><span>
</span><span>    </span><span>HM.hm_pop_min_impl_def</span><span>
</span><span>    </span><span>HM.hm_remove_impl_def</span><span>
</span><span>    </span><span>HM.hm_peek_min_impl_def</span><span>
</span><span>    </span><span>HM.hm_empty_impl_def</span><span>
</span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span>HM.hm_prio_of_impl</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>HM.hm_prio_of_impl_def</span><span>
</span><span>    
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">export_llvm</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_empty_impl :: _ &#8658; 32 heapmap llM&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_append_impl:: _ &#8658; 32 word &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_is_empty_impl :: 32 heapmap &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_the_lookup_impl :: _ &#8658; 32 heapmap &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_contains_key_impl :: _ &#8658; 32 heapmap &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_decrease_key_impl :: _ &#8658; _ &#8658; 32 heapmap &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_increase_key_impl :: _ &#8658; _ &#8658; 32 heapmap &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_change_key_impl :: _ &#8658; _ &#8658; 32 heapmap &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_set_impl :: _ &#8658; _ &#8658; 32 heapmap &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_pop_min_impl :: 32 heapmap &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_remove_impl :: _ &#8658; 32 heapmap &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hm_peek_min_impl :: 32 heapmap &#8658; _&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap.ll&quot;</span></span></span><span>
</span><span>    
</span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>N</span><span> </span><span>Ni</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NiREF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Ni,N)&#8712;snat_rel&#39; TYPE(32)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>HM.hm_empty_fixed_hnr_mop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>NiREF</span><span class="delimiter">]</span><span>
</span><span>    
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*notes [sepref_import_param] = NiREF
    notes [[sepref_register_adhoc N]]
    *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snatb (x::nat) &#8801; x&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snatb_hnr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(return,RETURN o snatb) &#8712; [&#955;x. x&lt;N]<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; snatb_assn N&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snatb_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_to_hoare</span><span> </span><span>vcg</span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_test &#8801; do {
      ASSERT (42&lt;N);
      m &#8592; HM.mop_hm_empty_fixed N;
      m &#8592; mop_map_update (snatb 7)  (snatb 3) m;
      m &#8592; mop_map_update (snatb 6)  (snatb 2) m;
      m &#8592; mop_map_update (snatb 16) (snatb 1) m;
      (k,v) &#8592; mop_pm_peek_min id m;
      RETURN k
    }&quot;</span></span></span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>heapmap_test_impl_aux</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uncurry0 heapmap_test&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unit_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> snat_assn&#39; TYPE(32)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_test_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>snatb_hnr</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(32)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>      
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">concrete_definition</span></span><span> </span><span>heapmap_test_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>heapmap_test_impl_aux_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>heapmap_test_impl_def</span><span class="delimiter">[</span><span>llvm_code</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">export_llvm</span></span><span> </span><span>heapmap_test_impl</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(heapmap_test_impl_aux, heapmap_test) &#8712; snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> snat_assn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_preI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>heapmap_test_impl_aux.refine</span><span class="delimiter">[</span><span>to_hnr</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span> </span><span>pred_lift_extract_simps</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>    
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


