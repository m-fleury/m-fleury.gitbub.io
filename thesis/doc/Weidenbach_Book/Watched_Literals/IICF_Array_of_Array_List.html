<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory IICF_Array_of_Array_List (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory IICF_Array_of_Array_List</h1>

<span class="command">theory</span> <span class="name">IICF_Array_of_Array_List</span><br/>
<span class="keyword">imports</span> <a href="IICF_List_List.html"><span class="name">IICF_List_List</span></a> <a href="Array_of_Array_List.html"><span class="name">Array_of_Array_List</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IICF_Array_of_Array_List</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;../Intf/IICF_List_List&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;../../../ds/Array_of_Array_List&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;raw_aal_assn TYPE(&#39;l::len2) TYPE(&#39;ll::len2) 
    &#8801; &#8639;(Array_of_Array_List.aal_assn :: (_,(&#39;l,_,&#39;ll) array_array_list)dr_assn)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>aal_assn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;aal_assn A &#8801; hr_comp (raw_aal_assn TYPE(_) TYPE(_)) (&#10216;&#10216;the_pure A&#10217;list_rel&#10217;list_rel)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>safe_constraint_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>CN_FALSEI</span><span class="delimiter">[</span><span>of</span><span> </span><span>is_pure</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;aal_assn A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>aal_assn&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;aal_assn&#39; TYPE(&#39;l::len2) TYPE(&#39;ll::len2) &#8801; aal_assn :: _ &#8658; _ &#8658; (&#39;l,_,&#39;ll) array_array_list &#8658; _&quot;</span></span></span><span>
</span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>l_dummy</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;l::len2 itself&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ll_dummy</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;ll::len2 itself&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>L</span><span> </span><span>LL</span><span> </span><span>AA</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;L &#8801; (LENGTH (&#39;l))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LL &#8801; (LENGTH (&#39;ll))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AA &#8801; raw_aal_assn TYPE(&#39;l::len2) TYPE(&#39;ll::len2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_unf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hr_comp AA (&#10216;&#10216;the_pure A&#10217;list_rel&#10217;list_rel) = aal_assn A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aal_assn_def</span><span> </span><span>AA_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>params</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(L,L)&#8712;nat_rel&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(LL,LL)&#8712;nat_rel&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(max_snat, max_snat) &#8712; Id &#8594; Id&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>n_unf</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>param</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>params</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    
</span><span>      </span><span class="keyword2"><span class="keyword">private</span></span><span> </span><span class="keyword1"><span class="command">method</span></span><span> </span><span>p_hnr</span><span> </span><span class="delimiter">=</span><span> </span><span>unfold</span><span> </span><span>snat_rel_def</span><span> </span><span>snat.assn_is_rel</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>sepref_to_hoare</span><span class="delimiter">;</span><span> </span><span>vcg</span><span>
</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_push_back_hnr_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry2 aal_push_back, uncurry2 (RETURN ooo op_list_list_push_back)) 
        &#8712; [&#955;((xss,i),x). i &lt; length xss &#8743; length (xss!i) + 1 &lt; max_snat LL]<span class="hidden">&#8681;</span><sub>a</sub> 
            AA<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> id_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; AA&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>p_hnr</span><span>
</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span>aal_push_back_hnr_aux</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>short_circuit_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>parametricity</span><span>
</span><span>                
</span><span>      </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_pop_back_hnr_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry aal_pop_back, uncurry (RETURN oo op_list_list_pop_back)) 
        &#8712; [&#955;(xss,i). i&lt;length xss &#8743; xss!i&#8800;[]]<span class="hidden">&#8681;</span><sub>a</sub> AA<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; id_assn &#215;<span class="hidden">&#8681;</span><sub>a</sub> AA&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>p_hnr</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span>aal_pop_back_hnr_aux</span><span>    
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>short_circuit_conv</span><span> </span><span>conv_to_is_Nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>parametricity</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_idx_hnr_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry2 aal_idx, uncurry2 (RETURN ooo op_list_list_idx)) 
        &#8712; [&#955;((xss,i),j). i&lt;length xss &#8743; j &lt; length (xss!i)]<span class="hidden">&#8681;</span><sub>a</sub> AA<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; id_assn&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>p_hnr</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span>aal_idx_hnr_aux</span><span>         
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>short_circuit_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>parametricity</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_upd_hnr_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry3 aal_upd, uncurry3 (RETURN oooo op_list_list_upd)) 
        &#8712; [&#955;(((xss,i),j),x). i&lt;length xss &#8743; j &lt; length (xss!i)]<span class="hidden">&#8681;</span><sub>a</sub> AA<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> id_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; AA&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>p_hnr</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span>aal_upd_hnr_aux</span><span>         
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>short_circuit_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>parametricity</span><span>
</span><span>        
</span><span>                
</span><span>      </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_llen_hnr_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry aal_llen, uncurry (RETURN oo op_list_list_llen)) 
        &#8712; [&#955;(xss,i). i&lt;length xss]<span class="hidden">&#8681;</span><sub>a</sub> AA<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; snat_assn&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>p_hnr</span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span>aal_llen_hnr_aux</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>                
</span><span>      </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_len_hnr_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(aal_len,RETURN o op_list_list_len) &#8712; AA<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> snat_assn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>p_hnr</span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span>aal_len_hnr_aux</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>                
</span><span>      </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_empty_hnr_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(aal_new_raw, RETURN o op_list_list_lempty) &#8712; [&#955;_. 4&lt;LL]<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; AA&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>p_hnr</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span class="delimiter">(</span><span>no_register</span><span class="delimiter">)</span><span> </span><span>aal_empty</span><span class="delimiter">:</span><span> </span><span>aal_empty_hnr_aux</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_take_hnr_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(uncurry2 aal_take, uncurry2 (RETURN ooo op_list_list_take)) 
        &#8712; [&#955;((xss,i),l). i&lt;length xss &#8743; l &#8804; length (xss!i)]<span class="hidden">&#8681;</span><sub>a</sub> AA<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; AA&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>p_hnr</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">sepref_decl_impl</span></span><span> </span><span>aal_take_hnr_aux</span><span>    
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>short_circuit_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>parametricity</span><span>
</span><span>      
</span><span>    </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>op_aal_lempty</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;op_aal_lempty TYPE(&#39;l::len2) TYPE(&#39;ll::len2) &#8801; op_list_list_lempty&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;op_aal_lempty TYPE(&#39;l::len2) TYPE(&#39;ll::len2)&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_lempty_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(aal_new_raw, RETURN &#8728; (PR_CONST (op_aal_lempty TYPE(&#39;l::len2) TYPE(&#39;ll::len2)))) 
      &#8712; [&#955;x. 4 &lt; LENGTH(&#39;ll)]<span class="hidden">&#8681;</span><sub>a</sub> snat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; aal_assn&#39; TYPE(&#39;l) TYPE(&#39;ll) A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aal_empty_hnr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_fold_custom_empty</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;replicate n [] = op_aal_lempty TYPE(&#39;l::len2) TYPE(&#39;ll::len2) n&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;op_list_list_lempty n = op_aal_lempty TYPE(&#39;l::len2) TYPE(&#39;ll::len2) n&quot;</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;mop_list_list_lempty n = RETURN (op_aal_lempty TYPE(&#39;l::len2) TYPE(&#39;ll::len2) n)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  
</span><span>    
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rdomp_conv_pure_part</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rdomp A a &#10231; (&#8707;c. pure_part (A a c))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rdomp_def</span><span> </span><span>pure_part_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_part_EXS_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pure_part (EXS x. A x) &#10231; (&#8707;x. pure_part (A x))&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_part_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_part_set_imgD</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pure_part (&#8899;*i&#8712;I. f i)&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&#8712;I. pure_part (f i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite I&quot;</span></span></span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite I&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>I</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>pure_part_split_conj</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite I&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pure_part_arl_assnD</span><span class="delimiter">[</span><span>vcg_prep_ext_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pure_part (&#8639;arl_assn xs (a::(_,&#39;l::len2) array_list)) 
    &#10233; length xs &lt; max_snat LENGTH(&#39;l)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>arl_assn_def</span><span> </span><span>arl_assn&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>pure_part_split_conj</span><span> </span><span>snat.vcg_prep_delete_assn</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_assn_boundsD_aux1</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rdomp (aal_assn&#39; TYPE(&#39;l::len2) TYPE(&#39;ll::len2) A) xss&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xss &lt; max_snat LENGTH(&#39;l)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;xs&#8712;set xss. length xs &lt; max_snat LENGTH(&#39;ll)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?G2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*and &quot;&#8704;xs&#8712;set xss. &#8704;x&#8712;set xs. rdomp A x&quot; (is ?G3)*)</span></span></span></span></span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b,&#39;ll) array_list list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>REL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(y, xss) &#8712; &#10216;&#10216;the_pure A&#10217;list_rel&#10217;list_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length x = length y&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>PP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;xa&#8712;{0..&lt;length y}. pure_part (&#8639;arl_assn (y ! xa) (x ! xa))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>LENY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length y &lt; max_snat LENGTH(&#39;l)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> 
</span><span>        </span><span>IICF_Array_of_Array_List.aal_assn_def</span><span>
</span><span>        </span><span>Array_of_Array_List.aal_assn_def</span><span>
</span><span>        </span><span>nao_assn_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rdomp_hrcomp_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>rdomp_conv_pure_part</span><span> </span><span>in_set_conv_nth</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>pure_part_split_conj</span><span> </span><span>pure_part_set_imgD</span><span> </span><span>snat.vcg_prep_delete_assn</span><span class="delimiter">)</span><span> 
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>REL</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xss = length y&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>list_rel_imp_same_length</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>LENY</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xss &lt; max_snat LENGTH(&#39;l)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;xs&#8712;set xss. length xs &lt; max_snat LENGTH(&#39;ll) &#8998;&#8249;&#8743; (&#8704;x&#8712;set xs. rdomp A x)&#8250;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_nth</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ILEN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length y&quot;</span></span></span><span>
</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>REL</span><span> </span><span>ILEN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(y!i,xss!i)&#8712;&#10216;the_pure A&#10217;list_rel&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>parametricity</span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (xss!i) = length (y!i)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>list_rel_imp_same_length</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>PP</span><span> </span><span>ILEN</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pure_part (&#8639;arl_assn (y ! i) (x ! i))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (y!i) &lt; max_snat LENGTH(&#39;ll)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>pure_part_arl_assnD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (xss ! i) &lt; max_snat LENGTH(&#39;ll)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?G2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_assn_boundsD&#39;</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rdomp (aal_assn&#39; TYPE(&#39;l::len2) TYPE(&#39;ll::len2) A) xss&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xss &lt; max_snat LENGTH(&#39;l) 
      &#8743; (&#8704;xs&#8712;set xss. length xs &lt; max_snat LENGTH(&#39;ll))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aal_assn_boundsD_aux1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aal_assn_boundsD</span><span class="delimiter">[</span><span>sepref_bounds_dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rdomp (aal_assn&#39; TYPE(&#39;l::len2) TYPE(&#39;ll::len2) A) xss&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xss &lt; max_snat LENGTH(&#39;l)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aal_assn_boundsD_aux1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Ad-Hoc Regression Tests&#8250;</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">experiment</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>example</span><span> </span><span class="delimiter">[</span><span>llvm_code</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;n. do {
      let l = replicate n [];
      
      let l = op_list_list_push_back l (n-1) 42;
      let l = op_list_list_push_back l (n-1) 43;
      let (x,l) = op_list_list_pop_back l (n-1);
      let l = op_list_list_push_back l (n-1) x;
      let l = op_list_list_take l (n-1) 1;
      
      RETURN l
    }&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#955;n. n&#8712;{1..150}]<span class="hidden">&#8681;</span><sub>a</sub> (snat_assn&#39; TYPE(32))<span class="hidden">&#8679;</span><sup>k</sup> &#8594; aal_assn&#39; TYPE(32) TYPE(32) (snat_assn&#39; TYPE(32))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>aal_fold_custom_empty</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;l</span><span class="delimiter">=</span><span>32</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="tfree">&#39;ll</span><span class="delimiter">=</span><span>32</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_snat_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TYPE(32)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">export_llvm</span></span><span> </span><span>example</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>example</span><span>
</span><span>  
</span><span>    
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span>            
</span><span>        
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


