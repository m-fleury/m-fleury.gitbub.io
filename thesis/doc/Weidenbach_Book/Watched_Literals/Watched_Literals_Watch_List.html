<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Watched_Literals_Watch_List (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Watched_Literals_Watch_List</h1>

<span class="command">theory</span> <span class="name">Watched_Literals_Watch_List</span><br/>
<span class="keyword">imports</span> <a href="Watched_Literals_List.html"><span class="name">Watched_Literals_List</span></a> <a href="Explorer.html"><span class="name">Explorer</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Watched_Literals_Watch_List</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Watched_Literals_List</span><span> </span><span>Weidenbach_Book_Base.Explorer</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Third Refinement: Remembering watched&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Types&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>clauses_to_update_wl</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat multiset&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>watcher</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat &#215; &#39;v literal &#215; bool)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>watched</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v watcher list&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>lit_queue_wl</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal multiset&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>twl_st_wl</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, nat) ann_lits &#215; &#39;v clauses_l &#215;
    &#39;v cconflict &#215; &#39;v clauses &#215; &#39;v clauses &#215; &#39;v lit_queue_wl &#215;
    (&#39;v literal &#8658; &#39;v watched)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Access Functions&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>clauses_to_update_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v literal &#8658; nat &#8658; clauses_to_update_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_wl (_, N, _, _, _, _, W) L i =
      filter_mset (&#955;i. i &#8712;# dom_m N) (mset (drop i (map fst (W L))))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_trail_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; (&#39;v, nat) ann_lit list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_wl (M, _, _, _, _, _, _) = M&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>literals_to_update_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v lit_queue_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update_wl (_, _, _, _, _, Q, _) = Q&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>set_literals_to_update_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v lit_queue_wl &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_literals_to_update_wl Q (M, N, D, NE, UE, _, W) = (M, N, D, NE, UE, Q, W)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_conflict_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v cconflict&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl (_, _, D, _, _, _, _) = D&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_clauses_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v clauses_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_wl (M, N, D, NE, UE, WS, Q) = N&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_unit_learned_clss_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_learned_clss_wl (M, N, D, NE, UE, Q, W) = UE&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_unit_init_clss_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_init_clss_wl (M, N, D, NE, UE, Q, W) = NE&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_unit_clauses_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_wl (M, N, D, NE, UE, Q, W) = NE + UE&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_unit_clauses_wl_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_wl S = get_unit_init_clss_wl S + get_unit_learned_clss_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>get_watched_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; (&#39;v literal &#8658; &#39;v watched)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_watched_wl (_, _, _, _, _, _, W) = W&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_learned_clss_wl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_learned_clss_wl S = learned_clss_lf (get_clauses_wl S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>all_lits_of_mm</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a clauses &#8658; &#39;a literal multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_lits_of_mm Ls = Pos `# (atm_of `# (&#8899;# Ls)) + Neg `# (atm_of `# (&#8899;# Ls))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_lits_of_mm_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_lits_of_mm {#} = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  We cannot just extract the literals of the clauses: we cannot be sure that atoms appear &#8727;&#8249;both&#8250;
  positively and negatively in the clauses. If we could ensure that there are no pure literals, the
  definition of \&lt;^term&gt;&#8249;all_lits_of_mm&#8250; can be changed to &#8249;all_lits_of_mm Ls = &#8899;# Ls&#8250;.

  In this definition \&lt;^term&gt;&#8249;K&#8250; is the blocking literal.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>correctly_marked_as_binary</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary N (i, K, b) &#10231; (b &#10231; (length (N &#8733; i) = 2))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>correctly_marked_as_binary.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>distinct_watched</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v watched &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_watched xs &#8801; distinct (map (&#955;(i, j, k). i) xs)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_watched_alt_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_watched xs = distinct (map fst xs)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>correct_watching_except</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; nat &#8658; &#39;v literal &#8658; &#39;v twl_st_wl &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except i j K (M, N, D, NE, UE, Q, W) &#10231;
    (&#8704;L &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE)).
       (L = K &#10230;
         distinct_watched (take i (W L) @ drop j (W L)) &#8743;
         ((&#8704;(i, K, b)&#8712;#mset (take i (W L) @ drop j (W L)). i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743;
             K &#8800; L &#8743; correctly_marked_as_binary N (i, K, b)) &#8743;
          (&#8704;(i, K, b)&#8712;#mset (take i (W L) @ drop j (W L)). b &#10230; i &#8712;# dom_m N) &#8743;
         filter_mset (&#955;i. i &#8712;# dom_m N) (fst `# mset (take i (W L) @ drop j (W L))) = clause_to_update L (M, N, D, NE, UE, {#}, {#}))) &#8743;
       (L &#8800; K &#10230;
         distinct_watched (W L) &#8743;
         ((&#8704;(i, K, b)&#8712;#mset (W L). i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; L &#8743; correctly_marked_as_binary N (i, K, b)) &#8743;
          (&#8704;(i, K, b)&#8712;#mset (W L). b &#10230; i &#8712;# dom_m N) &#8743;
         filter_mset (&#955;i. i &#8712;# dom_m N) (fst `# mset (W L)) = clause_to_update L (M, N, D, NE, UE, {#}, {#}))))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>correct_watching</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching (M, N, D, NE, UE, Q, W) &#10231;
    (&#8704;L &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE)).
       distinct_watched (W L) &#8743;
       (&#8704;(i, K, b)&#8712;#mset (W L). i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; L &#8743; correctly_marked_as_binary N (i, K, b)) &#8743;
       (&#8704;(i, K, b)&#8712;#mset (W L).  b &#10230; i &#8712;# dom_m N) &#8743;
       filter_mset (&#955;i. i &#8712;# dom_m N) (fst `# mset (W L)) = clause_to_update L (M, N, D, NE, UE, {#}, {#}))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>correct_watching.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_except_correct_watching</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>j</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8805; length (W K)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except i j K (M, N, D, NE, UE, Q, W)&#8250;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching (M, N, D, NE, UE, Q, W(K := take i (W K)))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>H1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L i&#39; K&#39; b. L &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10233;
       (L = K &#10233;
         distinct_watched (take i (W L) @ drop j (W L)) &#8743;
         (((i&#39;, K&#39;, b)&#8712;#mset (take i (W L) @ drop j (W L)) &#10230; i&#39; &#8712;# dom_m N &#10230;
                K&#39; &#8712; set (N &#8733; i&#39;) &#8743; K&#39; &#8800; L &#8743; correctly_marked_as_binary N (i&#39;, K&#39;, b)) &#8743;
         ((i&#39;, K&#39;, b)&#8712;#mset (take i (W L) @ drop j (W L)) &#10230; b &#10230; i&#39; &#8712;# dom_m N) &#8743;
         filter_mset (&#955;i. i &#8712;# dom_m N) (fst `# mset (take i (W L) @ drop j (W L))) =
            clause_to_update L (M, N, D, NE, UE, {#}, {#})))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>H2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L i K&#39; b. L &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10233; (L &#8800; K &#10233;
         distinct_watched (W L) &#8743;
         (((i, K&#39;, b)&#8712;#mset (W L) &#10230; i &#8712;# dom_m N &#10230; K&#39; &#8712; set (N &#8733; i) &#8743; K&#39; &#8800; L &#8743;
             (correctly_marked_as_binary N (i, K&#39;, b))) &#8743;
          ((i, K&#39;, b)&#8712;#mset (W L) &#10230; b &#10230; i &#8712;# dom_m N) &#8743;
         filter_mset (&#955;i. i &#8712;# dom_m N) (fst `# mset (W L)) =
             clause_to_update L (M, N, D, NE, UE, {#}, {#})))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching_except.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>allI</span><span> </span><span>impI</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = K&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H1</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>j</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H2</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>j</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = K&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H1</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst x&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd x)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd x)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>j</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H2</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst x&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd x)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd x)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = K&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H1</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>_</span><span> </span><span>_</span><span class="delimiter">]</span><span> </span><span>j</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H2</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>_</span><span> </span><span>_</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = K&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H1</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>_</span><span> </span><span>_</span><span class="delimiter">]</span><span> </span><span>j</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H2</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>_</span><span> </span><span>_</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>watched_by</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v literal &#8658; &#39;v watched&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by (M, N, D, NE, UE, Q, W) L = W L&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>update_watched</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v watched &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_watched L WL (M, N, D, NE, UE, Q, W) = (M, N, D, NE, UE, Q, W(L:= WL))&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bspec&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; a &#10233; &#8704;x&#8712;a. P x &#10233; P x&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bspec</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_exceptD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except i j L S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm
           (mset `# ran_mf (get_clauses_wl S) + get_unit_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by S L)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &#8805; j&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by S L ! w) &#8712;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd (watched_by S L ! w)) &#8712; set (get_clauses_wl S &#8733; (fst (watched_by S L ! w)))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;x. x&#8712;set (take i (watched_by S L)) &#8746; set (drop j (watched_by S L)) &#10233;
          case x of (i, K, b) &#8658; i &#8712;# dom_m (get_clauses_wl S) &#10230; K &#8712; set (get_clauses_wl S &#8733; i) &#8743;
           K &#8800; L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Un_iff</span><span>
</span><span>       </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>bspec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;i&#8805;j. i &lt; length (watched_by S L) &#8743;
            watched_by S L ! w = watched_by S L ! i&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>w</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>w</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_drop_conv_nth</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>correct_watching_except.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_all_lits_of_mm_ain_atms_of_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm N &#10231; atm_of L &#8712; atms_of_mm N&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_def</span><span> </span><span>atms_of_ms_def</span><span> </span><span>atms_of_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_lits_of_mm_union</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_lits_of_mm (M + N) = all_lits_of_mm M + all_lits_of_mm N&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_lits_of_mm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>all_lits_of_m</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a clause &#8658; &#39;a literal multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_lits_of_m Ls = Pos `# (atm_of `# Ls) + Neg `# (atm_of `# Ls)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_lits_of_m_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_lits_of_m {#} = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_m_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_lits_of_m_empty_iff</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_lits_of_m A = {#} &#10231; A = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_m_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_all_lits_of_m_ain_atms_of_iff</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_m N &#10231; atm_of L &#8712; atms_of N&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_m_def</span><span> </span><span>atms_of_ms_def</span><span> </span><span>atms_of_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_clause_in_all_lits_of_m</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# C &#10233; x &#8712;# all_lits_of_m C&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_of_lit_in_atms_of</span><span> </span><span>in_all_lits_of_m_ain_atms_of_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_lits_of_mm_add_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_lits_of_mm (add_mset C N) = (all_lits_of_m C) + (all_lits_of_mm N)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_def</span><span> </span><span>all_lits_of_m_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_lits_of_m_add_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_lits_of_m (add_mset L C) = add_mset L (add_mset (-L) (all_lits_of_m C))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_m_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_lits_of_m_union</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_lits_of_m (A + B) = all_lits_of_m A + all_lits_of_m B&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_m_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_lits_of_m_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8838;# D&#39; &#10233; all_lits_of_m D &#8838;# all_lits_of_m D&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mset_le_addE</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_m_union</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_all_lits_of_mm_uminusD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2 &#8712;# all_lits_of_mm N &#10233; -x2 &#8712;# all_lits_of_mm N&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_all_lits_of_mm_uminus_iff</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-x2 &#8712;# all_lits_of_mm N &#10231; x2 &#8712;# all_lits_of_mm N&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_lits_of_mm_diffD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (A - B) &#10233; L &#8712;# all_lits_of_mm A&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>A&#39;</span><span> </span><span>B</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8712;# B&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>B</span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_add_mset</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_lits_of_mm_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset A &#8838; set_mset B &#10233; set_mset (all_lits_of_mm A) &#8838; set_mset (all_lits_of_mm B)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>st_l_of_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v literal &#215; nat) option &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;st_l_of_wl None (M, N, D, NE, UE, Q, W) = (M, N, D, NE, UE, {#}, Q)&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;st_l_of_wl (Some (L, j)) (M, N, D, NE, UE, Q, W) =
    (M, N, D, NE, UE, (if D &#8800; None then {#} else clauses_to_update_wl (M, N, D, NE, UE, Q, W) L j,
      Q))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>state_wl_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v literal &#215; nat) option &#8658; (&#39;v twl_st_wl &#215; &#39;v twl_st_l) set&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state_wl_l L = {(T, T&#39;). T&#39; = st_l_of_wl L T}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>twl_st_of_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v literal &#215; nat) option &#8658; (&#39;v twl_st_wl &#215; &#39;v twl_st) set&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_of_wl L = state_wl_l L O twl_st_l (map_option fst L)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>twl_st_wl</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Conversions simp rules&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st_wl</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, T) &#8712; state_wl_l L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_l T = get_trail_wl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_l T = get_clauses_wl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l T = get_conflict_wl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = None &#10233; clauses_to_update_l T = {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; None &#10233; get_conflict_wl S &#8800; None &#10233; clauses_to_update_l T = {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; None &#10233; get_conflict_wl S = None &#10233; clauses_to_update_l T =
       clauses_to_update_wl S (fst (the L)) (snd (the L))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update_l T = literals_to_update_wl S&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_learned_clauses_l T = get_unit_learned_clss_wl S&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_init_clauses_l T = get_unit_init_clss_wl S&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_learned_clauses_l T = get_unit_learned_clss_wl S&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_l T = get_unit_clauses_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>state_wl_l_def</span><span> </span><span>all_clss_lf_ran_m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>L</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st_l</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(a, a&#39;) &#8712; state_wl_l None &#10233;
        get_learned_clss_l a&#39; = get_learned_clss_wl a&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>state_wl_l_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>a&#39;</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_learned_clss_l_def</span><span> </span><span>get_learned_clss_wl_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_one_lit_from_wq_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_one_lit_from_wq L S = set_clauses_to_update_l (clauses_to_update_l S - {#L#}) S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_set_literals_to_update</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching (set_literals_to_update_wl WS T&#39;) = correct_watching T&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st_wl</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_wl (set_literals_to_update_wl W S) = get_clauses_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_init_clss_wl (set_literals_to_update_wl W S) = get_unit_init_clss_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_conflict_wl_set_literals_to_update_wl</span><span class="delimiter">[</span><span>twl_st_wl</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl (set_literals_to_update_wl P S) = get_conflict_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_wl (set_literals_to_update_wl P S) = get_unit_clauses_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>set_conflict_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause_l &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_conflict_wl = (&#955;C (M, N, D, NE, UE, Q, W). (M, N, Some (mset C), NE, UE, {#}, W))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st_wl</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_wl (set_conflict_wl D S) = get_clauses_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_conflict_wl_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st_wl</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_init_clss_wl (set_conflict_wl D S) = get_unit_init_clss_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_wl (set_conflict_wl D S) = get_unit_clauses_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_conflict_wl_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>state_wl_l_mark_of_is_decided</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, y) &#8712; state_wl_l b &#10233;
       get_trail_wl x &#8800; [] &#10233;
       is_decided (hd (get_trail_l y)) = is_decided (hd (get_trail_wl x))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_wl x&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_l y&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hd (get_trail_wl x)&#8250;</span></span></span><span class="delimiter">;</span><span>
</span><span>     </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hd (get_trail_l y)&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>convert_lit.simps</span><span> </span><span>st_l_of_wl.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>state_wl_l_mark_of_is_proped</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, y) &#8712; state_wl_l b &#10233;
       get_trail_wl x &#8800; [] &#10233;
       is_proped (hd (get_trail_l y)) = is_proped (hd (get_trail_wl x))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_wl x&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_l y&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hd (get_trail_wl x)&#8250;</span></span></span><span class="delimiter">;</span><span>
</span><span>     </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hd (get_trail_l y)&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>convert_lit.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We here also update the list of watched clauses \&lt;^term&gt;&#8249;WL&#8250;.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>twl_st_wl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_prop_body_wl_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv T j i L &#10231; (i &lt; length (watched_by T L) &#8743; j &#8804; i &#8743;
   (fst (watched_by T L ! i) &#8712;# dom_m (get_clauses_wl T) &#10230;
    (&#8707;T&#39;. (T, T&#39;) &#8712; state_wl_l (Some (L, i)) &#8743; j &#8804; i &#8743;
    unit_propagation_inner_loop_body_l_inv L (fst (watched_by T L ! i))
       (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;)&#8743;
    L &#8712;# all_lits_of_mm (mset `# init_clss_lf (get_clauses_wl T) + get_unit_clauses_wl T) &#8743;
     correct_watching_except j i L T)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unit_prop_body_wl_inv_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv T j i L &#10231; (i &lt; length (watched_by T L) &#8743; j &#8804; i &#8743;
   (fst (watched_by T L ! i) &#8712;# dom_m (get_clauses_wl T) &#10230;
    (&#8707;T&#39;. (T, T&#39;) &#8712; state_wl_l (Some (L, i)) &#8743;
    unit_propagation_inner_loop_body_l_inv L (fst (watched_by T L ! i))
       (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;)&#8743;
    L &#8712;# all_lits_of_mm (mset `# init_clss_lf (get_clauses_wl T) + get_unit_clauses_wl T) &#8743;
     correct_watching_except j i L T &#8743;
    get_conflict_wl T = None &#8743;
    length (get_clauses_wl T &#8733; fst (watched_by T L ! i)) &#8805; 2)))&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A = ?B&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?B</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?A</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?B</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by T L ! i) &#8712;# dom_m (get_clauses_wl T)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?B</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; length (watched_by T L)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; i&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>TT&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, T&#39;) &#8712; state_wl_l (Some (L, i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L (fst (watched_by T L ! i))
       (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# init_clss_lf (get_clauses_wl T) + get_unit_clauses_wl T)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j i L T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_clauses_to_update_l
         (clauses_to_update_l
           (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;) +
          {#fst (watched_by T L ! i)#})
         (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;),
        x)
       &#8712; twl_st_l (Some L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs x&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs x&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by T L ! i)
       &#8712;# dom_m
            (get_clauses_l
              (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; fst (watched_by T L ! i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; length
            (get_clauses_l
              (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;) &#8733;
             fst (watched_by T L ! i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup
        (get_trail_l
          (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(if get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;) &#8733;
           fst (watched_by T L ! i) !
           0 =
           L
        then 0 else 1)
       &lt; length
          (get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;) &#8733;
           fst (watched_by T L ! i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;1 -
       (if get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;) &#8733;
           fst (watched_by T L ! i) !
           0 =
           L
        then 0 else 1)
       &lt; length
          (get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;) &#8733;
           fst (watched_by T L ! i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set (watched_l
                  (get_clauses_l
                    (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;) &#8733;
                   fst (watched_by T L ! i)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l (remove_one_lit_from_wq (fst (watched_by T L ! i)) T&#39;) = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball (get_clauses x) struct_wf_twl_cls&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>twl_st_inv_alt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_clause_of (get_clauses_wl T &#8733; fst (watched_by T L ! i)) &#8712;# get_clauses x&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TT&#39;</span><span> </span><span>x</span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (get_clauses_wl T &#8733; fst (watched_by T L ! i)) &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl T = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span>TT&#39;</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?B</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A&#8250;</span></span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>propagate_lit_wl_general</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; nat &#8658; nat &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_lit_wl_general = (&#955;L&#39; C i (M, N,  D, NE, UE, Q, W).
      let N = (if length (N &#8733; C) &gt; 2 then N(C &#8618; swap (N &#8733; C) 0 (Suc 0 - i)) else N) in
      (Propagated L&#39; C # M, N, D, NE, UE, add_mset (-L&#39;) Q, W))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>propagate_lit_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; nat &#8658; nat &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_lit_wl = (&#955;L&#39; C i (M, N,  D, NE, UE, Q, W).
      let N = N(C &#8618; swap (N &#8733; C) 0 (Suc 0 - i)) in
      (Propagated L&#39; C # M, N, D, NE, UE, add_mset (-L&#39;) Q, W))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>propagate_lit_wl_bin</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; nat &#8658; nat &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_lit_wl_bin = (&#955;L&#39; C i (M, N,  D, NE, UE, Q, W).
      (Propagated L&#39; C # M, N, D, NE, UE, add_mset (-L&#39;) Q, W))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>keep_watch</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;keep_watch = (&#955;L i j (M, N,  D, NE, UE, Q, W).
      (M, N,  D, NE, UE, Q, W(L := (W L)[i := W L ! j])))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_watched_by_keep_watch</span><span class="delimiter">[</span><span>twl_st_wl</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (watched_by (keep_watch L i j S) K) = length (watched_by S K)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>watched_by_keep_watch_neq</span><span class="delimiter">[</span><span>twl_st_wl</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by S L) &#10233; watched_by (keep_watch L j w S) L ! w = watched_by S L ! w&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>watched_by_keep_watch_eq</span><span class="delimiter">[</span><span>twl_st_wl</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &lt; length (watched_by S L) &#10233; watched_by (keep_watch L j w S) L ! j = watched_by S L ! w&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update_clause_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; nat &#8658; bool &#8658; nat &#8658; nat &#8658; nat &#8658; nat &#8658; &#39;v twl_st_wl &#8658;
    (nat &#215; nat &#215; &#39;v twl_st_wl) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clause_wl = (&#955;(L::&#39;v literal) C b j w i f (M, N,  D, NE, UE, Q, W). do {
     let K&#39; = (N&#8733;C) ! f;
     let N&#39; = N(C &#8618; swap (N &#8733; C) i f);
     RETURN (j, w+1, (M, N&#39;, D, NE, UE, Q, W(K&#39; := W K&#39; @ [(C, L, b)])))
  })&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update_blit_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; nat &#8658; bool &#8658; nat &#8658; nat &#8658; &#39;v literal &#8658; &#39;v twl_st_wl &#8658;
    (nat &#215; nat &#215; &#39;v twl_st_wl) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_blit_wl = (&#955;(L::&#39;v literal) C b j w K (M, N,  D, NE, UE, Q, W). do {
     RETURN (j+1, w+1, (M, N, D, NE, UE, Q, W(L := (W L)[j:=(C, K, b)])))
  })&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_prop_body_wl_find_unwatched_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_find_unwatched_inv f C S &#10231;
   get_clauses_wl S &#8733; C &#8800; [] &#8743;
   (f = None &#10231; (&#8704;L&#8712;#mset (unwatched_l (get_clauses_wl S &#8733; C)). - L &#8712; lits_of_l (get_trail_wl S)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>remaining_nondom_wl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remaining_nondom_wl w L S &#8801;
  (if get_conflict_wl S = None
          then size (filter_mset (&#955;(i, _). i &#8713;# dom_m (get_clauses_wl S)) (mset (drop w (watched_by S L)))) else 0)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_inv L = (&#955;(j, w, S).
    (&#8707;S&#39;. (S, S&#39;) &#8712; state_wl_l (Some (L, w)) &#8743; j&#8804; w &#8743;
       unit_propagation_inner_loop_l_inv L (S&#39;, remaining_nondom_wl w L S) &#8743;
      correct_watching_except j w L S &#8743; w &#8804; length (watched_by S L)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_except_correct_watching_except_Suc_Suc_keep_watch</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>j_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by S L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except (Suc j) (Suc w) L (keep_watch L j w S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>D</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, D, NE, UE, Q, W)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>Hneq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La. La&#8712;#all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10230;
        (La &#8800; L &#10230;
	  distinct_watched (W La) &#8743;
         (&#8704;(i, K, b)&#8712;#mset (W La). i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743;
             correctly_marked_as_binary N (i, K, b)) &#8743;
         (&#8704;(i, K, b)&#8712;#mset (W La). b &#10230; i &#8712;# dom_m N) &#8743;
         {#i &#8712;# fst `# mset (W La). i &#8712;# dom_m N#} = clause_to_update La (M, N, D, NE, UE, {#}, {#}))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>Heq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La. La&#8712;#all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10230;
        (La = L &#10230;
	 distinct_watched (take j (W La) @ drop w (W La)) &#8743;
         (&#8704;(i, K, b)&#8712;#mset (take j (W La) @ drop w (W La)). i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743;
            K &#8800; La &#8743; correctly_marked_as_binary N (i, K, b)) &#8743;
         (&#8704;(i, K, b)&#8712;#mset (take j (W La) @ drop w (W La)). b &#10230; i &#8712;# dom_m N) &#8743;
         {#i &#8712;# fst `# mset (take j (W La) @ drop w (W La)). i &#8712;# dom_m N#} =
         clause_to_update La (M, N, D, NE, UE, {#}, {#}))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>correct_watching_except.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset (take (Suc j) ((W(L := (W L)[j := W L ! w])) La) @ drop (Suc w) ((W(L := (W L)[j := W L ! w])) La)) =
     mset (take j (W La) @ drop w (W La))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_le</span><span> </span><span>j_w</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>list_update_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case x of (i, K, b) &#8658; i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743;
           correctly_marked_as_binary N (i, K, b)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# mset (take (Suc j) ((W(L := (W L)[j := W L ! w])) La) @
                 drop (Suc w) ((W(L := (W L)[j := W L ! w])) La))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#215; &#39;a literal &#215; bool&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case x of (i, K, b) &#8658; b &#10230; i &#8712;# dom_m N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# mset (take (Suc j) ((W(L := (W L)[j := W L ! w])) La) @
                 drop (Suc w) ((W(L := (W L)[j := W L ! w])) La))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#215; &#39;a literal &#215; bool&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>eq</span><span class="delimiter">)</span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#i &#8712;# fst `#
              mset
               (take (Suc j) ((W(L := (W L)[j := W L ! w])) La) @
                drop (Suc w) ((W(L := (W L)[j := W L ! w])) La)).
       i &#8712;# dom_m N#} =
      clause_to_update La (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case x of (i, K, b) &#8658; i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743;
        correctly_marked_as_binary N (i, K, b)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8800; L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# mset ((W(L := (W L)[j := W L ! w])) La)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#215; &#39;a literal &#215; bool&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case x of (i, K, b) &#8658; b &#10230; i &#8712;# dom_m N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8800; L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# mset ((W(L := (W L)[j := W L ! w])) La)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#215; &#39;a literal &#215; bool&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#i &#8712;# fst `# mset ((W(L := (W L)[j := W L ! w])) La). i &#8712;# dom_m N#} =
      clause_to_update La (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8800; L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_watched ((W(L := (W L)[j := W L ! w])) La)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8800; L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_watched (take (Suc j) ((W(L := (W L)[j := W L ! w])) La) @
                drop (Suc w) ((W(L := (W L)[j := W L ! w])) La))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_mset_mset_distinct</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>mset_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>mset_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_mset_mset_distinct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>keep_watch_def</span><span> </span><span>prod.simps</span><span> </span><span>correct_watching_except.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_except_update_blit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except i j L (a, b, c, d, e, f, g(L := (g L)[j&#39; := (x1, C, b&#39;)]))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>C&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8712;# all_lits_of_mm (mset `# ran_mf b + (d + e))&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8712; set (b &#8733; x1)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8800; L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>corr_watched</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary b (x1, C&#39;, b&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except i j L (a, b, c, d, e, f, g(L := (g L)[j&#39; := (x1, C&#39;, b&#39;)]))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>Hdisteq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La i&#39; K&#39; b&#39;&#39;. La&#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233;
        (La = L &#10230;
	 distinct_watched (take i ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La) @ drop j ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>Heq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La i&#39; K&#39; b&#39;&#39;. La&#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233;
        (La = L &#10230;
         (((i&#39;, K&#39;, b&#39;&#39;)&#8712;#mset (take i ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La) @ drop j ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La)) &#10230;
             i&#39; &#8712;# dom_m b &#10230; K&#39; &#8712; set (b &#8733; i&#39;) &#8743; K&#39; &#8800; La &#8743; correctly_marked_as_binary b (i&#39;, K&#39;, b&#39;&#39;)) &#8743;
          ((i&#39;, K&#39;, b&#39;&#39;)&#8712;#mset (take i ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La) @ drop j ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La)) &#10230;
              b&#39;&#39; &#10230; i&#39; &#8712;# dom_m b)) &#8743;
         {#i &#8712;# fst `# mset (take i ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La) @ drop j ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La)).
          i &#8712;# dom_m b#} =
         clause_to_update La (a, b, c, d, e, {#}, {#}))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>Hdistneq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La i&#39; K&#39; b&#39;&#39;. La&#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233;
        (La &#8800; L &#10230; distinct_watched (((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>Hneq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La i K b&#39;&#39;. La&#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233; La &#8800; L &#10233;
         distinct_watched (((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La)) &#8743;
         ((i, K, b&#39;&#39;)&#8712;#mset ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La)&#10230; i &#8712;# dom_m b &#10230;
            K &#8712; set (b &#8733; i) &#8743; K &#8800; La &#8743; correctly_marked_as_binary b (i, K, b&#39;&#39;)) &#8743;
         ((i, K, b&#39;&#39;)&#8712;#mset ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La)&#10230; b&#39;&#39; &#10230; i &#8712;# dom_m b) &#8743;
         {#i &#8712;# fst `# mset ((g(L := (g L)[j&#39; := (x1, C, b&#39;)])) La). i &#8712;# dom_m b#} =
            clause_to_update La (a, b, c, d, e, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching_except.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;g&#39; = g(L := (g L)[j&#39; := (x1, C, b&#39;)])&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g_g&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;g(L := (g L)[j&#39; := (x1, C&#39;, b&#39;)]) = g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst `# mset ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La) = fst `# mset (g&#39; La)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>mset_map</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_update</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst `#
                 mset
                  (take i ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La) @
                   drop j ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La)) =
      fst `#
                 mset
                  (take i (g&#39; La) @
                   drop j (g&#39; La))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>mset_map</span><span> </span><span>drop_map</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_update</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst `# mset ((take i (g&#39; L))[j&#39; := (x1, C&#39;, b&#39;)]) = fst `# mset (take i (g&#39; L))&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst `# mset ((drop j ((g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)]))) = fst `# mset (drop j (g&#39; L))&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;j&#39; &lt; j &#10233; fst `# mset ((drop j (g&#39; L))[j&#39; - j := (x1, C&#39;, b&#39;)]) = fst `# mset (drop j (g&#39; L))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g&#39;_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>mset_map</span><span> </span><span>drop_map</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_update</span><span> </span><span>drop_update_swap</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>mset_map</span><span> </span><span>drop_map</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_update</span><span> </span><span>drop_update_swap</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>mset_map</span><span> </span><span>drop_map</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_update</span><span> </span><span>drop_update_swap</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#39; &lt; length (g&#39; L) &#10233; j&#39; &lt; i &#10233; (x1, C, b&#39;) &#8712; set ((take i (g L))[j&#39; := (x1, C, b&#39;)])&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_mem</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(take i (g L))[j&#39; := (x1, C, b&#39;)]&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233; j&#39; &lt; length (g&#39; L) &#10233;
       j&#39; &lt; i &#10233; b&#39; &#10233; x1 &#8712;# dom_m b&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C&#39;</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>x1</span><span> </span><span>C</span><span> </span><span>b&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#39; &lt; j&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; j&#39; &lt; j &#10233; j&#39; - j &lt; length (g&#39; L) - j &#10233;
     (x1, C, b&#39;) &#8712; set (drop j ((g L)[j&#39; := (x1, C, b&#39;)]))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_mem</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#39;-j&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop j ((g L)[j&#39; := (x1, C, b&#39;)])&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233; &#172; j&#39; &lt; j &#10233;
       j&#39; - j &lt; length (g&#39; L) - j &#10233; b&#39; &#10233; x1 &#8712;# dom_m b&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C&#39;</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>x1</span><span> </span><span>C</span><span> </span><span>b&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#39; &lt; j&#8250;</span></span></span><span class="delimiter">)</span><span>  </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La&#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233;
        La = L &#10233;
	 distinct_watched (take i ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La) @ drop j ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hdisteq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_g&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#39; &lt; j&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_update</span><span> </span><span>drop_update_swap</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La&#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233;
        La = L &#10233;
	 distinct_watched (take i ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La) @ drop j ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La)) &#8743;
         ((i&#39;, K, b&#39;&#39;)&#8712;#mset (take i ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La) @ drop j ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La)) &#10230;
             i&#39; &#8712;# dom_m b &#10230; K &#8712; set (b &#8733; i&#39;) &#8743; K &#8800; La &#8743; correctly_marked_as_binary b (i&#39;, K, b&#39;&#39;)) &#8743;
          ((i&#39;, K, b&#39;&#39;)&#8712;#mset (take i ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La) @ drop j ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La)) &#10230;
            b&#39;&#39; &#10230; i&#39; &#8712;# dom_m b) &#8743;
         {#i &#8712;# fst `# mset (take i ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La) @ drop j ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La)).
          i &#8712;# dom_m b#} =
         clause_to_update La (a, b, c, d, e, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span>i&#39;</span><span> </span><span>K</span><span> </span><span>b&#39;&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C&#39;</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span>i&#39;</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span>i&#39;</span><span> </span><span>K</span><span> </span><span>b&#39;</span><span class="delimiter">]</span><span> </span><span>H</span><span> </span><span>H&#39;</span><span> </span><span>dist</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span> </span><span>corr_watched</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_g&#39;</span><span> </span><span>g&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j&#39; &lt; j&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_set_upd_cases</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>drop_update_swap</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>distinct_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La&#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233;
       (La &#8800; L &#10230;
        distinct_watched ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La) &#8743;
        (&#8704;(i, K, ba)&#8712;#mset ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La).
            i &#8712;# dom_m b &#10230;
            K &#8712; set (b &#8733; i) &#8743;
            K &#8800; La &#8743; correctly_marked_as_binary b (i, K, ba)) &#8743;
        (&#8704;(i, K, ba)&#8712;#mset ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La).
            ba &#10230; i &#8712;# dom_m b) &#8743;
        {#i &#8712;# fst `# mset ((g&#39;(L := (g&#39; L)[j&#39; := (x1, C&#39;, b&#39;)])) La).
         i &#8712;# dom_m b#} =
        clause_to_update La (a, b, c, d, e, {#}, {#}))&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq</span><span> </span><span>Hdistneq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching_except.simps</span><span> </span><span>g_g&#39;</span><span>  </span><span>g&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching_except.simps</span><span> </span><span>g_g&#39;</span><span>  </span><span>g&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>H2</span><span> </span><span>H3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_except_correct_watching_except_Suc_notin</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by S L ! w) &#8713;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>j_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by S L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j (Suc w) L (keep_watch L j w S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>D</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, D, NE, UE, Q, W)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (W L ! w) &#8713;# dom_m N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>Hneq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La. La&#8712;#all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10230;
        (La &#8800; L &#10230;
	 distinct_watched (W La) &#8743;
         ((&#8704;(i, K, b)&#8712;#mset (W La). i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743;
             correctly_marked_as_binary N (i, K, b)) &#8743;
          (&#8704;(i, K, b)&#8712;#mset (W La). b &#10230; i &#8712;# dom_m N)) &#8743;
          {#i &#8712;# fst `# mset (W La). i &#8712;# dom_m N#} = clause_to_update La (M, N, D, NE, UE, {#}, {#}))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>Heq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La. La&#8712;#all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10230;
        (La = L &#10230;
	 distinct_watched (take j (W La) @ drop w (W La)) &#8743;
         ((&#8704;(i, K, b)&#8712;#mset (take j (W La) @ drop w (W La)). i &#8712;# dom_m N &#10230;
              K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743; correctly_marked_as_binary N (i, K, b)) &#8743;
          (&#8704;(i, K, b)&#8712;#mset (take j (W La) @ drop w (W La)). b &#10230; i &#8712;# dom_m N) &#8743;
         {#i &#8712;# fst `# mset (take j (W La) @ drop w (W La)). i &#8712;# dom_m N#} =
         clause_to_update La (M, N, D, NE, UE, {#}, {#})))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>correct_watching_except.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset (take j ((W(L := (W L)[j := W L ! w])) La) @ drop (Suc w) ((W(L := (W L)[j := W L ! w])) La)) =
    remove1_mset (W L ! w) (mset (take j (W La) @ drop w (W La)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_le</span><span> </span><span>j_w</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>list_update_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case x of (i, K, b) &#8658; i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743;
       correctly_marked_as_binary N (i, K, b)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# mset (take j ((W(L := (W L)[j := W L ! w])) La) @
                 drop (Suc w) ((W(L := (W L)[j := W L ! w])) La))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#215; &#39;a literal &#215; bool&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>eq</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case x of (i, K, b) &#8658; b &#10230; i &#8712;# dom_m N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# mset (take j ((W(L := (W L)[j := W L ! w])) La) @
                 drop (Suc w) ((W(L := (W L)[j := W L ! w])) La))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#215; &#39;a literal &#215; bool&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>eq</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#i &#8712;# fst `#
              mset
               (take j ((W(L := (W L)[j := W L ! w])) La) @
                drop (Suc w) ((W(L := (W L)[j := W L ! w])) La)).
       i &#8712;# dom_m N#} =
      clause_to_update La (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_mset_remove1_mset_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case x of (i, K, b) &#8658; i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743;
      correctly_marked_as_binary N (i, K, b)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8800; L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# mset ((W(L := (W L)[j := W L ! w])) La)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#215; &#39;a literal &#215; bool&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case x of (i, K, b) &#8658; b &#10230; i &#8712;# dom_m N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8800; L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# mset ((W(L := (W L)[j := W L ! w])) La)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#215; &#39;a literal &#215; bool&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#i &#8712;# fst `# mset ((W(L := (W L)[j := W L ! w])) La). i &#8712;# dom_m N#} =
      clause_to_update La (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8800; L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_watched ((W(L := (W L)[j := W L ! w])) La)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8800; L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_watched (take j ((W(L := (W L)[j := W L ! w])) La) @
                drop (Suc w) ((W(L := (W L)[j := W L ! w])) La))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_mset_mset_distinct</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>mset_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>solves</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>distinct_mset_mset_distinct</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>mset_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>distinct_mset_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#i. (i, j, k) &#8712;# mset (take j (W L) @ drop w (W L))#}&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_mset_remove1_mset_if</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>keep_watch_def</span><span> </span><span>prod.simps</span><span> </span><span>correct_watching_except.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_except_correct_watching_except_update_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except (Suc j) (Suc w) L
       (M, N, D, NE, UE, Q, W(L := (W L)[j := W L ! w]))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>j_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (W L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE))&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712; set (N &#8733; x1)&#8250;</span></span></span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; N &#8733; x1 ! xa&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 &#8712;# dom_m N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i_xa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; length (N &#8733; x1)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &lt; length (N &#8733; x1)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W L ! w = (x1, x2, b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>N_i</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! i = L&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! (1 -i) &#8800; L&#8250;</span></span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! xa &#8800; L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>N_xa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! xa &#8800; N &#8733; x1 ! i&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! xa &#8800; N &#8733; x1 ! (Suc 0 - i)&#8250;</span></span></span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i_2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; 2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &#8805; 2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L_neq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8800; N &#8733; x1 ! xa&#8250;</span></span></span><span> </span><span class="comment">&#8213;&#8249;The new blocking literal is not the new watched literal.&#8250;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j (Suc w) L
          (M, N(x1 &#8618; swap (N &#8733; x1) i xa), D, NE, UE, Q, W
           (L := (W L)[j := (x1, x2, b)],
            N &#8733; x1 ! xa := W (N &#8733; x1 ! xa) @ [(x1, L&#39;, b)]))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>W&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W&#39; &#8801; W(L := (W L)[j := W L ! w])&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (N &#8733; x1) &gt; 2&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_2</span><span> </span><span>i_xa</span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correctly_marked_as_binary.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>Heq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La i K b. La&#8712;#all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10233;
          La = L &#10233;
	   distinct_watched (take (Suc j) (W&#39; La) @ drop (Suc w) (W&#39; La)) &#8743;
           ((i, K, b)&#8712;#mset (take (Suc j) (W&#39; La) @ drop (Suc w) (W&#39; La)) &#10230;
               i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743; correctly_marked_as_binary N (i, K, b)) &#8743;
           ((i, K, b)&#8712;#mset (take (Suc j) (W&#39; La) @ drop (Suc w) (W&#39; La)) &#10230;
               b &#10230; i &#8712;# dom_m N) &#8743;
           {#i &#8712;# fst `#
                   mset
                    (take (Suc j) (W&#39; La) @ drop (Suc w) (W&#39; La)).
            i &#8712;# dom_m N#} =
           clause_to_update La (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>Hneq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La i K b. La&#8712;#all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10233;
          La &#8800; L &#10233;
	   distinct_watched (W&#39; La) &#8743;
           ((i, K, b)&#8712;#mset (W&#39; La) &#10230; i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743;
               correctly_marked_as_binary N (i, K, b)) &#8743;
           ((i, K, b)&#8712;#mset (W&#39; La) &#10230; b &#10230; i &#8712;# dom_m N) &#8743;
           {#i &#8712;# fst `# mset (W&#39; La). i &#8712;# dom_m N#} =
           clause_to_update La (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>Hneq2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La. La&#8712;#all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10233;
          (La &#8800; L &#10230;
	   distinct_watched (W&#39; La) &#8743;
           {#i &#8712;# fst `# mset (W&#39; La). i &#8712;# dom_m N#} =
           clause_to_update La (M, N, D, NE, UE, {#}, {#}))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching_except.simps</span><span> </span><span>W&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset `# ran_mf (N(x1 &#8618; swap (N &#8733; x1) i xa)) = mset `# ran_mf N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span>i_xa</span><span> </span><span>distinct_mset_dom</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_m_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>image_mset_cong2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>W_W&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W
      (L := (W L)[j := (x1, x2, b)], N &#8733; x1 ! xa := W (N &#8733; x1 ! xa) @ [(x1, L&#39;, b)]) =
     W&#39;(N &#8733; x1 ! xa := W (N &#8733; x1 ! xa) @ [(x1, L&#39;, b)])&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>W&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>W_W2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;W (N &#8733; x1 ! xa) = W&#39; (N &#8733; x1 ! xa)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>W&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (swap (N &#8733; x1) i xa) =  set (N &#8733; x1)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_xa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (fst (the (if x1 = ia then Some (swap (N &#8733; x1) i xa, irred N x1) else fmlookup N ia))) =
     set (fst (the (fmlookup N ia)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ia</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = x1 &#8744; i &#8712;# remove1_mset x1 (dom_m N) &#10231; i &#8712;# dom_m N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set_N_swap_x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (watched_l (swap (N &#8733; x1) i xa)) = {N &#8733; x1 ! (1 -i), N &#8733; x1 ! xa}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_2</span><span> </span><span>i_xa</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &#8805; 2&#8250;</span></span></span><span> </span><span>N_i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl (N &#8733; x1)&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i-1&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swap_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>nat.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>set_N_x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (watched_l (N &#8733; x1)) = {N &#8733; x1 ! (1 -i), N &#8733; x1 ! i}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_2</span><span> </span><span>i_xa</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &#8805; 2&#8250;</span></span></span><span> </span><span>N_i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swap_def</span><span> </span><span>take_2_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>La_in_notin_swap</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712; set (watched_l (N &#8733; x1)) &#10233;
       La &#8713; set (watched_l (swap (N &#8733; x1) i xa)) &#10233; La = L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_2</span><span> </span><span>i_xa</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &#8805; 2&#8250;</span></span></span><span> </span><span>N_i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_N_x1</span><span> </span><span>set_N_swap_x1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_notin_swap</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; set (watched_l (swap (N &#8733; x1) i xa))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_2</span><span> </span><span>i_xa</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &#8805; 2&#8250;</span></span></span><span> </span><span>N_i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_N_x1</span><span> </span><span>set_N_swap_x1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N_xa_in_swap</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! xa &#8712; set (watched_l (swap (N &#8733; x1) i xa))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_2</span><span> </span><span>i_xa</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &#8805; 2&#8250;</span></span></span><span> </span><span>N_i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_N_x1</span><span> </span><span>set_N_swap_x1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H4</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(i = x1 &#10230; K &#8712; set (N &#8733; x1) &#8743; K &#8800; La) &#8743; (i &#8712;# remove1_mset x1 (dom_m N) &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La) &#10231;
   (i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span>P</span><span> </span><span>K</span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 &#8713;# Ab &#10233;
       {#C &#8712;# Ab.
        (x1 = C &#10230; Q C) &#8743;
        (x1 &#8800; C &#10230; R C)#} =
     {#C &#8712;# Ab. R C#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Ab</span><span> </span><span>Q</span><span> </span><span>R</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>filter_mset_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bin</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary N (x1, x2, b)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (W L ! w)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd (W L ! w ))&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd (W L ! w))&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>dom</span><span> </span><span>L&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>W&#39;_def</span><span> </span><span>list_update_append</span><span> </span><span>L_L</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x1_new</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 &#8713; fst ` set (W (N &#8733; x1 ! xa))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; ?thesis&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! xa
        &#8712;# all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span>in_clause_in_all_lits_of_m</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! xa&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset (N &#8733; x1)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>i_xa</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_union</span><span> </span><span>ran_m_def</span><span> </span><span>all_lits_of_mm_add_mset</span><span>
</span><span>	  </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#i &#8712;# fst `# mset (W (N &#8733; x1 ! xa)). i &#8712;# dom_m N#} =
        clause_to_update (N &#8733; x1 ! xa) (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! xa&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>W&#39;_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 &#8712;# clause_to_update (N &#8733; x1 ! xa) (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>mem_Collect_eq</span><span> </span><span>set_image_mset</span><span>
</span><span>        </span><span>set_mset_filter</span><span> </span><span>set_mset_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_xa</span><span> </span><span>i_2</span><span> </span><span>i_xa</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! xa&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clause_to_update_def</span><span> </span><span>take_2_if</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?N</span><span> </span><span class="delimiter">=</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N(x1 &#8618; swap (N &#8733; x1) i xa)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE)) &#10233; La = L &#10233;
       x &#8712; set (take j (W L)) &#8744; x &#8712; set (drop (Suc w) (W L)) &#10233;
       case x of (i, K, b) &#8658; i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; L &#8743;
           correctly_marked_as_binary ?N (i, K, b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst x&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd x)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd x)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>W&#39;_def</span><span> </span><span>list_update_append</span><span> </span><span>correctly_marked_as_binary.simps</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE)) &#10233; La = L &#10233;
       x &#8712; set (take j (W L)) &#8744; x &#8712; set (drop (Suc w) (W L)) &#10233;
       case x of (i, K, b) &#8658;b &#10230; i &#8712;# dom_m N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst x&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd x)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd x)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>W&#39;_def</span><span> </span><span>list_update_append</span><span> </span><span>correctly_marked_as_binary.simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE)) &#10233;
          La = L &#10233;
	  distinct_watched (take j (W L) @ drop (Suc w) (W L)) &#8743;
          {#i &#8712;# fst `# mset (take j (W L)). i &#8712;# dom_m N#} + {#i &#8712;# fst `# mset (drop (Suc w) (W L)). i &#8712;# dom_m N#} =
          clause_to_update L (M, N(x1 &#8618; swap (N &#8733; x1) i xa), D, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>dom</span><span> </span><span>L_notin_swap</span><span> </span><span>N_xa_in_swap</span><span> </span><span>distinct_mset_dom</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span class="delimiter">]</span><span>
</span><span>    </span><span>i_xa</span><span> </span><span>i_2</span><span> </span><span>assms</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>W&#39;_def</span><span> </span><span>list_update_append</span><span> </span><span>set_N_x1</span><span> </span><span>assms</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span>
</span><span>        </span><span>clause_to_update_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>filter_mset_cong2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm
               ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE)) &#10233;
       La &#8800; L &#10233;
       x &#8712; set (if La = N &#8733; x1 ! xa
                 then W&#39; (N &#8733; x1 ! xa) @ [(x1, L&#39;, b)]
                 else (W(L := (W L)[j := (x1, x2, b)])) La) &#10233;
       case x of
       (i, K, b) &#8658; i &#8712;# dom_m ?N &#10230; K &#8712; set (?N &#8733; i) &#8743; K &#8800; La &#8743; correctly_marked_as_binary ?N (i, K, b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst x&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd x)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd x)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>L&#39;</span><span> </span><span>L_neq</span><span> </span><span>bin</span><span> </span><span>dom</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>W&#39;_def</span><span> </span><span>list_update_append</span><span>
</span><span>      </span><span>correctly_marked_as_binary.simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm
               ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE)) &#10233;
       La &#8800; L &#10233;
       x &#8712; set (if La = N &#8733; x1 ! xa
                 then W&#39; (N &#8733; x1 ! xa) @ [(x1, L&#39;, b)]
                 else (W(L := (W L)[j := (x1, x2, b)])) La) &#10233;
       case x of (i, K, b) &#8658; b &#10230; i &#8712;# dom_m N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst x&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd x)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd x)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>L&#39;</span><span> </span><span>L_neq</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (N &#8733; x1) &gt; 2&#8250;</span></span></span><span>
</span><span>      </span><span>dom</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>W&#39;_def</span><span> </span><span>list_update_append</span><span> </span><span>correctly_marked_as_binary.simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm
               ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE)) &#10233;
       La &#8800; L &#10233; distinct_watched  ((W
           (L := (W L)[j := (x1, x2, b)],
            N &#8733; x1 ! xa := W (N &#8733; x1 ! xa) @ [(x1, L&#39;, b)])) La)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>L&#39;</span><span> </span><span>L_neq</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (N &#8733; x1) &gt; 2&#8250;</span></span></span><span>
</span><span>      </span><span>dom</span><span> </span><span>x1_new</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>W&#39;_def</span><span> </span><span>list_update_append</span><span> </span><span>correctly_marked_as_binary.simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! xa &#8713; set (watched_l (N &#8733; x1))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_xa</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_N_x1</span><span> </span><span>set_N_swap_x1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; &#8896;Ab Ac La.
       all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE)) = add_mset L&#39; (add_mset (N &#8733; x1 ! xa) Ac) &#10233;
       dom_m N = add_mset x1 Ab &#10233;
       N &#8733; x1 ! xa &#8800; L &#10233;
       {#i &#8712;# fst `# mset (W (N &#8733; x1 ! xa)). i = x1 &#8744; i &#8712;# Ab#} =
         {#C &#8712;# Ab. N &#8733; x1 ! xa &#8712; set (watched_l (N &#8733; C))#} &#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! xa&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>L_neq</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>W_W&#39;</span><span> </span><span>W_W2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clause_to_update_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712;# all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE)) &#10233;
          La &#8800; L &#10233;
	  distinct_watched (W&#39; La) &#8743;
          (x1 &#8712;# dom_m N &#10230;
           (La = N &#8733; x1 ! xa &#10230;
            add_mset x1 {#i &#8712;# fst `# mset (W&#39; (N &#8733; x1 ! xa)). i &#8712;# dom_m N#} =
            clause_to_update (N &#8733; x1 ! xa) (M, N(x1 &#8618; swap (N &#8733; x1) i xa), D, NE, UE, {#}, {#})) &#8743;
           (La &#8800; N &#8733; x1 ! xa &#10230;
            {#i &#8712;# fst `# mset (W La). i &#8712;# dom_m N#} =
            clause_to_update La (M, N(x1 &#8618; swap (N &#8733; x1) i xa), D, NE, UE, {#}, {#}))) &#8743;
          (x1 &#8713;# dom_m N &#10230;
           (La = N &#8733; x1 ! xa &#10230;
            {#i &#8712;# fst `# mset (W&#39; (N &#8733; x1 ! xa)). i &#8712;# dom_m N#} =
            clause_to_update (N &#8733; x1 ! xa) (M, N(x1 &#8618; swap (N &#8733; x1) i xa), D, NE, UE, {#}, {#})) &#8743;
           (La &#8800; N &#8733; x1 ! xa &#10230;
            {#i &#8712;# fst `# mset (W La). i &#8712;# dom_m N#} =
            clause_to_update La (M, N(x1 &#8618; swap (N &#8733; x1) i xa), D, NE, UE, {#}, {#})))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq2</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span class="delimiter">]</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>L&#39;</span><span> </span><span>dom</span><span> </span><span>distinct_mset_dom</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span class="delimiter">]</span><span> </span><span>L_notin_swap</span><span> </span><span>N_xa_in_swap</span><span> </span><span>L_neq</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>W&#39;_def</span><span> </span><span>list_update_append</span><span> </span><span>clause_to_update_def</span><span>
</span><span>        </span><span>add_mset_eq_add_mset</span><span> </span><span>set_N_x1</span><span> </span><span>set_N_swap_x1</span><span> </span><span>assms</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span>N_i</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>La_in_notin_swap</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>image_mset_cong2</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>filter_mset_cong2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span>j_w</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching_except.simps</span><span> </span><span>H1</span><span>  </span><span>W&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>W_W&#39;</span><span> </span><span>H2</span><span> </span><span>W_W2</span><span> </span><span>H4</span><span> </span><span>H3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>L&#39;</span><span> </span><span>W_W&#39;</span><span> </span><span>W_W2</span><span> </span><span>H3</span><span> </span><span>H4</span><span> </span><span>drop_map</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_pre L = (&#955;(j, w, S).
     w &lt; length (watched_by S L) &#8743; j &#8804; w &#8743;
     unit_propagation_inner_loop_wl_loop_inv L (j, w, S))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;It was too hard to align the programi unto a refinable form directly.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_int</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; nat &#8658; nat &#8658; &#39;v twl_st_wl &#8658;
    (nat &#215; nat &#215; &#39;v twl_st_wl) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_wl_int L j w S = do {
      ASSERT(unit_propagation_inner_loop_wl_loop_pre L (j, w, S));
      let (C, K, b) = (watched_by S L) ! w;
      let S = keep_watch L j w S;
      ASSERT(unit_prop_body_wl_inv S j w L);
      let val_K = polarity (get_trail_wl S) K;
      if val_K = Some True
      then RETURN (j+1, w+1, S)
      else do { &#8213;&#8249;Now the costly operations:&#8250;
        if C &#8713;# dom_m (get_clauses_wl S)
        then RETURN (j, w+1, S)
        else do {
          let i = (if ((get_clauses_wl S)&#8733;C) ! 0 = L then 0 else 1);
          let L&#39; = ((get_clauses_wl S)&#8733;C) ! (1 - i);
          let val_L&#39; = polarity (get_trail_wl S) L&#39;;
          if val_L&#39; = Some True
          then update_blit_wl L C b j w L&#39; S
          else do {
            f &#8592; find_unwatched_l (get_trail_wl S) (get_clauses_wl S &#8733;C);
            ASSERT (unit_prop_body_wl_find_unwatched_inv f C S);
            case f of
              None &#8658; do {
                if val_L&#39; = Some False
                then do {RETURN (j+1, w+1, set_conflict_wl (get_clauses_wl S &#8733; C) S)}
                else do {RETURN (j+1, w+1, propagate_lit_wl_general L&#39; C i S)}
              }
            | Some f &#8658; do {
                let K = get_clauses_wl S &#8733; C ! f;
                let val_L&#39; = polarity (get_trail_wl S) K;
                if val_L&#39; = Some True
                then update_blit_wl L C b j w K S
                else update_clause_wl L C b j w i f S
              }
          }
        }
      }
   }&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>propagate_proper_bin_case</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_proper_bin_case L L&#39; S C &#10231;
    C &#8712;# dom_m (get_clauses_wl S) &#8743; length ((get_clauses_wl S)&#8733;C) = 2 &#8743;
    set (get_clauses_wl S&#8733;C) = {L, L&#39;} &#8743; L &#8800; L&#39;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_propagation_inner_loop_body_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; nat &#8658; nat &#8658; &#39;v twl_st_wl &#8658;
    (nat &#215; nat &#215; &#39;v twl_st_wl) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_wl L j w S = do {
      ASSERT(unit_propagation_inner_loop_wl_loop_pre L (j, w, S));
      let (C, K, b) = (watched_by S L) ! w;
      let S = keep_watch L j w S;
      ASSERT(unit_prop_body_wl_inv S j w L);
      let val_K = polarity (get_trail_wl S) K;
      if val_K = Some True
      then RETURN (j+1, w+1, S)
      else do {
        if b then do {
           ASSERT(propagate_proper_bin_case L K S C);
           if val_K = Some False
           then RETURN (j+1, w+1, set_conflict_wl (get_clauses_wl S &#8733; C) S)
           else do {  &#8213;&#8249;This is non-optimal (memory access: relax invariant!):&#8250;
             let i = (if ((get_clauses_wl S)&#8733;C) ! 0 = L then 0 else 1);
             RETURN (j+1, w+1, propagate_lit_wl_bin K C i S)}
        }  &#8213;&#8249;Now the costly operations:&#8250;
        else if C &#8713;# dom_m (get_clauses_wl S)
        then RETURN (j, w+1, S)
        else do {
          let i = (if ((get_clauses_wl S)&#8733;C) ! 0 = L then 0 else 1);
          let L&#39; = ((get_clauses_wl S)&#8733;C) ! (1 - i);
          let val_L&#39; = polarity (get_trail_wl S) L&#39;;
          if val_L&#39; = Some True
          then update_blit_wl L C b j w L&#39; S
          else do {
            f &#8592; find_unwatched_l (get_trail_wl S) (get_clauses_wl S &#8733;C);
            ASSERT (unit_prop_body_wl_find_unwatched_inv f C S);
            case f of
              None &#8658; do {
                if val_L&#39; = Some False
                then do {RETURN (j+1, w+1, set_conflict_wl (get_clauses_wl S &#8733; C) S)}
                else do {RETURN (j+1, w+1, propagate_lit_wl L&#39; C i S)}
              }
            | Some f &#8658; do {
                let K = get_clauses_wl S &#8733; C ! f;
                let val_L&#39; = polarity (get_trail_wl S) K;
                if val_L&#39; = Some True
                then update_blit_wl L C b j w K S
                else update_clause_wl L C b j w i f S
              }
          }
        }
      }
   }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st_wl</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_wl (keep_watch L j w S) = get_clauses_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_int_alt_def</span><span class="delimiter">:</span><span>
</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_wl_int L j w S = do {
      ASSERT(unit_propagation_inner_loop_wl_loop_pre L (j, w, S));
      let (C, K, b) = (watched_by S L) ! w;
      let b&#39; = (C &#8713;# dom_m (get_clauses_wl S));
      if b&#39; then do {
        let S = keep_watch L j w S;
        ASSERT(unit_prop_body_wl_inv S j w L);
        let K = K;
        let val_K = polarity (get_trail_wl S) K in
        if val_K = Some True
        then RETURN (j+1, w+1, S)
        else &#8213;&#8249;Now the costly operations:&#8250;
          RETURN (j, w+1, S)
      }
      else do {
        let S&#39; = keep_watch L j w S;
        ASSERT(unit_prop_body_wl_inv S&#39; j w L);
        K &#8592; SPEC((=) K);
        let val_K = polarity (get_trail_wl S&#39;) K in
        if val_K = Some True
        then RETURN (j+1, w+1, S&#39;)
        else do { &#8213;&#8249;Now the costly operations:&#8250;
          let i = (if ((get_clauses_wl S&#39;)&#8733;C) ! 0 = L then 0 else 1);
          let L&#39; = ((get_clauses_wl S&#39;)&#8733;C) ! (1 - i);
          let val_L&#39; = polarity (get_trail_wl S&#39;) L&#39;;
          if val_L&#39; = Some True
          then update_blit_wl L C b j w L&#39; S&#39;
          else do {
            f &#8592; find_unwatched_l (get_trail_wl S&#39;) (get_clauses_wl S&#39;&#8733;C);
            ASSERT (unit_prop_body_wl_find_unwatched_inv f C S&#39;);
            case f of
              None &#8658; do {
                if val_L&#39; = Some False
                then do {RETURN (j+1, w+1, set_conflict_wl (get_clauses_wl S&#39; &#8733; C) S&#39;)}
                else do {RETURN (j+1, w+1, propagate_lit_wl_general L&#39; C i S&#39;)}
              }
            | Some f &#8658; do {
                let K = get_clauses_wl S&#39; &#8733; C ! f;
                let val_L&#39; = polarity (get_trail_wl S&#39;) K;
                if val_L&#39; = Some True
                then update_blit_wl L C b j w K S&#39;
                else update_clause_wl L C b j w i f S&#39;
             }
          }
        }
      }
   }&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We first define an intermediate step where both then and else branches are the same.&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>E</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_wl_int L j w S = do {
      ASSERT(unit_propagation_inner_loop_wl_loop_pre L (j, w, S));
      let (C, K, b) = (watched_by S L) ! w;
      let b&#39; = (C &#8713;# dom_m (get_clauses_wl S));
      if b&#39; then do {
        let S = keep_watch L j w S;
        ASSERT(unit_prop_body_wl_inv S j w L);
        let K = K;
        let val_K = polarity (get_trail_wl S) K in
        if val_K = Some True
        then RETURN (j+1, w+1, S)
        else do { &#8213;&#8249;Now the costly operations:&#8250;
          if b&#39;
          then RETURN (j, w+1, S)
          else do {
            let i = (if ((get_clauses_wl S)&#8733;C) ! 0 = L then 0 else 1);
            let L&#39; = ((get_clauses_wl S)&#8733;C) ! (1 - i);
            let val_L&#39; = polarity (get_trail_wl S) L&#39;;
            if val_L&#39; = Some True
            then update_blit_wl L C b j w L&#39; S
            else do {
              f &#8592; find_unwatched_l (get_trail_wl S) (get_clauses_wl S &#8733;C);
              ASSERT (unit_prop_body_wl_find_unwatched_inv f C S);
              case f of
                None &#8658; do {
                  if val_L&#39; = Some False
                  then do {RETURN (j+1, w+1, set_conflict_wl (get_clauses_wl S &#8733; C) S)}
                  else do {RETURN (j+1, w+1, propagate_lit_wl_general L&#39; C i S)}
                }
              | Some f &#8658; do {
                let K = get_clauses_wl S &#8733; C ! f;
                let val_L&#39; = polarity (get_trail_wl S) K;
                if val_L&#39; = Some True
                then update_blit_wl L C b j w K S
                else update_clause_wl L C b j w i f S
                }
            }
          }
        }
      }
      else do {
        let S&#39; = keep_watch L j w S;
        ASSERT(unit_prop_body_wl_inv S&#39; j w L);
        K &#8592; SPEC((=) K);
        let val_K = polarity (get_trail_wl S&#39;) K in
        if val_K = Some True
        then RETURN (j+1, w+1, S&#39;)
        else do { &#8213;&#8249;Now the costly operations:&#8250;
          if b&#39;
          then RETURN (j, w+1, S&#39;)
          else do {
            let i = (if ((get_clauses_wl S&#39;)&#8733;C) ! 0 = L then 0 else 1);
            let L&#39; = ((get_clauses_wl S&#39;)&#8733;C) ! (1 - i);
            let val_L&#39; = polarity (get_trail_wl S&#39;) L&#39;;
            if val_L&#39; = Some True
            then update_blit_wl L C b j w L&#39; S&#39;
            else do {
              f &#8592; find_unwatched_l (get_trail_wl S&#39;) (get_clauses_wl S&#39;&#8733;C);
              ASSERT (unit_prop_body_wl_find_unwatched_inv f C S&#39;);
              case f of
                None &#8658; do {
                  if val_L&#39; = Some False
                  then do {RETURN (j+1, w+1, set_conflict_wl (get_clauses_wl S&#39; &#8733; C) S&#39;)}
                  else do {RETURN (j+1, w+1, propagate_lit_wl_general L&#39; C i S&#39;)}
                }
              | Some f &#8658; do {
                let K = get_clauses_wl S&#39; &#8733; C ! f;
                let val_L&#39; = polarity (get_trail_wl S&#39;) K;
                if val_L&#39; = Some True
                then update_blit_wl L C b j w K S&#39;
                else update_clause_wl L C b j w i f S&#39;
                }
            }
          }
        }
      }
   }&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ = do {
      ASSERT(unit_propagation_inner_loop_wl_loop_pre L (j, w, S));
      let (C, K, b) = (watched_by S L) ! w;
      let b&#39; = (C &#8713;# dom_m (get_clauses_wl S));
      if b&#39; then do {
        ?P C K b b&#39;
      }
      else do {
        ?Q C K b b&#39;
      }
    }&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_int_def</span><span> </span><span>if_not_swap</span><span> </span><span>bind_to_let_conv</span><span>
</span><span>      </span><span>SPEC_eq_is_RETURN</span><span> </span><span>twl_st_wl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>if_not_swap</span><span> </span><span>bind_to_let_conv</span><span>
</span><span>      </span><span>SPEC_eq_is_RETURN</span><span> </span><span>twl_st_wl</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>if_cancel</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>bind_cong_nres</span><span> </span><span>case_prod_cong</span><span> </span><span>if_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>if_replace_cond</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?P _ _ _&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>if_True</span><span> </span><span>if_False</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The Functions&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Inner Loop&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>clause_to_update_mapsto_upd_If</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>i</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8712;# dom_m N&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause_to_update L (M, N(i &#8618; C&#39;), C, NE, UE, WS, Q) =
    (if L &#8712; set (watched_l C&#39;)
     then add_mset i (remove1_mset i (clause_to_update L (M, N, C, NE, UE, WS, Q)))
     else remove1_mset i (clause_to_update L (M, N, C, NE, UE, WS, Q)))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>D&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; = dom_m N - {#i#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dom_m N = add_mset i D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mset_set.remove</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8713;# D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>distinct_mset_dom</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>D&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#C &#8712;# D&#39;.
     (i = C &#10230; L &#8712; set (watched_l C&#39;)) &#8743;
     (i &#8800; C &#10230; L &#8712; set (watched_l (N &#8733; C)))#} =
    {#C &#8712;# D&#39;. L &#8712; set (watched_l (N &#8733; C))#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>filter_mset_cong2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clause_to_update_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unit_propagation_inner_loop_body_l_with_skip_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_with_skip L (S&#39;, n) = do {
      ASSERT (clauses_to_update_l S&#39; &#8800; {#} &#8744; 0 &lt; n);
      ASSERT (unit_propagation_inner_loop_l_inv L (S&#39;, n));
      b &#8592; SPEC (&#955;b. (b &#10230; 0 &lt; n) &#8743; (&#172; b &#10230; clauses_to_update_l S&#39; &#8800; {#}));
      if &#172; b
      then do {
        ASSERT (clauses_to_update_l S&#39; &#8800; {#});
        X2 &#8592; select_from_clauses_to_update S&#39;;
        ASSERT (unit_propagation_inner_loop_body_l_inv L (snd X2) (fst X2));
        x &#8592; SPEC (&#955;K. K &#8712; set (get_clauses_l (fst X2) &#8733; snd X2));
        let v = polarity (get_trail_l (fst X2)) x;
        if v = Some True then let T = fst X2 in RETURN (T, if get_conflict_l T = None then n else 0)
        else let v = if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1;
                      va = get_clauses_l (fst X2) &#8733; snd X2 ! (1 - v); vaa = polarity (get_trail_l (fst X2)) va
                  in
          if vaa = Some True
	  then let T = fst X2 in RETURN (T, if get_conflict_l T = None then n else 0)
          else do {
             x &#8592; find_unwatched_l (get_trail_l (fst X2)) (get_clauses_l (fst X2) &#8733; snd X2);
             case x of
             None &#8658;
               if vaa = Some False
               then let T = set_conflict_l (get_clauses_l (fst X2) &#8733; snd X2) (fst X2)
                    in RETURN (T, if get_conflict_l T = None then n else 0)
               else let T = propagate_lit_l va (snd X2) v (fst X2)
                    in RETURN (T, if get_conflict_l T = None then n else 0)
             | Some a &#8658; do {
                   x &#8592; ASSERT (a &lt; length (get_clauses_l (fst X2) &#8733; snd X2));
                   let K = (get_clauses_l (fst X2) &#8733; (snd X2))!a;
                   let val_K = polarity (get_trail_l (fst X2)) K;
                   if val_K = Some True
                   then let T = fst X2 in RETURN (T, if get_conflict_l T = None then n else 0)
                   else do {
                          T &#8592; update_clause_l (snd X2) v a (fst X2);
                          RETURN (T, if get_conflict_l T = None then n else 0)
                        }
                 }
            }
        }
      else RETURN (S&#39;, n - 1)
    }&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>remove_pairs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;do {(x2, x2&#39;) &#8592; (b0 :: _ nres); F x2 x2&#39;} =
        do {X2 &#8592; b0; F (fst X2) (snd X2)}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>a0</span><span> </span><span>b0</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>f</span><span> </span><span>t</span><span> </span><span>F</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>case_prod_unfold</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;do {T &#8592; do {x &#8592; a ; b x}; RETURN (f T)} =
        do {x &#8592; a; T &#8592; b x; RETURN (f T)}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>a0</span><span> </span><span>b0</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>f</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;do{T &#8592; let v = val in g v; (f T :: _ nres)} =
         do{let v = val; T &#8592; g v; f T} &#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>T</span><span> </span><span>val</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;do{T &#8592; if b then g else g&#39;; (f T :: _ nres)} =
         (if b then do{T &#8592; g; f T} else do{T &#8592; g&#39;; f T}) &#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span>g&#39;</span><span> </span><span>f</span><span> </span><span>T</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H4</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;do{T &#8592; case x of None &#8658; g | Some a &#8658; g&#39; a; (f T :: _ nres)} =
         (case x of None &#8658; do{T &#8592; g; f T} | Some a &#8658; do{T &#8592; g&#39; a; f T}) &#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span>g&#39;</span><span> </span><span>f</span><span> </span><span>T</span><span> </span><span>b</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_l_with_skip_def</span><span> </span><span>prod.case</span><span>
</span><span>      </span><span>unit_propagation_inner_loop_body_l_def</span><span> </span><span>remove_pairs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>H1</span><span> </span><span>H2</span><span> </span><span>H3</span><span> </span><span>H4</span><span> </span><span>bind_to_let_conv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keep_watch_st_wl</span><span class="delimiter">[</span><span>twl_st_wl</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_wl (keep_watch L j w S) = get_unit_clauses_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl (keep_watch L j w S) = get_conflict_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_wl (keep_watch L j w S) = get_trail_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>twl_st_wl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_except_correct_watching_except_propagate_lit_wl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc 0 &lt; length (get_clauses_wl S &#8733; C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L (propagate_lit_wl_general L&#39; C i S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>D</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, D, NE, UE, Q, W)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>Hneq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La. La&#8712;#all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10233;
        La &#8800; L &#10233;
         (&#8704;(i, K, b)&#8712;#mset (W La). i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743;
            correctly_marked_as_binary N (i, K, b)) &#8743;
         (&#8704;(i, K, b)&#8712;#mset (W La). b &#10230; i &#8712;# dom_m N) &#8743;
         {#i &#8712;# fst `# mset (W La). i &#8712;# dom_m N#} = clause_to_update La (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>Heq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La. La&#8712;#all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10233;
        La = L &#10233;
         (&#8704;(i, K, b)&#8712;#mset (take j (W La) @ drop w (W La)). i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; La &#8743;
              correctly_marked_as_binary N (i, K, b)) &#8743;
         (&#8704;(i, K, b)&#8712;#mset (take j (W La) @ drop w (W La)). b &#10230; i &#8712;# dom_m N) &#8743;
         {#i &#8712;# fst `# mset (take j (W La) @ drop w (W La)). i &#8712;# dom_m N#} =
         clause_to_update La (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>correct_watching_except.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?N</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;if length (N &#8733; C) &gt; 2 then N(C &#8618; swap (N &#8733; C) 0 (Suc 0 - i)) else N&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc 0 - i &lt; length (N &#8733; C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; length (N &#8733; C)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_le</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset (swap (N &#8733; C) 0 (Suc 0 - i)) = mset (N &#8733; C)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#mset (fst x). x &#8712;# ran_m ?N#} =
     {#mset (fst x). x &#8712;# ran_m N#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_m_def</span><span> </span><span>S</span><span>
</span><span>           </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>image_mset_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset `# ran_mf ?N = mset `# ran_mf N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dom_m ?N = dom_m N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H4</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (?N &#8733; ia) =
    set (N &#8733; ia)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ia</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_le</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ia&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H5</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (watched_l (?N &#8733; ia)) = set (watched_l (N &#8733; ia))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ia</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_le</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = ia&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; ia&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl (N &#8733; ia)&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>swap_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary N C&#39; &#10231; correctly_marked_as_binary ?N C&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C&#39;</span><span> </span><span>ia</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correctly_marked_as_binary.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>propagate_lit_wl_general_def</span><span> </span><span>prod.simps</span><span> </span><span>correct_watching_except.simps</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span>H1</span><span> </span><span>H2</span><span> </span><span>H3</span><span> </span><span>H4</span><span> </span><span>clause_to_update_def</span><span> </span><span>get_clauses_l.simps</span><span> </span><span>H5</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_int_alt_def2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_wl_int L j w S = do {
      ASSERT(unit_propagation_inner_loop_wl_loop_pre L (j, w, S));
      let (C, K, b) = (watched_by S L) ! w;
      let S = keep_watch L j w S;
      ASSERT(unit_prop_body_wl_inv S j w L);
      let val_K = polarity (get_trail_wl S) K;
      if val_K = Some True
      then RETURN (j+1, w+1, S)
      else do { &#8213;&#8249;Now the costly operations:&#8250;
        if b then
          if C &#8713;# dom_m (get_clauses_wl S)
          then RETURN (j, w+1, S)
          else do {
            let i = (if ((get_clauses_wl S)&#8733;C) ! 0 = L then 0 else 1);
            let L&#39; = ((get_clauses_wl S)&#8733;C) ! (1 - i);
            let val_L&#39; = polarity (get_trail_wl S) L&#39;;
            if val_L&#39; = Some True
            then update_blit_wl L C b j w L&#39; S
            else do {
              f &#8592; find_unwatched_l (get_trail_wl S) (get_clauses_wl S &#8733;C);
              ASSERT (unit_prop_body_wl_find_unwatched_inv f C S);
              case f of
                None &#8658; do {
                  if val_L&#39; = Some False
                  then do {RETURN (j+1, w+1, set_conflict_wl (get_clauses_wl S &#8733; C) S)}
                  else do {RETURN (j+1, w+1, propagate_lit_wl_general L&#39; C i S)}
                }
              | Some f &#8658; do {
                  let K = get_clauses_wl S &#8733; C ! f;
                  let val_L&#39; = polarity (get_trail_wl S) K;
                  if val_L&#39; = Some True
                  then update_blit_wl L C b j w K S
                  else update_clause_wl L C b j w i f S
                }
            }
          }
        else
          if C &#8713;# dom_m (get_clauses_wl S)
          then RETURN (j, w+1, S)
          else do {
            let i = (if ((get_clauses_wl S)&#8733;C) ! 0 = L then 0 else 1);
            let L&#39; = ((get_clauses_wl S)&#8733;C) ! (1 - i);
            let val_L&#39; = polarity (get_trail_wl S) L&#39;;
            if val_L&#39; = Some True
            then update_blit_wl L C b j w L&#39; S
            else do {
              f &#8592; find_unwatched_l (get_trail_wl S) (get_clauses_wl S &#8733;C);
              ASSERT (unit_prop_body_wl_find_unwatched_inv f C S);
              case f of
                None &#8658; do {
                  if val_L&#39; = Some False
                  then do {RETURN (j+1, w+1, set_conflict_wl (get_clauses_wl S &#8733; C) S)}
                  else do {RETURN (j+1, w+1, propagate_lit_wl_general L&#39; C i S)}
                }
              | Some f &#8658; do {
                  let K = get_clauses_wl S &#8733; C ! f;
                  let val_L&#39; = polarity (get_trail_wl S) K;
                  if val_L&#39; = Some True
                  then update_blit_wl L C b j w K S
                  else update_clause_wl L C b j w i f S
                }
            }
          }
      }
   }&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_int_def</span><span> </span><span>if_not_swap</span><span> </span><span>bind_to_let_conv</span><span>
</span><span>    </span><span>SPEC_eq_is_RETURN</span><span> </span><span>twl_st_wl</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>if_not_swap</span><span> </span><span>bind_to_let_conv</span><span>
</span><span>    </span><span>SPEC_eq_is_RETURN</span><span> </span><span>twl_st_wl</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>if_cancel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>bind_cong_nres</span><span> </span><span>case_prod_cong</span><span> </span><span>if_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_wl L j w S = do {
      ASSERT(unit_propagation_inner_loop_wl_loop_pre L (j, w, S));
      let (C, K, b) = (watched_by S L) ! w;
      let S = keep_watch L j w S;
      ASSERT(unit_prop_body_wl_inv S j w L);
      let val_K = polarity (get_trail_wl S) K;
      if val_K = Some True
      then RETURN (j+1, w+1, S)
      else do {
        if b then do {
          if False
          then RETURN (j, w+1, S)
          else
            if False &#8213; &#8249;\&lt;^term&gt;&#8249;val_L&#39; = Some True&#8250;&#8250;
            then RETURN (j, w+1, S)
            else do {
              f &#8592; RETURN (None :: nat option);
              case f of
               None &#8658; do {
                 ASSERT(propagate_proper_bin_case L K S C);
                 if val_K = Some False
                 then RETURN (j+1, w+1, set_conflict_wl (get_clauses_wl S &#8733; C) S)
                 else do {
                   let i = (if ((get_clauses_wl S)&#8733;C) ! 0 = L then 0 else 1);
                   RETURN (j+1, w+1, propagate_lit_wl_bin K C i S)}
               }
             | _ &#8658; RETURN (j, w+1, S)
            }
        }  &#8213;&#8249;Now the costly operations:&#8250;
        else if C &#8713;# dom_m (get_clauses_wl S)
        then RETURN (j, w+1, S)
        else do {
          let i = (if ((get_clauses_wl S)&#8733;C) ! 0 = L then 0 else 1);
          let L&#39; = ((get_clauses_wl S)&#8733;C) ! (1 - i);
          let val_L&#39; = polarity (get_trail_wl S) L&#39;;
          if val_L&#39; = Some True
          then update_blit_wl L C b j w L&#39; S
          else do {
            f &#8592; find_unwatched_l (get_trail_wl S) (get_clauses_wl S &#8733;C);
            ASSERT (unit_prop_body_wl_find_unwatched_inv f C S);
            case f of
              None &#8658; do {
                if val_L&#39; = Some False
                then do {RETURN (j+1, w+1, set_conflict_wl (get_clauses_wl S &#8733; C) S)}
                else do {RETURN (j+1, w+1, propagate_lit_wl L&#39; C i S)}
              }
            | Some f &#8658; do {
                let K = get_clauses_wl S &#8733; C ! f;
                let val_L&#39; = polarity (get_trail_wl S) K;
                if val_L&#39; = Some True
                then update_blit_wl L C b j w K S
                else update_clause_wl L C b j w i f S
              }
          }
        }
      }
   }&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_def</span><span> </span><span>if_not_swap</span><span> </span><span>bind_to_let_conv</span><span>
</span><span>    </span><span>SPEC_eq_is_RETURN</span><span> </span><span>twl_st_wl</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>if_not_swap</span><span> </span><span>bind_to_let_conv</span><span>
</span><span>    </span><span>SPEC_eq_is_RETURN</span><span> </span><span>twl_st_wl</span><span> </span><span>if_False</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>bind_cong_nres</span><span> </span><span>case_prod_cong</span><span> </span><span>if_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8801; fst (watched_by S L ! w)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8801; remove_one_lit_from_wq C&#39; S&#39;&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39;&#39; &#8801; get_clauses_l S&#39; &#8733; C&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>S_S&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; state_wl_l (Some (L, w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by S L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>j_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>corr_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inner_loop_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_inv L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n = size (filter_mset (&#955;(i, _). i &#8713;# dom_m (get_clauses_wl S)) (mset (drop w (watched_by S L))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl_S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S = None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_wl_int</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_wl L j w S &#8804;
     &#8659; Id (unit_propagation_inner_loop_body_wl_int L j w S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bL</span><span> </span><span>bin</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>SLw</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w = (C&#39;, bL, bin)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8801; (if get_clauses_wl S &#8733; C&#39; ! 0 = L then 0 else 1)&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>l_wl_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv S j w L&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?inv</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>clause_ge_0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; length (get_clauses_l T &#8733; C&#39;)&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?ge</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit (get_trail_wl S) L&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l (get_trail_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l (get_trail_wl S)&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?L_def</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; length (get_clauses_wl S &#8733; C&#39;)&#8250;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?i_le</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i_le2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;1-i &lt; length (get_clauses_wl S &#8733; C&#39;)&#8250;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?i_le2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>C&#39;_dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8712;# dom_m (get_clauses_l T)&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?C&#39;_dom</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L_watched</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set (watched_l (get_clauses_l T &#8733; C&#39;))&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?L_w</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist_clss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset_mset (mset `# ran_mf (get_clauses_wl S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l T = None&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?confl</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien_L</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# init_clss_lf (get_clauses_wl S) + get_unit_init_clss_wl S)&#8250;</span></span></span><span>
</span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?alien</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien_L&#39;</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# ran_mf (get_clauses_wl S) + get_unit_clauses_wl S)&#8250;</span></span></span><span>
</span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?alien&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien_L&#39;&#39;</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# init_clss_lf (get_clauses_wl S) + get_unit_clauses_wl S)&#8250;</span></span></span><span>
</span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?alien&#39;&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>correctly_marked_as_binary</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary (get_clauses_wl S) (C&#39;, bL, bin)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>T_T&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_clauses_to_update_l (clauses_to_update_l T + {#C&#39;#}) T, T&#39;) &#8712; twl_st_l (Some L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>C&#39;_dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8712;# dom_m (get_clauses_l T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; C&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>ge_0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; length (get_clauses_l T &#8733; C&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (get_trail_l T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>i_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(if get_clauses_l T &#8733; C&#39; ! 0 = L then 0 else 1)
         &lt; length (get_clauses_l T &#8733; C&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>i_le2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;1 - (if get_clauses_l T &#8733; C&#39; ! 0 = L then 0 else 1)
         &lt; length (get_clauses_l T &#8733; C&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>L_watched</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set (watched_l (get_clauses_l T &#8733; C&#39;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l T = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?i_le</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?C&#39;_dom</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?L_w</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?i_le2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>i_le</span><span> </span><span>C&#39;_dom</span><span> </span><span>L_watched</span><span> </span><span>i_le2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>lev</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;))&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# clauses_to_update T&#39; &#10233;
         add_mset (fst C) (literals_to_update T&#39;) &#8838;#
         uminus `# lit_of `# mset (get_trail T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_duplicate_queued_alt_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, twl_clause_of C&#39;&#39;) &#8712;# clauses_to_update T&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_l</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l (get_trail T&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mset_le_add_mset_decr_left2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>H</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit (get_trail_wl S) L&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l (get_trail_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l (get_trail_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>T_T&#39;</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>twl_st</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="var">?alien</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>uL_M</span><span> </span><span>twl_st_l</span><span class="delimiter">(</span><span>1</span><span>-</span><span>8</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span> </span><span>S_S&#39;</span><span>
</span><span>        </span><span>init_clss_state_to_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span>
</span><span>        </span><span>unit_init_clauses_get_unit_init_clauses_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_all_lits_of_mm_ain_atms_of_iff</span><span> </span><span>twl_st_wl</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>alien&#39;</span><span class="delimiter">:</span><span> </span><span class="var">?alien&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_lits_of_mm_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?alien&#39;&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_lits_of_mm_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l_wl_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; state_wl_l (Some (L, w)) &#8743;
         unit_propagation_inner_loop_body_l_inv L (fst (watched_by S L ! w))
          (remove_one_lit_from_wq (fst (watched_by S L ! w)) S&#39;) &#8743;
         L &#8712;# all_lits_of_mm
               (mset `# init_clss_lf (get_clauses_wl S) +
                get_unit_clauses_wl S) &#8743;
         correct_watching_except j w L S &#8743;
         w &lt; length (watched_by S L) &#8743; get_conflict_wl S = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>assms</span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?inv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?ge</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ge_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset_mset (mset `# ran_mf (get_clauses_wl S))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>S_S&#39;</span><span> </span><span>twl_st_l</span><span class="delimiter">(</span><span>1</span><span>-</span><span>8</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span> </span><span>T_T&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_alt_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?confl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w &#8712; set (take j (watched_by S L)) &#8746; set (drop w (watched_by S L))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span>alien&#39;</span><span> </span><span>C&#39;_dom</span><span> </span><span>SLw</span><span> </span><span>w_le</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_drop_conv_nth</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary (get_clauses_wl S) (C&#39;, bL, bin)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr_w</span><span> </span><span>alien&#39;</span><span> </span><span>C&#39;_dom</span><span> </span><span>SLw</span><span> </span><span>S_S&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching_except.simps</span><span> </span><span>Ball_def</span><span> </span><span>all_conj_distrib</span><span> </span><span>state_wl_l_def</span><span>
</span><span>          </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Un_iff</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f, f&#39;) &#8712; &#10216;Id&#10217;option_rel&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f, f&#39;) &#8712; {(f, f&#39;). f = f&#39; &#8743; f&#39; = None}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span>f&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f, f&#39;) &#8712; &#10216;Id&#10217;option_rel&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f, f&#39;) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span>f&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_def&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = (if get_clauses_l T &#8733; C&#39; ! 0 = L then 0 else 1)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>bin_dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_proper_bin_case L x1c (keep_watch L j w S) x1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>bin_in_dom</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;False = (x1 &#8713;# dom_m (get_clauses_wl (keep_watch L j w S)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>bin_pol_not_True</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;False =
        (polarity (get_trail_wl (keep_watch L j w S))
          (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
           (1 - (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1))) =
          Some True)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>bin_cannot_find_new</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN None &#8804; &#8659; {(f, f&#39;). f = f&#39; &#8743; f&#39; = None}
       (find_unwatched_l (get_trail_wl (keep_watch L j w S)) (get_clauses_wl (keep_watch L j w S) &#8733; x1))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>bin_pol_False</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(polarity (get_trail_wl (keep_watch L j w S)) x1c = Some False) =
      (polarity (get_trail_wl (keep_watch L j w S))
        (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
         (1 - (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1))) =
       Some False)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>bin_prop</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(let i = if get_clauses_wl (keep_watch L j w S) &#8733; x1b ! 0 = L then 0 else 1
     in RETURN (j + 1, w + 1, propagate_lit_wl_bin x1c x1b i (keep_watch L j w S)))
    &#8804; SPEC (&#955;c. (c, j + 1, w + 1,
                  propagate_lit_wl_general
                   (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
                    (1 - (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)))
                   x1 (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)
                   (keep_watch L j w S))
                 &#8712; Id)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>pre</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_pre L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2 = (x1a, x2a)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2b = (x1c, x2c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>SLw&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>SLw&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w = (x1b, x2b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv (keep_watch L j w S) j w L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv (keep_watch L j w S) j w L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S)) x1c &#8800; Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>bin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2c&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2a&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, T) &#8712; state_wl_l (Some (L, w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>w_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by S L)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (T, remaining_nondom_wl w L S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S &#8743; w &#8804; length (watched_by S L)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pre</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop_pre_def</span><span> </span><span>prod.simps</span><span>
</span><span>        </span><span>unit_propagation_inner_loop_wl_loop_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, T) &#8712; state_wl_l (Some (L, w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &#8804; length (watched_by S L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>T_T&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, T&#39;) &#8712; twl_st_l (Some L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>uL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l (get_trail_l T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update T&#39; &#8800; {#} &#8744; 0 &lt; remaining_nondom_wl w L S &#10230; get_conflict T&#39; = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_l_inv_def</span><span> </span><span>prod.case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict T&#39; = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_T</span><span> </span><span>w_le</span><span> </span><span>T_T&#39;</span><span> </span><span>confl_S</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">)</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>lev</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;))&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# clauses_to_update T&#39; &#10233;
         add_mset (fst C) (literals_to_update T&#39;) &#8838;#
         uminus `# lit_of `# mset (get_trail T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_duplicate_queued_alt_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l (get_trail T&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL</span><span> </span><span>T_T&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm
           (mset `# init_clss_lf (get_clauses_wl S) + get_unit_init_clss_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>uL_M</span><span> </span><span>twl_st_l</span><span class="delimiter">(</span><span>1</span><span>-</span><span>8</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span> </span><span>S_S&#39;</span><span> </span><span>S_T</span><span>
</span><span>        </span><span>init_clss_state_to_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span>
</span><span>        </span><span>unit_init_clauses_get_unit_init_clauses_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_all_lits_of_mm_ain_atms_of_iff</span><span> </span><span>twl_st_wl</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>alien&#39;</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# ran_mf (get_clauses_wl S) + get_unit_clauses_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_lits_of_mm_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w  &#8712; set (drop w (watched_by S L))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr_w</span><span> </span><span>alien&#39;</span><span> </span><span>SLw</span><span> </span><span>S_S&#39;</span><span> </span><span>inv</span><span> </span><span>pre</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching_except.simps</span><span> </span><span>Ball_def</span><span> </span><span>all_conj_distrib</span><span> </span><span>state_wl_l_def</span><span>
</span><span>          </span><span>unit_propagation_inner_loop_wl_loop_pre_def</span><span> </span><span>in_set_drop_conv_nth</span><span>
</span><span>          </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bex_geI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span>  </span><span>w</span><span class="delimiter">]</span><span>
</span><span>          </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Un_iff</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 &#8712;# dom_m (get_clauses_wl S) &#8743; bL &#8712; set (get_clauses_wl S &#8733; C&#39;) &#8743;
             bL &#8800; L &#8743; correctly_marked_as_binary (get_clauses_wl S) (C&#39;, bL, bin) &#8743;
       filter_mset (&#955;i. i &#8712;# dom_m (get_clauses_wl S))
              (fst `# mset (take j (watched_by S L) @ drop w (watched_by S L))) =
       clause_to_update L (get_trail_wl S, get_clauses_wl S, get_conflict_wl S,
          get_unit_init_clss_wl S, get_unit_learned_clss_wl S, {#},  {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr_w</span><span> </span><span>alien&#39;</span><span> </span><span>S_S&#39;</span><span> </span><span>bin</span><span> </span><span>SLw&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SLw</span><span> </span><span>st</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching_except.simps</span><span> </span><span>Ball_def</span><span> </span><span>all_conj_distrib</span><span> </span><span>state_wl_l_def</span><span>
</span><span>          </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;False = (x1 &#8713;# dom_m (get_clauses_wl (keep_watch L j w S)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8712;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>filter</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter_mset (&#955;i. i &#8712;# dom_m (get_clauses_wl S))
              (fst `# mset (take j (watched_by S L) @ drop w (watched_by S L))) =
         clause_to_update L (get_trail_wl S, get_clauses_wl S, get_conflict_wl S,
          get_unit_init_clss_wl S, get_unit_learned_clss_wl S, {#},  {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w  &#8712; set (drop w (watched_by S L))&#8250;</span></span></span><span> </span><span>H</span><span> </span><span>SLw&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SLw</span><span> </span><span>st</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x1c</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1c = bL&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 = x1b&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw&#39;</span><span> </span><span>SLw&#39;&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>st</span><span> </span><span>SLw</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8712;# filter_mset (&#955;i. i &#8712;# dom_m (get_clauses_wl S))
              (fst `# mset (take j (watched_by S L) @ drop w (watched_by S L)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w  &#8712; set (drop w (watched_by S L))&#8250;</span></span></span><span> </span><span>dom</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_in</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set (watched_l (get_clauses_wl S &#8733; C&#39;))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_watched</span><span> </span><span>S_T</span><span> </span><span>SLw&#39;</span><span> </span><span>bin</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>filter</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clause_to_update_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (get_clauses_wl S &#8733; C&#39;) = 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>SLw&#39;</span><span> </span><span>bin</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SLw</span><span> </span><span>st</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correctly_marked_as_binary.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(get_clauses_wl (keep_watch L j w S) &#8733; x1 !
       (1 - (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1))) = bL&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unwatched_l (get_clauses_wl S &#8733; x1) = []&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>lit&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(get_clauses_wl (keep_watch L j w S) &#8733; x1b !
                    ((if get_clauses_wl (keep_watch L j w S) &#8733; x1b ! 0 = L then 0 else 1))) = L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>SLw&#39;</span><span> </span><span>bin</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SLw</span><span> </span><span>st</span><span> </span><span>length_list_2</span><span> </span><span>x1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span>  </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>C&#39;_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;False =
      (polarity (get_trail_wl (keep_watch L j w S))
        (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
         (1 - (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1))) =
        Some True)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x1c</span><span> </span><span>lit</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_proper_bin_case L x1c (keep_watch L j w S) x1&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>le2</span><span> </span><span>SLw&#39;</span><span> </span><span>L_in</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propagate_proper_bin_case_def</span><span> </span><span>x1</span><span> </span><span>SLw</span><span> </span><span>length_list_2</span><span> </span><span>x1</span><span> </span><span>x1c</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN None &#8804; &#8659; {(f, f&#39;). f = f&#39; &#8743; f&#39; = None}
     (find_unwatched_l (get_trail_wl (keep_watch L j w S)) (get_clauses_wl (keep_watch L j w S) &#8733; x1))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>find_unwatched_l_def</span><span> </span><span>RETURN_RES_refine_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(polarity (get_trail_wl (keep_watch L j w S)) x1c = Some False) =
      (polarity (get_trail_wl (keep_watch L j w S))
        (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
         (1 - (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1))) =
       Some False)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x1c</span><span> </span><span>lit</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>    </span><span>bin_prop</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(let i = if get_clauses_wl (keep_watch L j w S) &#8733; x1b ! 0 = L then 0 else 1
     in RETURN (j + 1, w + 1, propagate_lit_wl_bin x1c x1b i (keep_watch L j w S)))
    &#8804; SPEC (&#955;c. (c, j + 1, w + 1,
                  propagate_lit_wl_general
                   (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
                    (1 - (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)))
                   x1 (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)
                   (keep_watch L j w S))
                 &#8712; Id)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le2</span><span> </span><span>SLw&#39;&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x1c</span><span> </span><span>lit</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x1</span><span> </span><span>propagate_lit_wl_bin_def</span><span> </span><span>propagate_lit_wl_general_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>RETURN_RES_refine</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>find_unwatched_l</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_unwatched_l (get_trail_wl (keep_watch L j w S)) (get_clauses_wl (keep_watch L j w S) &#8733; x1b)
      &#8804; &#8659; Id
          (find_unwatched_l (get_trail_wl (keep_watch L j w S)) (get_clauses_wl (keep_watch L j w S) &#8733; x1))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2 = (x1a, x2a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2b = (x1c, x2c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w = (x1b, x2b)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propagate_lit_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((j + 1, w + 1,
	  propagate_lit_wl
	   (get_clauses_wl (keep_watch L j w S) &#8733; x1b !
	    (1 -
	     (if get_clauses_wl (keep_watch L j w S) &#8733; x1b ! 0 = L then 0
	      else 1)))
	   x1b
	   (if get_clauses_wl (keep_watch L j w S) &#8733; x1b ! 0 = L then 0 else 1)
	   (keep_watch L j w S)),
	 j + 1, w + 1,
	 propagate_lit_wl_general
	  (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
	   (1 -
	    (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)))
	  x1 (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)
	  (keep_watch L j w S))
	&#8712; Id&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>pre</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_pre L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2 = (x1a, x2a)&#8250;</span></span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2b = (x1c, x2c)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>SLw</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>SLw&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w = (x1b, x2b)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv (keep_watch L j w S) j w L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S)) x1c &#8800; Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S)) x1a &#8800; Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>bin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; x2c&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; x2a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; x1b &#8713;# dom_m (get_clauses_wl (keep_watch L j w S))&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; x1 &#8713;# dom_m (get_clauses_wl (keep_watch L j w S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S))
	(get_clauses_wl (keep_watch L j w S) &#8733; x1b !
	 (1 -
	  (if get_clauses_wl (keep_watch L j w S) &#8733; x1b ! 0 = L then 0 else 1))) &#8800;
       Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S))
	(get_clauses_wl (keep_watch L j w S) &#8733; x1 !
	 (1 -
	  (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1))) &#8800;
       Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f, fa) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_find_unwatched_inv fa x1 (keep_watch L j w S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_find_unwatched_inv f x1b (keep_watch L j w S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fa = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S))
	(get_clauses_wl (keep_watch L j w S) &#8733; x1b !
	 (1 -
	  (if get_clauses_wl (keep_watch L j w S) &#8733; x1b ! 0 = L then 0 else 1))) &#8800;
       Some False&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S))
	(get_clauses_wl (keep_watch L j w S) &#8733; x1 !
	 (1 -
	  (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1))) &#8800;
       Some False&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span> </span><span>f</span><span> </span><span>fa</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, T) &#8712; state_wl_l (Some (L, w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>w_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by S L)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (T, remaining_nondom_wl w L S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S &#8743; w &#8804; length (watched_by S L)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pre</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop_pre_def</span><span> </span><span>prod.simps</span><span>
</span><span>        </span><span>unit_propagation_inner_loop_wl_loop_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, T) &#8712; state_wl_l (Some (L, w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &#8804; length (watched_by S L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>T_T&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, T&#39;) &#8712; twl_st_l (Some L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>uL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712; lits_of_l (get_trail_l T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update T&#39; &#8800; {#} &#8744; 0 &lt; remaining_nondom_wl w L S &#10230; get_conflict T&#39; = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_l_inv_def</span><span> </span><span>prod.case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict T&#39; = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_T</span><span> </span><span>w_le</span><span> </span><span>T_T&#39;</span><span> </span><span>confl_S</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">)</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>lev</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>twl_st_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv T&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>        </span><span>twl_st_inv.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;))&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# clauses_to_update T&#39; &#10233;
         add_mset (fst C) (literals_to_update T&#39;) &#8838;#
         uminus `# lit_of `# mset (get_trail T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_duplicate_queued_alt_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l (get_trail T&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>uL</span><span> </span><span>T_T&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm
           (mset `# init_clss_lf (get_clauses_wl S) + get_unit_init_clss_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>uL_M</span><span> </span><span>twl_st_l</span><span class="delimiter">(</span><span>1</span><span>-</span><span>8</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span> </span><span>S_S&#39;</span><span> </span><span>S_T</span><span>
</span><span>        </span><span>init_clss_state_to_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span>
</span><span>        </span><span>unit_init_clauses_get_unit_init_clauses_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_all_lits_of_mm_ain_atms_of_iff</span><span> </span><span>twl_st_wl</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>alien&#39;</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# ran_mf (get_clauses_wl S) + get_unit_clauses_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_lits_of_mm_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w  &#8712; set (drop w (watched_by S L))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr_w</span><span> </span><span>alien&#39;</span><span> </span><span>SLw</span><span> </span><span>S_S&#39;</span><span> </span><span>inv</span><span> </span><span>pre</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching_except.simps</span><span> </span><span>Ball_def</span><span> </span><span>all_conj_distrib</span><span> </span><span>state_wl_l_def</span><span>
</span><span>          </span><span>unit_propagation_inner_loop_wl_loop_pre_def</span><span> </span><span>in_set_drop_conv_nth</span><span>
</span><span>          </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bex_geI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span>  </span><span>w</span><span class="delimiter">]</span><span>
</span><span>          </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Un_iff</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary (get_clauses_wl S) (x1b, x1c, False)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr_w</span><span> </span><span>alien&#39;</span><span> </span><span>S_S&#39;</span><span> </span><span>SLw&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>SLw</span><span class="delimiter">]</span><span> </span><span>SLw</span><span> </span><span>bin</span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>st</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching_except.simps</span><span> </span><span>Ball_def</span><span> </span><span>all_conj_distrib</span><span> </span><span>state_wl_l_def</span><span>
</span><span>          </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C&#8712;# (dom_m (get_clauses_wl S)). length (get_clauses_wl S &#8733; C) &#8805; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_inv</span><span> </span><span>S_T</span><span> </span><span>T_T&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_def</span><span> </span><span>twl_st_inv.simps</span><span>
</span><span>        </span><span>image_Un</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (get_clauses_wl S &#8733; C&#39;) &gt; 2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>SLw&#39;</span><span> </span><span>bin</span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SLw</span><span> </span><span>st</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correctly_marked_as_binary.simps</span><span> </span><span>SLw</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>propagate_lit_wl_def</span><span>
</span><span>        </span><span>propagate_lit_wl_general_def</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_int_alt_def2</span><span>
</span><span>       </span><span>unit_propagation_inner_loop_body_wl_alt_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bin_in_dom</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bin_pol_not_True</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span> </span><span class="comment">&#8213;&#8249;impossible case&#8250;</span><span>
</span><span>                     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bin_cannot_find_new</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>f&#39;</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bin_dom</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bin_pol_False</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bin_prop</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>find_unwatched_l</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>f&#39;&#39;</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x1a</span><span> </span><span>x2a</span><span> </span><span>x1b</span><span> </span><span>x2b</span><span> </span><span>x1c</span><span> </span><span>x2c</span><span> </span><span>f</span><span> </span><span>fa</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>propagate_lit_wl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8801; fst (watched_by S L ! w)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8801; remove_one_lit_from_wq C&#39; S&#39;&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39;&#39; &#8801; get_clauses_l S&#39; &#8733; C&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>S_S&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; state_wl_l (Some (L, w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by S L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>j_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>corr_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inner_loop_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_inv L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n = size (filter_mset (&#955;(i, _). i &#8713;# dom_m (get_clauses_wl S)) (mset (drop w (watched_by S L))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl_S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S = None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_int_spec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_wl_int L j w S &#8804;
    &#8659;{((i, j, T&#39;), (T, n)).
        (T&#39;, T) &#8712; state_wl_l (Some (L, j)) &#8743;
        correct_watching_except i j L T&#39; &#8743;
        j &#8804; length (watched_by T&#39; L) &#8743;
        length (watched_by S L) =  length (watched_by T&#39; L) &#8743;
        i &#8804; j &#8743;
        (get_conflict_wl T&#39; = None &#10230;
           n = size (filter_mset (&#955;(i, _). i &#8713;# dom_m (get_clauses_wl T&#39;)) (mset (drop j (watched_by T&#39; L))))) &#8743;
        (get_conflict_wl T&#39; &#8800; None &#10230; n = 0)}
     (unit_propagation_inner_loop_body_l_with_skip L (S&#39;, n))&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?propa&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?unit _&#8250;</span></span></span><span class="delimiter">)</span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>unit_propagation_inner_loop_body_wl_update</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T &#10233;
         mset `# (ran_mf ((get_clauses_wl S) (C&#39;&#8618; (swap (get_clauses_wl S &#8733; C&#39;) 0
                           (1 - (if (get_clauses_wl S)&#8733;C&#39; ! 0 = L then 0 else 1)))))) =
        mset `# (ran_mf (get_clauses_wl S))&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#10233; ?eq&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bL</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>SLw</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w = (C&#39;, bL)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>val</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(polarity a b, polarity a&#39; b&#39;) &#8712; Id&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a = a&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b = b&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>a&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a, &#39;b) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span> </span><span>b&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_wl S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_unwatched_l (get_trail_wl S) (get_clauses_wl S &#8733; C&#39;)
      &#8804; &#8659; {(found, found&#39;). found = found&#39; &#8743;
             (found = None &#10231; (&#8704;L&#8712;set (unwatched_l C&#39;&#39;). -L &#8712; lits_of_l ?M)) &#8743;
             (&#8704;j. found = Some j &#10230; (j &lt; length C&#39;&#39; &#8743; (undefined_lit ?M (C&#39;&#39;!j) &#8744; C&#39;&#39;!j &#8712; lits_of_l ?M) &#8743; j &#8805; 2))
           }
            (find_unwatched_l (get_trail_l T) (get_clauses_l T &#8733; C&#39;))&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?find _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>find_unwatched_l_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>RES_refine</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8801; (if get_clauses_wl S &#8733; C&#39; ! 0 = L then 0 else 1)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>l_wl_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv S j w L&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?inv</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>clause_ge_0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; length (get_clauses_l T &#8733; C&#39;)&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?ge</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit (get_trail_wl S) L&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l (get_trail_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l (get_trail_wl S)&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?L_def</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; length (get_clauses_wl S &#8733; C&#39;)&#8250;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?i_le</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i_le2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;1-i &lt; length (get_clauses_wl S &#8733; C&#39;)&#8250;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?i_le2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>C&#39;_dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8712;# dom_m (get_clauses_l T)&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?C&#39;_dom</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L_watched</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set (watched_l (get_clauses_l T &#8733; C&#39;))&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?L_w</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist_clss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset_mset (mset `# ran_mf (get_clauses_wl S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l T = None&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?confl</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien_L</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# init_clss_lf (get_clauses_wl S) + get_unit_init_clss_wl S)&#8250;</span></span></span><span>
</span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?alien</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien_L&#39;</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# ran_mf (get_clauses_wl S) + get_unit_clauses_wl S)&#8250;</span></span></span><span>
</span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?alien&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien_L&#39;&#39;</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# init_clss_lf (get_clauses_wl S) + get_unit_clauses_wl S)&#8250;</span></span></span><span>
</span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?alien&#39;&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>correctly_marked_as_binary</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary (get_clauses_wl S) (C&#39;, bL)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>T_T&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_clauses_to_update_l (clauses_to_update_l T + {#C&#39;#}) T, T&#39;) &#8712; twl_st_l (Some L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>C&#39;_dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8712;# dom_m (get_clauses_l T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; C&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>ge_0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; length (get_clauses_l T &#8733; C&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (get_trail_l T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>i_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(if get_clauses_l T &#8733; C&#39; ! 0 = L then 0 else 1)
         &lt; length (get_clauses_l T &#8733; C&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>i_le2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;1 - (if get_clauses_l T &#8733; C&#39; ! 0 = L then 0 else 1)
         &lt; length (get_clauses_l T &#8733; C&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>L_watched</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set (watched_l (get_clauses_l T &#8733; C&#39;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l T = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?i_le</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?C&#39;_dom</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?L_w</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?i_le2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>i_le</span><span> </span><span>C&#39;_dom</span><span> </span><span>L_watched</span><span> </span><span>i_le2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>dup</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>lev</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of T&#39;))&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# clauses_to_update T&#39; &#10233;
         add_mset (fst C) (literals_to_update T&#39;) &#8838;#
         uminus `# lit_of `# mset (get_trail T&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_duplicate_queued_alt_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L, twl_clause_of C&#39;&#39;) &#8712;# clauses_to_update T&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_l</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>uL_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l (get_trail T&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mset_le_add_mset_decr_left2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>H</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit (get_trail_wl S) L&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712; lits_of_l (get_trail_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713; lits_of_l (get_trail_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>T_T&#39;</span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>twl_st</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="var">?alien</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>uL_M</span><span> </span><span>twl_st_l</span><span class="delimiter">(</span><span>1</span><span>-</span><span>8</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span> </span><span>S_S&#39;</span><span>
</span><span>        </span><span>init_clss_state_to_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span>
</span><span>        </span><span>unit_init_clauses_get_unit_init_clauses_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_all_lits_of_mm_ain_atms_of_iff</span><span> </span><span>twl_st_wl</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>alien&#39;</span><span class="delimiter">:</span><span> </span><span class="var">?alien&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_lits_of_mm_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?alien&#39;&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_rev_mp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_lits_of_mm_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l_wl_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; state_wl_l (Some (L, w)) &#8743;
         unit_propagation_inner_loop_body_l_inv L (fst (watched_by S L ! w))
          (remove_one_lit_from_wq (fst (watched_by S L ! w)) S&#39;) &#8743;
         L &#8712;# all_lits_of_mm
               (mset `# init_clss_lf (get_clauses_wl S) +
                get_unit_clauses_wl S) &#8743;
         correct_watching_except j w L S &#8743;
         w &lt; length (watched_by S L) &#8743; get_conflict_wl S = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>assms</span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?inv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?ge</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ge_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset_mset (mset `# ran_mf (get_clauses_wl S))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>S_S&#39;</span><span> </span><span>twl_st_l</span><span class="delimiter">(</span><span>1</span><span>-</span><span>8</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>T_T&#39;</span><span class="delimiter">]</span><span> </span><span>T_T&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_alt_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?confl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w &#8712; set (take j (watched_by S L)) &#8746; set (drop w (watched_by S L))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span>alien&#39;</span><span> </span><span>C&#39;_dom</span><span> </span><span>SLw</span><span> </span><span>w_le</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_drop_conv_nth</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary (get_clauses_wl S) (C&#39;, bL)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr_w</span><span> </span><span>alien&#39;</span><span> </span><span>C&#39;_dom</span><span> </span><span>SLw</span><span> </span><span>S_S&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching_except.simps</span><span> </span><span>Ball_def</span><span> </span><span>all_conj_distrib</span><span> </span><span>state_wl_l_def</span><span>
</span><span>          </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Un_iff</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f, f&#39;) &#8712; &#10216;Id&#10217;option_rel&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f = f&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span>f&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_def&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = (if get_clauses_l T &#8733; C&#39; ! 0 = L then 0 else 1)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>refine0</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN (C&#39;, bL) &#8804; &#8659; {((C&#39;, bL), b). (b &#10231; C&#39;&#8713;# dom_m (get_clauses_wl S)) &#8743;
           (b &#10230; 0 &lt; n) &#8743; (&#172;b &#10230; clauses_to_update_l S&#39; &#8800; {#})}
       (SPEC (&#955;b. (b &#10230; 0 &lt; n) &#8743; (&#172;b &#10230; clauses_to_update_l S&#39; &#8800; {#})))&#8250;</span></span></span><span>
</span><span>       </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?blit _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (S&#39;, n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#} &#8744; 0 &lt; n &#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (S&#39;, n)&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_inv L (j, w, S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(C&#39;, bL) &#8712;# {#(i, _) &#8712;# mset (drop w (watched_by S L)). i &#8713;# dom_m (get_clauses_wl S)#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by S L ! w) &#8713;# dom_m (get_clauses_wl S) &#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>w_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_set_drop_conv_nth</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ex_geI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>w</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SLw</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by S L ! w) &#8712;# dom_m (get_clauses_wl S) &#10233;
      clauses_to_update_l S&#39; = {#} &#10233; False&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>w_le</span><span> </span><span>that</span><span> </span><span>n</span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SLw</span><span> </span><span>unit_propagation_inner_loop_l_inv_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>in_set_drop_conv_nth</span><span> </span><span>twl_st_l_def</span><span>
</span><span>         </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ex_geI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>w</span><span class="delimiter">]</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>RETURN_SPEC_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8713;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (watched_by (keep_watch L j w S) L) = length (watched_by S L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>j</span><span> </span><span>w</span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S_removal</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, set_clauses_to_update_l
         (remove1_mset (fst (watched_by S L ! w)) (clauses_to_update_l S&#39;)) S&#39;)
    &#8712; state_wl_l (Some (L, Suc w))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>w_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN (get_clauses_wl (keep_watch L j w S) &#8733; C&#39;)
    &#8804; &#8659; {(_, (U, C)). C = C&#39; &#8743; (S, U) &#8712; state_wl_l (Some (L, Suc w))} (select_from_clauses_to_update S&#39;)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_inv L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by S L ! w) &#8712;# clauses_to_update_l S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>select_from_clauses_to_update_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RETURN_RES_refine</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, C&#39;)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_one_lit_from_wq_def</span><span> </span><span>S_removal</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>keep_watch_state_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by S L ! w) &#8713;# dom_m (get_clauses_wl S) &#10233;
     (keep_watch L j w S, S&#39;) &#8712; state_wl_l (Some (L, Suc w))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>keep_watch_def</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span>drop_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (Suc w) (watched_by (keep_watch L j w S) L) = drop (Suc w) (watched_by S L)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_wl (keep_watch L j w S) = get_clauses_wl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>j</span><span> </span><span>w</span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>keep_watch</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN (keep_watch L j w S) &#8804; &#8659; {(T, (T&#39;, C)). (T, T&#39;) &#8712; state_wl_l (Some (L, Suc w)) &#8743;
         C = C&#39; &#8743; T&#39; = set_clauses_to_update_l (clauses_to_update_l S&#39; - {#C#}) S&#39;}
      (select_from_clauses_to_update S&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?keep_watch _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span>cond</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#} &#8744; 0 &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (S&#39;, n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_inv L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; C&#39; &#8713;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>clss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l S&#39; = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clss</span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_l_inv_def</span><span> </span><span>twl_struct_invs_def</span><span> </span><span>prod.case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>that</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>select_from_clauses_to_update_def</span><span> </span><span>keep_watch_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>RETURN_RES_refine</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>drop_map</span><span>
</span><span>          </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trail_keep_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_wl (keep_watch L j w S) = get_trail_wl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>j</span><span> </span><span>w</span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit_prop_body_wl_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv (keep_watch L j w S) j w L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#} &#8744; 0 &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>loop_l</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (S&#39;, n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>loop_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_pre L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((C&#39;, bL), b) &#8712; ?blit&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(C&#39;, bL) = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; x1 &#8713;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, X2) &#8712; ?keep_watch&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L (snd X2) (fst X2)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>b</span><span> </span><span>X2</span><span> </span><span>x2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>corr_w&#39;</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S &#10233; correct_watching_except j w L (keep_watch L j w S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span>w_le</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>correct_watching_except.simps</span><span> </span><span>keep_watch_def</span><span> </span><span>prod.case</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j = w&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, S&#39;) &#8712; state_wl_l (Some (L, w)) &#10231; (S, S&#39;) &#8712; state_wl_l (Some (L, w))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span> </span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j=w&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>keep_watch_def</span><span> </span><span>drop_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by (keep_watch L j w S) L ! w = watched_by S L ! w&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span> </span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j=w&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>keep_watch_def</span><span> </span><span>drop_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>inv</span><span> </span><span>X2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_one_lit_from_wq_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# init_clss_lf (get_clauses_wl S) + get_unit_clauses_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien_L&#39;&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span>w_le</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>S&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span>X2</span><span> </span><span>w_le</span><span> </span><span>S_S&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>corr_w&#39;</span><span> </span><span>corr_w</span><span> </span><span>remove_one_lit_from_wq_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>refine0</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;SPEC ((=) x2) &#8804; SPEC (&#955;K. K &#8712; set (get_clauses_l (fst X2) &#8733; snd X2))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#} &#8744; 0 &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (S&#39;, n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_pre L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>bL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((C&#39;, bL), b) &#8712; ?blit&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(C&#39;, bL) = (x1, x2&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2&#39; =(x2, x3)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; x1 &#8713;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, X2) &#8712; ?keep_watch&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L (snd X2) (fst X2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv (keep_watch L j w S) j w L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>b</span><span> </span><span>x3</span><span> </span><span>x2&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2&#39; = bL&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 = C&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_one_lit_from_wq_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>alien_L&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# ran_mf (get_clauses_wl S) + get_unit_clauses_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>correct_watching_exceptD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>corr_w</span><span> </span><span>this</span><span> </span><span>w_le</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst bL &#8712; set (get_clauses_wl S &#8733; fst (watched_by S L ! w))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x1</span><span> </span><span>SLw</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by S L ! w&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bL</span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span>x1</span><span> </span><span>x2&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>find_unwatched_l</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_unwatched_l (get_trail_wl (keep_watch L j w S))
        (get_clauses_wl (keep_watch L j w S) &#8733; x1)
        &#8804; &#8659; {(k, k&#39;). k = k&#39; &#8743; get_clauses_wl S &#8733; x1 &#8800; [] &#8743;
            (k &#8800; None &#10230; (the k &#8805; 2 &#8743; the k &lt; length (get_clauses_wl (keep_watch L j w S) &#8733; x1) &#8743;
               (undefined_lit (get_trail_wl S) (get_clauses_wl (keep_watch L j w S) &#8733; x1!(the k))
                  &#8744; get_clauses_wl (keep_watch L j w S) &#8733; x1!(the k) &#8712; lits_of_l (get_trail_wl S)))) &#8743;
            ((k = None) &#10231;
              (&#8704;La&#8712;#mset (unwatched_l (get_clauses_wl (keep_watch L j w S) &#8733; x1)).
              - La &#8712; lits_of_l (get_trail_wl (keep_watch L j w S))))}
          (find_unwatched_l (get_trail_l (fst X2))
            (get_clauses_l (fst X2) &#8733; snd X2))&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?find_unw _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>C&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(C&#39;, bL) = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, X2) &#8712; ?keep_watch&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; {K. K &#8712; set (get_clauses_l (fst X2) &#8733; snd X2)}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, X2) &#8712;  ?keep_watch&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>X2</span><span> </span><span>SLw</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span> </span><span>find_unwatched_l_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>SPEC_refine</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>blit_final</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(if polarity (get_trail_wl (keep_watch L j w S)) x2 = Some True
        then RETURN (j + 1, w + 1, keep_watch L j w S)
        else RETURN (j, w + 1, keep_watch L j w S))
        &#8804; &#8659; ?unit
          (RETURN (S&#39;, n - 1))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((C&#39;, bL), b) &#8712; ?blit&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(C&#39;, bL) = (x1, x2&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2&#39; =(x2, x3)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 &#8713;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv (keep_watch L j w S) j w L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x2&#39;</span><span> </span><span>x3</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span> </span><span>n</span><span> </span><span>that</span><span> </span><span>confl_S</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_state_wl</span><span> </span><span>assert_bind_spec_conv</span><span> </span><span>Let_def</span><span> </span><span>twl_st_wl</span><span>
</span><span>        </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>correct_watching_except_correct_watching_except_Suc_Suc_keep_watch</span><span>
</span><span>        </span><span>corr_w</span><span> </span><span>correct_watching_except_correct_watching_except_Suc_notin</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conflict_final</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((j + 1, w + 1,
          set_conflict_wl (get_clauses_wl (keep_watch L j w S) &#8733; x1)
          (keep_watch L j w S)),
        set_conflict_l (get_clauses_l (fst X2) &#8733; snd X2) (fst X2),
        if get_conflict_l
            (set_conflict_l (get_clauses_l (fst X2) &#8733; snd X2) (fst X2)) =
            None
        then n else 0)
        &#8712; ?unit&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>C&#39;_bl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(C&#39;, bL) = (x1, x2&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2&#39; =(x2, x3)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, X2) &#8712; ?keep_watch&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span> </span><span>f</span><span> </span><span>x&#39;</span><span> </span><span>x2&#39;</span><span> </span><span>x3</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l (set_conflict_l C S) &#8800; None&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl (set_conflict_wl C S&#39;) = Some (mset C)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by (set_conflict_wl C S&#39;) L = watched_by S&#39; L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span> </span><span>L</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_conflict_l_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_conflict_wl_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_conflict_wl_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L (set_conflict_wl C S) &#10231;
      correct_watching_except j w L S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>j</span><span> </span><span>w</span><span> </span><span>L</span><span> </span><span>C</span><span> </span><span>S</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>correct_watching_except.simps</span><span>
</span><span>        </span><span>set_conflict_wl_def</span><span> </span><span>prod.case</span><span> </span><span>clause_to_update_def</span><span> </span><span>get_clauses_l.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_conflict_wl (get_clauses_wl S &#8733; x1) (keep_watch L j w S),
      set_conflict_l (get_clauses_l (fst X2) &#8733; snd X2) (fst X2))
      &#8712; state_wl_l (Some (L, Suc w))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>X2</span><span> </span><span>SLw</span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span>
</span><span>        </span><span>set_conflict_wl_def</span><span> </span><span>set_conflict_l_def</span><span> </span><span>keep_watch_def</span><span>
</span><span>        </span><span>clauses_to_update_wl.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_state_wl</span><span>
</span><span>          </span><span>correct_watching_except_correct_watching_except_Suc_Suc_keep_watch</span><span>
</span><span>          </span><span>corr_w</span><span> </span><span>correct_watching_except_correct_watching_except_Suc_notin</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa_final</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((j + 1, w + 1,
          propagate_lit_wl_general
          (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
            (1 -
            (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)))
          x1 (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)
          (keep_watch L j w S)),
        propagate_lit_l
          (get_clauses_l (fst X2) &#8733; snd X2 !
          (1 - (if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1)))
          (snd X2) (if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1)
          (fst X2),
        if get_conflict_l
            (propagate_lit_l
              (get_clauses_l (fst X2) &#8733; snd X2 !
                (1 - (if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1)))
              (snd X2) (if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1)
              (fst X2)) =
            None
        then n else 0)
        &#8712; ?unit&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>C&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(C&#39;, bL) = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x1_dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; x1 &#8713;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, X2) &#8712; ?keep_watch&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>l_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L (snd X2) (fst X2)&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span> </span><span>f</span><span> </span><span>x&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l (propagate_lit_l C L w S) = get_conflict_l S&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by (propagate_lit_wl_general C L w S&#39;) L&#39; = watched_by S&#39; L&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl (propagate_lit_wl_general C L w S&#39;) = get_conflict_wl S&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# dom_m (get_clauses_wl S&#39;) &#10233;
         dom_m (get_clauses_wl (propagate_lit_wl_general C L w S&#39;)) = dom_m (get_clauses_wl S&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dom_m (get_clauses_wl (keep_watch L&#39; i j S&#39;)) = dom_m (get_clauses_wl S&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span> </span><span>L</span><span> </span><span>w</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span> </span><span>L&#39;</span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>propagate_lit_l_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>propagate_lit_wl_general_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>propagate_lit_wl_general_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>propagate_lit_wl_general_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>propagate_lit_wl_general_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8801; if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_alt_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = (if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x1_dom</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 &#8712;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x1_dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_wl S &#8733; x1 ! 0 &#8800; L &#10233; get_clauses_wl S &#8733; x1 ! Suc 0 = L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc 0 &lt; length (get_clauses_wl S &#8733; x1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l_inv</span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span> </span><span>C&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_wl S &#8733; x1&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl (get_clauses_wl S &#8733; x1)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n = size {#(i, _) &#8712;# mset (drop (Suc w) (watched_by S L)).
        i &#8713;# dom_m (get_clauses_wl S)#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span>SLw</span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l (fst X2) = get_conflict_wl S&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(propagate_lit_wl_general (get_clauses_wl S &#8733; x1 ! (Suc 0 - i)) x1 i (keep_watch L j w S),
     propagate_lit_l (get_clauses_l (fst X2) &#8733; snd X2 ! (Suc 0 - i)) (snd X2) i (fst X2))
    &#8712; state_wl_l (Some (L, Suc w))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span>SLw</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x1_dom</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>propagate_lit_wl_general_def</span><span> </span><span>keep_watch_def</span><span>
</span><span>          </span><span>propagate_lit_l_def</span><span> </span><span>drop_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except (Suc j) (Suc w) L (keep_watch L j w S) &#10233;
    correct_watching_except (Suc j) (Suc w) L
     (propagate_lit_wl_general (get_clauses_wl S &#8733; x1 ! (Suc 0 - i)) x1 i (keep_watch L j w S))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>correct_watching_except_correct_watching_except_propagate_lit_wl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_le</span><span> </span><span>j_w</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc 0 &lt; length (get_clauses_wl S &#8733; x1)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except (Suc j) (Suc w) L (keep_watch L j w S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>corr_w</span><span> </span><span>correct_watching_except_correct_watching_except_Suc_Suc_keep_watch</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>i_alt_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span> </span><span>j_w</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>update_blit_wl_final</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_blit_wl L x1 x3 j w (get_clauses_wl (keep_watch L j w S) &#8733; x1 ! xa) (keep_watch L j w S)
      &#8804; &#8659; ?unit
          (RETURN (fst X2, if get_conflict_l (fst X2) = None then n else 0))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>cond</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#} &#8744; 0 &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>loop_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (S&#39;, n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_pre L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>C&#39;bl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((C&#39;, bL), b) &#8712; ?blit&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>C&#39;_bl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(C&#39;, bL) = (x1, x2&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2&#39; =(x2, x3)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; x1 &#8713;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, X2) &#8712; ?keep_watch&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>pre</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L (snd X2) (fst X2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv (keep_watch L j w S) j w L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(K, x) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712; Collect ((=) x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; {K. K &#8712; set (get_clauses_l (fst X2) &#8733; snd X2)}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>fx&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f, x&#39;) &#8712; ?find_unw x1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_find_unwatched_inv f x1 (keep_watch L j w S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>f</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f = Some xa&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x&#39; = Some x&#39;a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>xa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(xa, x&#39;a) &#8712; nat_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x&#39;a &lt; length (get_clauses_l (fst X2) &#8733; snd X2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S)) (get_clauses_wl (keep_watch L j w S) &#8733; x1 ! xa) =
     Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>pol</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_l (fst X2)) (get_clauses_l (fst X2) &#8733; snd X2 ! x&#39;a) = Some True&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span> </span><span>f</span><span> </span><span>x&#39;</span><span> </span><span>xa</span><span> </span><span>x&#39;a</span><span> </span><span>x2&#39;</span><span> </span><span>x3</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>loop_inv</span><span> </span><span>cond</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_l_inv_def</span><span> </span><span>prod.case</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_one_lit_from_wq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except (Suc j) (Suc w) L (keep_watch L j w S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>corr_w</span><span> </span><span>correct_watching_except_correct_watching_except_Suc_Suc_keep_watch</span><span>
</span><span>          </span><span>j_w</span><span> </span><span>w_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except (Suc j) (Suc w) L
       (a, b, None, d, e, f, ga(L := (ga L)[j := (x1, b &#8733; x1 ! xa, x3)]))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>        </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except (Suc j) (Suc w) L
      (a, b, None, d, e, f, ga(L := (ga L)[j := (x1, x2, x3)]))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ga L ! w = (x1, x2, x3)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>S</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (a, b, None, d, e, f, ga)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;X2 = (set_clauses_to_update_l (remove1_mset x1 (clauses_to_update_l S&#39;)) S&#39;, x1)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(a, b, None, d, e,
      {#i &#8712;# mset (drop (Suc w) (map fst ((ga L)[j := (x1, x2, x3)]))). i &#8712;# dom_m b#}, f) =
      set_clauses_to_update_l (remove1_mset x1 (clauses_to_update_l S&#39;)) S&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v literal, &#39;v literal,nat) annotated_lit list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat, &#39;v literal list &#215;  bool) fmap&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>d</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal multiset multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>e</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal multiset multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>ga</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; (nat &#215; &#39;v literal &#215; bool) list&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8733; x1 ! xa &#8712;# all_lits_of_mm (mset `# ran_mf b + (d + e))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span>fx&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_m_def</span><span> </span><span>all_lits_of_mm_add_mset</span><span> </span><span>x&#39;</span><span> </span><span>f</span><span> </span><span>twl_st_wl</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>            </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_clause_in_all_lits_of_m</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8733; x1 ! xa &#8712; set (b &#8733; x1)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span>fx&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_m_def</span><span> </span><span>all_lits_of_mm_add_mset</span><span> </span><span>x&#39;</span><span> </span><span>f</span><span> </span><span>twl_st_wl</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>            </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_clause_in_all_lits_of_m</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#8733; x1 ! xa &#8800; L&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pol</span><span> </span><span>X2</span><span> </span><span>L_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unit_T</span><span class="delimiter">]</span><span> </span><span>S_S&#39;</span><span> </span><span>SLw</span><span> </span><span>fx&#39;</span><span> </span><span>x&#39;</span><span> </span><span>f&#39;</span><span> </span><span>xa</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary b (x1, b &#8733; x1 ! xa, x3)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>correctly_marked_as_binary</span><span> </span><span>unit_T</span><span> </span><span>C&#39;_bl</span><span> </span><span>x2&#39;</span><span> </span><span>C&#39;bl</span><span> </span><span>dom</span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correctly_marked_as_binary.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>correct_watching_except_update_blit</span><span class="delimiter">[</span><span>OF</span><span> </span><span>corr</span><span> </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_blit_wl L x1 x3 j w (get_clauses_wl (keep_watch L j w S) &#8733; x1 ! xa) (keep_watch L j w S)
    &#8804; SPEC(&#955;(i, j, T&#39;). correct_watching_except i j L T&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X2</span><span> </span><span>confl</span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>x2&#39;</span><span>
</span><span>          </span><span>update_blit_wl_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>loop_inv</span><span> </span><span>cond</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_l_inv_def</span><span> </span><span>prod.case</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n = size {#(i, _) &#8712;# mset (drop (Suc w) (watched_by S L)). i &#8713;# dom_m (get_clauses_wl S)#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span>dom</span><span> </span><span>X2</span><span> </span><span>w_le</span><span> </span><span>S_S&#39;</span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>S_S&#39;</span><span> </span><span>X2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>update_blit_wl_def</span><span> </span><span>keep_watch_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>drop_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>update_clss_final</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_clause_wl L x1 x3 j w
       (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1) xa
       (keep_watch L j w S)
      &#8804; &#8659; ?unit
          (update_clause_l (snd X2)
            (if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1) x&#39;a (fst X2) &#10524;
           (&#955;T. RETURN (T, if get_conflict_l T = None then n else 0)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>cond</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#} &#8744; 0 &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>loop_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (S&#39;, n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_pre L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((C&#39;, bL), b) &#8712; ?blit&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>C&#39;_bl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(C&#39;, bL) = (x1, x2&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2&#39; =(x2, x3)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; x1 &#8713;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, X2) &#8712; ?keep_watch&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>wl_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv (keep_watch L j w S) j w L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(K, x) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712; Collect ((=) x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; {K. K &#8712; set (get_clauses_l (fst X2) &#8733; snd X2)}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S)) K &#8800; Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_l (fst X2)) x &#8800; Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S))
      (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
        (1 - (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1))) &#8800;
       Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_l (fst X2))
        (get_clauses_l (fst X2) &#8733; snd X2 !
          (1 - (if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1))) &#8800;
      Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>fx&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f, x&#39;) &#8712; ?find_unw x1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_find_unwatched_inv f x1 (keep_watch L j w S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>f</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f = Some xa&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x&#39; = Some x&#39;a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>xa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(xa, x&#39;a) &#8712; nat_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x&#39;a &lt; length (get_clauses_l (fst X2) &#8733; snd X2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S))
        (get_clauses_wl (keep_watch L j w S) &#8733; x1 ! xa) &#8800;
      Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>pol</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_l (fst X2)) (get_clauses_l (fst X2) &#8733; snd X2 ! x&#39;a) &#8800; Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L (snd X2) (fst X2)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span> </span><span>f</span><span> </span><span>x&#39;</span><span> </span><span>xa</span><span> </span><span>x&#39;a</span><span> </span><span>x2&#39;</span><span> </span><span>x3</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>loop_inv</span><span> </span><span>cond</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_l_inv_def</span><span> </span><span>prod.case</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, None, NE, UE, Q, W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 &#8712;# dom_m (get_clauses_wl (keep_watch L j w S)) &#10231; True&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>watch_by_S_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by (keep_watch L j w S) L ! w = (x1, x2, x3)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>SLw</span><span> </span><span>x2&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;_bl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C&#39;_dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by (keep_watch L j w S) L ! w) &#8712;# dom_m (get_clauses_wl (keep_watch L j w S)) &#10231; True&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S_x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, x) &#8712; state_wl_l (Some (L, w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>unit_loop_inv</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L (fst (watched_by (keep_watch L j w S) L ! w))
      (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w)) x)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm
            (mset `# init_clss_lf (get_clauses_wl (keep_watch L j w S)) +
             get_unit_clauses_wl (keep_watch L j w S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L (keep_watch L j w S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by (keep_watch L j w S) L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl (keep_watch L j w S) = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wl_inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_alt_def</span><span> </span><span>C&#39;_dom</span><span> </span><span>simp_thms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>x_x&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_clauses_to_update_l
        (clauses_to_update_l
          (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
            x) +
          {#fst (watched_by (keep_watch L j w S) L ! w)#})
        (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w)) x),
        x&#39;) &#8712; twl_st_l (Some L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs x&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs x&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by (keep_watch L j w S) L ! w)
      &#8712;# dom_m
          (get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; fst (watched_by (keep_watch L j w S) L ! w)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; length
            (get_clauses_l
              (remove_one_lit_from_wq
                (fst (watched_by (keep_watch L j w S) L ! w)) x) &#8733;
            fst (watched_by (keep_watch L j w S) L ! w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup
        (get_trail_l
          (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
            x))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>ge0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(if get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x) &#8733;
          fst (watched_by (keep_watch L j w S) L ! w) !
          0 =
          L
        then 0 else 1)
      &lt; length
          (get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x) &#8733;
          fst (watched_by (keep_watch L j w S) L ! w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>ge1i</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;1 -
      (if get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x) &#8733;
          fst (watched_by (keep_watch L j w S) L ! w) !
          0 =
          L
        then 0 else 1)
      &lt; length
          (get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x) &#8733;
          fst (watched_by (keep_watch L j w S) L ! w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L_watched</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set (watched_l
                (get_clauses_l
                  (remove_one_lit_from_wq
                    (fst (watched_by (keep_watch L j w S) L ! w)) x) &#8733;
                  fst (watched_by (keep_watch L j w S) L ! w)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l
        (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w)) x) =
      None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit_loop_inv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x&#39;a = xa&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_one_lit_from_wq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except (Suc j) (Suc w) L (keep_watch L j w S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>corr_w</span><span> </span><span>correct_watching_except_correct_watching_except_Suc_Suc_keep_watch</span><span>
</span><span>          </span><span>j_w</span><span> </span><span>w_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = (if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw</span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>X2</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw</span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>X2</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = (if get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x) &#8733;
          fst (watched_by (keep_watch L j w S) L ! w) !
          0 =
          L
        then 0 else 1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>S_x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv x&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs x&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;x. twl_st_inv
         (x, {#TWL_Clause (mset (watched_l (fst x)))
                (mset (unwatched_l (fst x)))
             . x &#8712;# init_clss_l N#},
          {#TWL_Clause (mset (watched_l (fst x))) (mset (unwatched_l (fst x)))
          . x &#8712;# learned_clss_l N#},
          None, NE, UE,
          add_mset
           (L, TWL_Clause (mset (watched_l (N &#8733; fst ((W L)[j := W L ! w] ! w))))
                (mset (unwatched_l (N &#8733; fst ((W L)[j := W L ! w] ! w)))))
           {#(L, TWL_Clause (mset (watched_l (N &#8733; x)))
                  (mset (unwatched_l (N &#8733; x))))
           . x &#8712;# remove1_mset (fst ((W L)[j := W L ! w] ! w))
                   {#i &#8712;# mset (drop w (map fst ((W L)[j := W L ! w]))).
                    i &#8712;# dom_m N#}#},
          Q)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_x&#39;</span><span> </span><span>S_x</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>twl_st_l_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>keep_watch_def</span><span>
</span><span>        </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>struct_wf_twl_cls.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball
       ({#TWL_Clause (mset (watched_l (fst x))) (mset (unwatched_l (fst x)))
        . x &#8712;# ran_m N#})
       struct_wf_twl_cls&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span>image_mset_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>all_clss_l_ran_m</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>distinct_N_x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct (N &#8733; x1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>ran_m_def</span><span> </span><span>mset_take_mset_drop_mset&#39;</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_i</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = N &#8733; x1 ! i&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watch_by_S_w</span><span> </span><span>L_watched</span><span> </span><span>ge0</span><span> </span><span>ge1i</span><span> </span><span>SLw</span><span> </span><span>S_x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;_bl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_2_if</span><span> </span><span>twl_st_wl</span><span> </span><span>S</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; length (N &#8733; x1)&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;1-i &lt; length (N &#8733; x1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watch_by_S_w</span><span> </span><span>ge0</span><span> </span><span>ge1i</span><span> </span><span>S_x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;X2 = (set_clauses_to_update_l (remove1_mset x1 (clauses_to_update_l S&#39;)) S&#39;, x1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw</span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>X2</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n = size {#(i, _) &#8712;# mset (drop (Suc w) (watched_by S L)).
      i &#8800; x1 &#8743; i &#8713;# remove1_mset x1 (dom_m (get_clauses_wl S))#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span>n</span><span> </span><span>w_le</span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8800; get_clauses_wl S &#8733; x1 ! xa&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pol</span><span> </span><span>X2</span><span> </span><span>L_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unit_T</span><span class="delimiter">]</span><span> </span><span>S_S&#39;</span><span> </span><span>SLw</span><span> </span><span>xa</span><span> </span><span>fx&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span> </span><span>f</span><span> </span><span>x&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_def</span><span> </span><span>twl_st_wl</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset x1 {#i &#8712;# mset (drop w (map fst (watched_by S L))). i &#8712;# dom_m (get_clauses_wl S)#} =
       {#i &#8712;# mset (drop (Suc w) (map fst ((watched_by S L)[j := (x1, x2, x3)]))). i = x1 &#8744; i &#8712;# remove1_mset x1 (dom_m (get_clauses_wl S))#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span>n</span><span> </span><span>w_le</span><span> </span><span>SLw</span><span> </span><span>j_w</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>drop_map</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j (Suc w) L
     (M, N(x1 &#8618; swap (N &#8733; x1) i xa), None, NE, UE, Q, W
      (L := (W L)[j := (x1, x2, x3)],
       N &#8733; x1 ! xa := W (N &#8733; x1 ! xa) @ [(x1, L, x3)]))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>correct_watching_except_correct_watching_except_update_clause</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien_L&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unit_T</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>twl_st_wl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>all_clss_l_ran_m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>image_mset_union</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>all_lits_of_mm_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_N_x1</span><span> </span><span>i_le</span><span> </span><span>fx&#39;</span><span> </span><span>xa</span><span> </span><span>i_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_i</span><span> </span><span>x&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>nth_eq_iff_index_eq</span><span> </span><span>i_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xa</span><span> </span><span>fx&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f</span><span> </span><span>xa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>x2&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_i</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_N_x1</span><span> </span><span>i_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_i</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_eq_iff_index_eq</span><span> </span><span>i_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_N_x1</span><span> </span><span>i_le</span><span> </span><span>fx&#39;</span><span> </span><span>xa</span><span> </span><span>i_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_i</span><span> </span><span>x&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>nth_eq_iff_index_eq</span><span> </span><span>i_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_N_x1</span><span> </span><span>i_le</span><span> </span><span>fx&#39;</span><span> </span><span>xa</span><span> </span><span>i_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_i</span><span> </span><span>x&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>nth_eq_iff_index_eq</span><span> </span><span>i_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_N_x1</span><span> </span><span>i_le</span><span> </span><span>fx&#39;</span><span> </span><span>xa</span><span> </span><span>i_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_i</span><span> </span><span>x&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>nth_eq_iff_index_eq</span><span> </span><span>i_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xa</span><span> </span><span>fx&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f</span><span> </span><span>xa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_N_x1</span><span> </span><span>i_le</span><span> </span><span>fx&#39;</span><span> </span><span>xa</span><span> </span><span>i_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_i</span><span> </span><span>x&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>nth_eq_iff_index_eq</span><span> </span><span>i_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span> </span><span>SLw</span><span> </span><span>confl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>update_clause_wl_def</span><span> </span><span>update_clause_l_def</span><span> </span><span>i</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>C&#39;_bl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>X2</span><span> </span><span>keep_watch_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>S</span><span> </span><span>x2&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>blit_final_in_dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_blit_wl L x1 x3 j w
        (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
          (1 -
          (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)))
        (keep_watch L j w S)
        &#8804; &#8659; ?unit
          (RETURN (fst X2, if get_conflict_l (fst X2) = None then n else 0))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>cond</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#} &#8744; 0 &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>loop_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (S&#39;, n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_pre L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((C&#39;, bL), b) &#8712; ?blit&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>C&#39;_bl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(C&#39;, bL) = (x1, x2&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x2&#39; =(x2, x3)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; x1 &#8713;# dom_m (get_clauses_wl S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S&#39; &#8800; {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, X2) &#8712; ?keep_watch&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>l_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L (snd X2) (fst X2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>wl_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_prop_body_wl_inv (keep_watch L j w S) j w L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(K, x) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712; Collect ((=) x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; {K. K &#8712; set (get_clauses_l (fst X2) &#8733; snd X2)}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S)) K &#8800; Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_l (fst X2)) x &#8800; Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_wl (keep_watch L j w S))
        (get_clauses_wl (keep_watch L j w S) &#8733; x1 !
        (1 -
          (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1))) =
      Some True&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity (get_trail_l (fst X2))
        (get_clauses_l (fst X2) &#8733; snd X2 !
        (1 - (if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1))) =
      Some True&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span> </span><span>x2&#39;</span><span> </span><span>x3</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>loop_inv</span><span> </span><span>cond</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_l_inv_def</span><span> </span><span>prod.case</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = (M, N, None, NE, UE, Q, W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dom&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 &#8712;# dom_m (get_clauses_wl (keep_watch L j w S)) &#10231; True&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SLW_dom&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by (keep_watch L j w S) L ! w)
        &#8712;# dom_m (get_clauses_wl (keep_watch L j w S))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw</span><span> </span><span>w_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correctly_marked_as_binary N (x1, N &#8733; x1 ! (Suc 0 - i), x3)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X2</span><span> </span><span>correctly_marked_as_binary</span><span> </span><span>l_inv</span><span> </span><span>x2&#39;</span><span> </span><span>C&#39;_bl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bL</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>remove_one_lit_from_wq_def</span><span> </span><span>correctly_marked_as_binary.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S_x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(keep_watch L j w S, x) &#8712; state_wl_l (Some (L, w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>unit_loop_inv</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L (fst (watched_by (keep_watch L j w S) L ! w))
      (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w)) x)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm
            (mset `# init_clss_lf (get_clauses_wl (keep_watch L j w S)) +
             get_unit_clauses_wl (keep_watch L j w S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L (keep_watch L j w S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by (keep_watch L j w S) L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl (keep_watch L j w S) = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wl_inv</span><span> </span><span>SLW_dom&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_alt_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>x_x&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_clauses_to_update_l
        (clauses_to_update_l
          (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
            x) +
          {#fst (watched_by (keep_watch L j w S) L ! w)#})
        (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w)) x),
        x&#39;) &#8712; twl_st_l (Some L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs x&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs x&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (watched_by (keep_watch L j w S) L ! w)
      &#8712;# dom_m
          (get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; fst (watched_by (keep_watch L j w S) L ! w)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; length
            (get_clauses_l
              (remove_one_lit_from_wq
                (fst (watched_by (keep_watch L j w S) L ! w)) x) &#8733;
            fst (watched_by (keep_watch L j w S) L ! w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup
        (get_trail_l
          (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
            x))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>ge0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(if get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x) &#8733;
          fst (watched_by (keep_watch L j w S) L ! w) !
          0 =
          L
        then 0 else 1)
      &lt; length
          (get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x) &#8733;
          fst (watched_by (keep_watch L j w S) L ! w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>ge1i</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;1 -
      (if get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x) &#8733;
          fst (watched_by (keep_watch L j w S) L ! w) !
          0 =
          L
        then 0 else 1)
      &lt; length
          (get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x) &#8733;
          fst (watched_by (keep_watch L j w S) L ! w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>L_watched</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set (watched_l
                (get_clauses_l
                  (remove_one_lit_from_wq
                    (fst (watched_by (keep_watch L j w S) L ! w)) x) &#8733;
                  fst (watched_by (keep_watch L j w S) L ! w)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l
        (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w)) x) =
      None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit_loop_inv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_l_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_one_lit_from_wq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except (Suc j) (Suc w) L (keep_watch L j w S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>corr_w</span><span> </span><span>correct_watching_except_correct_watching_except_Suc_Suc_keep_watch</span><span>
</span><span>          </span><span>j_w</span><span> </span><span>w_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = (if get_clauses_wl (keep_watch L j w S) &#8733; x1 ! 0 = L then 0 else 1)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = (if get_clauses_l (fst X2) &#8733; snd X2 ! 0 = L then 0 else 1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw</span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>X2</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw</span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>X2</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = (if get_clauses_l
            (remove_one_lit_from_wq (fst (watched_by (keep_watch L j w S) L ! w))
              x) &#8733;
          fst (watched_by (keep_watch L j w S) L ! w) !
          0 =
          L
        then 0 else 1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>S_x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv x&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs x&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;x. twl_st_inv
         (x, {#TWL_Clause (mset (watched_l (fst x)))
                (mset (unwatched_l (fst x)))
             . x &#8712;# init_clss_l N#},
          {#TWL_Clause (mset (watched_l (fst x))) (mset (unwatched_l (fst x)))
          . x &#8712;# learned_clss_l N#},
          None, NE, UE,
          add_mset
           (L, TWL_Clause (mset (watched_l (N &#8733; fst ((W L)[j := W L ! w] ! w))))
                (mset (unwatched_l (N &#8733; fst ((W L)[j := W L ! w] ! w)))))
           {#(L, TWL_Clause (mset (watched_l (N &#8733; x)))
                  (mset (unwatched_l (N &#8733; x))))
           . x &#8712;# remove1_mset (fst ((W L)[j := W L ! w] ! w))
                   {#i &#8712;# mset (drop w (map fst ((W L)[j := W L ! w]))).
                    i &#8712;# dom_m N#}#},
          Q)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_x&#39;</span><span> </span><span>S_x</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>twl_st_l_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>keep_watch_def</span><span>
</span><span>        </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>struct_wf_twl_cls.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv x&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs x&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;x. twl_st_inv
         (x, {#TWL_Clause (mset (watched_l (fst x)))
                (mset (unwatched_l (fst x)))
             . x &#8712;# init_clss_l N#},
          {#TWL_Clause (mset (watched_l (fst x))) (mset (unwatched_l (fst x)))
          . x &#8712;# learned_clss_l N#},
          None, NE, UE,
          add_mset
           (L, TWL_Clause (mset (watched_l (N &#8733; fst ((W L)[j := W L ! w] ! w))))
                (mset (unwatched_l (N &#8733; fst ((W L)[j := W L ! w] ! w)))))
           {#(L, TWL_Clause (mset (watched_l (N &#8733; x)))
                  (mset (unwatched_l (N &#8733; x))))
           . x &#8712;# remove1_mset (fst ((W L)[j := W L ! w] ! w))
                   {#i &#8712;# mset (drop w (map fst ((W L)[j := W L ! w]))).
                    i &#8712;# dom_m N#}#},
          Q)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_x&#39;</span><span> </span><span>S_x</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>twl_st_l_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>keep_watch_def</span><span>
</span><span>        </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>struct_wf_twl_cls.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball
       ({#TWL_Clause (mset (watched_l (fst x))) (mset (unwatched_l (fst x)))
        . x &#8712;# ran_m N#})
       struct_wf_twl_cls&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_inv.simps</span><span> </span><span>image_mset_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>all_clss_l_ran_m</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>distinct_N_x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct (N &#8733; x1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>ran_m_def</span><span> </span><span>mset_take_mset_drop_mset&#39;</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>watch_by_S_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;watched_by (keep_watch L j w S) L ! w = (x1, x2, x3)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;_bl</span><span> </span><span>x2&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_i</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = N &#8733; x1 ! i&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_watched</span><span> </span><span>ge0</span><span> </span><span>ge1i</span><span> </span><span>SLw</span><span> </span><span>S_x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;_bl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_2_if</span><span> </span><span>twl_st_wl</span><span> </span><span>S</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; length (N &#8733; x1)&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;1-i &lt; length (N &#8733; x1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>watch_by_S_w</span><span> </span><span>ge0</span><span> </span><span>ge1i</span><span> </span><span>S_x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>X2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;X2 = (set_clauses_to_update_l (remove1_mset x1 (clauses_to_update_l S&#39;)) S&#39;, x1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw</span><span> </span><span>X2</span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>X2</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N_x1_in_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8733; x1 ! (Suc 0 - i)
      &#8712;# all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span>i_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_m_def</span><span> </span><span>S</span><span> </span><span>all_lits_of_mm_add_mset</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_clause_in_all_lits_of_m</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((M, N, None, NE, UE, Q, W (L := (W L)[j := (x1, N &#8733; x1 ! (Suc 0 - i), x3)])),
       fst X2) &#8712; state_wl_l (Some (L, Suc w))&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>X2</span><span> </span><span>j_w</span><span> </span><span>w_le</span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>S</span><span> </span><span>keep_watch_def</span><span> </span><span>drop_map</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mset.simps</span><span> </span><span>image_mset_add_mset</span><span> </span><span>filter_mset_add_mset</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>p</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span class="delimiter">(</span><span>1</span><span>-</span><span>5</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>L_i</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n = size {#(i, _) &#8712;# mset (drop (Suc w) (watched_by S L)).
      i &#8713;# dom_m (get_clauses_wl S)#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span>n</span><span> </span><span>w_le</span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc 0 - i &#8800; i&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>i_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except (Suc j) (Suc w) L
        (M, N, None, NE, UE, Q, W(L := (W L)[j := (x1, N &#8733; x1 ! (Suc 0 - i), x3)]))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SLw</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C&#39;_bl</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>correct_watching_except_update_blit</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_x1_in_L</span><span> </span><span>corr</span><span> </span><span>i_le</span><span> </span><span>distinct_N_x1</span><span> </span><span>i_le</span><span> </span><span>bin</span><span> </span><span>x2&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>keep_watch_def</span><span> </span><span>L_i</span><span> </span><span>nth_eq_iff_index_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_w</span><span> </span><span>w_le</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>update_blit_wl_def</span><span> </span><span>keep_watch_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="var">?propa</span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?unit _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>trail_keep_w</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_int_alt_def</span><span>
</span><span>      </span><span>i_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>i_def&#39;</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>unit_propagation_inner_loop_body_l_with_skip_alt_def</span><span>
</span><span>      </span><span>unit_propagation_inner_loop_body_l_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;let _ = keep_watch _ _ _ _ in _&quot;</span></span></span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>SLw</span><span> </span><span>prod.case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;let _ = _ in let _ = get_clauses_l _ &#8733; _ ! _ in _&quot;</span></span></span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;if (&#172;_) then ASSERT _ &gt;&gt;= _ else _&#8250;</span></span></span><span> </span><span>if_not_swap</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>RETURN_as_SPEC_refine</span><span class="delimiter">[</span><span>refine2</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>50</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>val</span><span> </span><span>f</span><span> </span><span>f&#39;</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*r ef*)</span></span></span></span></span><span> </span><span>keep_watch</span><span> </span><span>find_unwatched_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inner_loop_inv</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_le</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>w_le</span><span> </span><span>j_w</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>blit_final</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>unit_prop_body_wl_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span> </span><span>n</span><span> </span><span>confl_S</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching_except_correct_watching_except_Suc_Suc_keep_watch</span><span>
</span><span>        </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>corr_w</span><span> </span><span>twl_st_wl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>blit_final_in_dom</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_prop_body_wl_find_unwatched_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span> </span><span>f</span><span> </span><span>x&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conflict_final</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>propa_final</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span> </span><span>f</span><span> </span><span>x&#39;</span><span> </span><span>xa</span><span> </span><span>x&#39;a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_blit_wl_final</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>X2</span><span> </span><span>K</span><span> </span><span>x</span><span> </span><span>f</span><span> </span><span>x&#39;</span><span> </span><span>xa</span><span> </span><span>x&#39;a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_clss_final</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset a (remove1_mset a M) = M &#10231; a &#8712;# M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>M</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ab_semigroup_add_class.add.commute</span><span> </span><span>add.left_neutral</span><span> </span><span>multi_self_add_other_not_self</span><span>
</span><span>       </span><span>remove1_mset_eqE</span><span> </span><span>union_mset_add_mset_left</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?eq</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_l_inv L C&#39; T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv</span><span class="delimiter">]</span><span> </span><span>i_le2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv</span><span class="delimiter">]</span><span> </span><span>C&#39;_dom</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv</span><span class="delimiter">]</span><span> </span><span>S_S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_m_clause_upd</span><span> </span><span>image_mset_remove1_mset_if</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>w</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39; &#8801; fst (watched_by S L ! w)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8801; remove_one_lit_from_wq C&#39; S&#39;&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#39;&#39; &#8801; get_clauses_l S&#39; &#8733; C&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>S_S&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; state_wl_l (Some (L, w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &lt; length (watched_by S L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>j_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8804; w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>corr_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inner_loop_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_inv L (j, w, S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n = size (filter_mset (&#955;(i, _). i &#8713;# dom_m (get_clauses_wl S)) (mset (drop w (watched_by S L))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl_S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S = None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>unit_propagation_inner_loop_body_wl_spec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_body_wl L j w S &#8804;
    &#8659;{((i, j, T&#39;), (T, n)).
        (T&#39;, T) &#8712; state_wl_l (Some (L, j)) &#8743;
        correct_watching_except i j L T&#39; &#8743;
        j &#8804; length (watched_by T&#39; L) &#8743;
        length (watched_by S L) =  length (watched_by T&#39; L) &#8743;
        i &#8804; j &#8743;
        (get_conflict_wl T&#39; = None &#10230;
           n = size (filter_mset (&#955;(i, _). i &#8713;# dom_m (get_clauses_wl T&#39;)) (mset (drop j (watched_by T&#39; L))))) &#8743;
        (get_conflict_wl T&#39; &#8800; None &#10230; n = 0)}
     (unit_propagation_inner_loop_body_l_with_skip L (S&#39;, n))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>unit_propagation_inner_loop_body_wl_wl_int</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S_S&#39;</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span> </span><span>corr_w</span><span> </span><span>inner_loop_inv</span><span> </span><span>n</span><span>
</span><span>       </span><span>confl_S</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Down_id_eq</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>unit_propagation_inner_loop_body_wl_int_spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S_S&#39;</span><span> </span><span>w_le</span><span> </span><span>j_w</span><span> </span><span>corr_w</span><span> </span><span>inner_loop_inv</span><span> </span><span>n</span><span>
</span><span>       </span><span>confl_S</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop</span><span>
</span><span>   </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v twl_st_wl &#8658; (nat &#215; nat &#215; &#39;v twl_st_wl) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop L S<span class="hidden">&#8681;</span><sub>0</sub> = do {
    let n = length (watched_by S<span class="hidden">&#8681;</span><sub>0</sub> L);
    WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>unit_propagation_inner_loop_wl_loop_inv L<span class="hidden">&#8662;</span></sup>
      (&#955;(j, w, S). w &lt; n &#8743; get_conflict_wl S = None)
      (&#955;(j, w, S). do {
        unit_propagation_inner_loop_body_wl L j w S
      })
      (0, 0, S<span class="hidden">&#8681;</span><sub>0</sub>)
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_except_correct_watching_cut_watch</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_except j w L (a, b, c, d, e, f, g)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching (a, b, c, d, e, f, g(L := take j (g L) @ drop w (g L)))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>Heq</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La i K b&#39;. La &#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233;
      (La = L &#10230;
       distinct_watched (take j (g La) @ drop w (g La)) &#8743;
       ((i, K, b&#39;)&#8712;#mset (take j (g La) @ drop w (g La)) &#10230;
           i &#8712;# dom_m b &#10230; K &#8712; set (b &#8733; i) &#8743; K &#8800; La &#8743; correctly_marked_as_binary b (i, K, b&#39;)) &#8743;
       ((i, K, b&#39;)&#8712;#mset (take j (g La) @ drop w (g La)) &#10230;
           b&#39; &#10230; i &#8712;# dom_m b) &#8743;
       {#i &#8712;# fst `# mset (take j (g La) @ drop w (g La)). i &#8712;# dom_m b#} =
       clause_to_update La (a, b, c, d, e, {#}, {#}))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>Hneq</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;La i K b&#39;. La&#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e)) &#10233;
      (La &#8800; L &#10230;
       distinct_watched (g La) &#8743;
       ((i, K, b&#39;)&#8712;#mset (g La) &#10230; i &#8712;# dom_m b &#10230; K &#8712; set (b &#8733; i) &#8743; K &#8800; La
          &#8743; correctly_marked_as_binary b (i, K, b&#39;)) &#8743;
        ((i, K, b&#39;)&#8712;#mset (g La) &#10230; b&#39; &#10230; i &#8712;# dom_m b) &#8743;
       {#i &#8712;# fst `# mset (g La). i &#8712;# dom_m b#} =
       clause_to_update La (a, b, c, d, e, {#}, {#}))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching.simps</span><span> </span><span>correct_watching_except.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((i, K, b&#39;)&#8712;#mset ((g(L := take j (g L) @ drop w (g L))) La) &#10233;
            i &#8712;# dom_m b &#10230; K &#8712; set (b &#8733; i) &#8743; K &#8800; La &#8743; correctly_marked_as_binary b (i, K, b&#39;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(i, K, b&#39;)&#8712;#mset ((g(L := take j (g L) @ drop w (g L))) La) &#10233;
            b&#39; &#10230; i &#8712;# dom_m b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#i &#8712;# fst `# mset ((g(L := take j (g L) @ drop w (g L))) La).
         i &#8712;# dom_m b#} =
        clause_to_update La (a, b, c, d, e, {#}, {#})&#8250;</span></span></span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_watched ((g(L := take j (g L) @ drop w (g L))) La)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La&#8712;#all_lits_of_mm (mset `# ran_mf b + (d + e))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>La</span><span> </span><span>i</span><span> </span><span>K</span><span> </span><span>b&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span>i</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span>i</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span>i</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span>i</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span>i</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span>i</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La = L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Heq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span>i</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Hneq</span><span class="delimiter">[</span><span>of</span><span> </span><span>La</span><span> </span><span>i</span><span> </span><span>K</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop L S<span class="hidden">&#8681;</span><sub>0</sub> = do {
    let (_ :: nat) = (if get_conflict_wl S<span class="hidden">&#8681;</span><sub>0</sub> = None then remaining_nondom_wl 0 L S<span class="hidden">&#8681;</span><sub>0</sub> else 0);
    let n = length (watched_by S<span class="hidden">&#8681;</span><sub>0</sub> L);
    WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>unit_propagation_inner_loop_wl_loop_inv L<span class="hidden">&#8662;</span></sup>
      (&#955;(j, w, S). w &lt; n &#8743; get_conflict_wl S = None)
      (&#955;(j, w, S). do {
        unit_propagation_inner_loop_body_wl L j w S
      })
      (0, 0, S<span class="hidden">&#8681;</span><sub>0</sub>)
  }
  &#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop_def</span><span> </span><span>Let_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cut_watch_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; nat &#8658; &#39;v literal &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cut_watch_list j w L =(&#955;(M, N, D, NE, UE, Q, W). do {
      ASSERT(j &#8804; w &#8743; j &#8804; length (W L) &#8743; w &#8804; length (W L));
      RETURN (M, N, D, NE, UE, Q, W(L := take j (W L) @ drop w (W L)))
    })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_propagation_inner_loop_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl L S<span class="hidden">&#8681;</span><sub>0</sub> = do {
     (j, w, S) &#8592; unit_propagation_inner_loop_wl_loop L S<span class="hidden">&#8681;</span><sub>0</sub>;
     ASSERT(j &#8804; w &#8743; w &#8804; length (watched_by S L));
     cut_watch_list j w L S
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_correct_watching_except00</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S &#10233; correct_watching_except 0 0 L S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>correct_watching.simps</span><span> </span><span>correct_watching_except.simps</span><span>
</span><span>    </span><span>take0</span><span> </span><span>drop0</span><span> </span><span>append.left_neutral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unit_propagation_inner_loop_wl_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry unit_propagation_inner_loop_wl, uncurry unit_propagation_inner_loop_l) &#8712;
    {((L&#39;, T&#39;::&#39;v twl_st_wl), (L, T::&#39;v twl_st_l)). L = L&#39; &#8743; (T&#39;, T) &#8712; state_wl_l (Some (L, 0)) &#8743;
      correct_watching T&#39;} &#8594;
    &#10216;{(T&#39;, T). (T&#39;, T) &#8712; state_wl_l None &#8743; correct_watching T&#39;}&#10217; nres_rel
    &#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?fg &#8712; ?A &#8594; &#10216;?B&#10217;nres_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?fg &#8712; ?A &#8594; &#10216;{(T&#39;, T). _ &#8743; ?P T T&#39;}&#10217;nres_rel&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>corr_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; state_wl_l (Some (L, 0))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;To ease the finding the correspondence between the body of the loops, we introduce
      following function:&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{((i, j, T&#39;), (T, n)).
        (T&#39;, T) &#8712; state_wl_l (Some (L, j)) &#8743;
        correct_watching_except i j L T&#39; &#8743;
        j &#8804; length (watched_by T&#39; L) &#8743;
        length (watched_by S L) =  length (watched_by T&#39; L) &#8743;
        i &#8804; j &#8743;
        (get_conflict_wl T&#39; = None &#10230;
           n = size (filter_mset (&#955;(i, _). i &#8713;# dom_m (get_clauses_wl T&#39;)) (mset (drop j (watched_by T&#39; L))))) &#8743;
        (get_conflict_wl T&#39; &#8800; None &#10230; n = 0)}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl_loop_inv L iT&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>        </span><span>iT&#39;_Tn</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(iT&#39;, Tn) &#8712; ?R&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L Tn&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Tn</span><span> </span><span>iT&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>iT&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;iT&#39; = (i, j, T&#39;)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>iT&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Tn</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Tn = (T, n)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Tn</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (T, 0::nat)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l_inv L (T, n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l T &#8800; None&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>iT&#39;_Tn</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_l_inv_def</span><span> </span><span>iT&#39;</span><span> </span><span>prod.case</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop_inv_def</span><span> </span><span>iT&#39;</span><span> </span><span>prod.simps</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>T</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>iT&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cond</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(j &lt; length (watched_by S L) &#8743; get_conflict_wl T&#39; = None) =
      (clauses_to_update_l T &#8800; {#} &#8744; n &gt; 0)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>        </span><span>iT&#39;_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(ijT&#39;, Tn) &#8712; ?R&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ijT&#39; = (i, jT&#39;)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;jT&#39; = (j, T&#39;)&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Tn = (T, n)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>ijT&#39;</span><span> </span><span>Tn</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>T&#39;</span><span> </span><span>n</span><span> </span><span>T</span><span> </span><span>jT&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size {#(i, _) &#8712;# mset (drop j xs). i &#8713;# dom_m b#} =
        size {#i &#8712;# fst `# mset (drop j xs). i &#8713;# dom_m b#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xs&#8250;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>xs</span><span> </span><span>j</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>p</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (filter_mset (&#955;i. (i &#8712;# (dom_m b))) (fst `# (mset (drop j (g L))))) +
          size {#i &#8712;# fst `# mset (drop j (g L)). i &#8713;# dom_m b#} =
          length (g L) - j&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span>j</span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>size_union</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>multiset_partition</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8800; {#} &#10233; size A &gt; 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (watched_by T&#39; L) = size (clauses_to_update_wl T&#39; L j) + n + j&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl T&#39; = None&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>iT&#39;_T</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl T&#39;&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>drop_map</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>iT&#39;_T</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl T&#39; = None&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>remaining</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN (if get_conflict_wl S = None then remaining_nondom_wl 0 L S else 0) &#8804; SPEC (&#955;_. True)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit_propagation_inner_loop_l_alt_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_l L S&#39; = do {
        n &#8592; SPEC (&#955;_::nat. True);
        (S, n) &#8592; WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>unit_propagation_inner_loop_l_inv L<span class="hidden">&#8662;</span></sup>
              (&#955;(S, n). clauses_to_update_l S &#8800; {#} &#8744; 0 &lt; n)
              (unit_propagation_inner_loop_body_l_with_skip L) (S&#39;, n);
        RETURN S}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>S&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_l_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unit_propagation_inner_loop_wl_alt_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl L S = do {
      let (n::nat) = (if get_conflict_wl S = None then remaining_nondom_wl 0 L S else 0);
      (j, w, S) &#8592; WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>unit_propagation_inner_loop_wl_loop_inv L<span class="hidden">&#8662;</span></sup>
         (&#955;(j, w, T). w &lt; length (watched_by S L)  &#8743; get_conflict_wl T = None)
         (&#955;(j, x, y). unit_propagation_inner_loop_body_wl L j x y) (0, 0, S);
      ASSERT (j &#8804; w &#8743; w &#8804; length (watched_by S L));
      cut_watch_list j w L S}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_wl_loop_alt_def</span><span> </span><span>unit_propagation_inner_loop_wl_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_inner_loop_wl L S &#8804;
            &#8659; {((T&#39;), T). (T&#39;, T) &#8712; state_wl_l None &#8743; ?P T T&#39;}
              (unit_propagation_inner_loop_l L S&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?R _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_inner_loop_l_alt_def</span><span> </span><span>uncurry_def</span><span>
</span><span>        </span><span>unit_propagation_inner_loop_wl_alt_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>WHILEIT_refine_genR</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>            </span><span>R&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?R&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span>R</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{((i, j, T&#39;), (T, n)). ((i, j, T&#39;), (T, n)) &#8712; ?R&#39; &#8743; i &#8804; j &#8743;
                length (watched_by S L) =  length (watched_by T&#39; L) &#8743;
               (j &#8805; length (watched_by T&#39; L) &#8744; get_conflict_wl T&#39; &#8800; None)}&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>remaining</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr_w</span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching_correct_watching_except00</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cond</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span>i&#39;w&#39;T&#39;</span><span> </span><span>Tn</span><span> </span><span>i&#39;</span><span> </span><span>w&#39;T&#39;</span><span> </span><span>w&#39;</span><span> </span><span>T&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Tn</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>unit_propagation_inner_loop_body_wl_spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst Tn&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>prod.case</span><span> </span><span>in_pair_collect_simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>twl_st_of_wl.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span>i&#39;w&#39;T&#39;</span><span> </span><span>Tn</span><span> </span><span>i&#39;</span><span> </span><span>w&#39;T&#39;</span><span> </span><span>j</span><span> </span><span>L&#39;</span><span> </span><span>w&#39;</span><span> </span><span>T&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>cut_watch_list_def</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>correct_watching_except_correct_watching_cut_watch</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>H</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fref_param1</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>H</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Outer loop&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>select_and_remove_from_literals_to_update_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; (&#39;v twl_st_wl &#215; &#39;v literal) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;select_and_remove_from_literals_to_update_wl S = SPEC(&#955;(S&#39;, L). L &#8712;# literals_to_update_wl S &#8743;
     S&#39; = set_literals_to_update_wl (literals_to_update_wl S - {#L#}) S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_propagation_outer_loop_wl_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_outer_loop_wl_inv S &#10231;
    (&#8707;S&#39;. (S, S&#39;) &#8712; state_wl_l None &#8743;
      correct_watching S &#8743;
      unit_propagation_outer_loop_l_inv S&#39;)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unit_propagation_outer_loop_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_outer_loop_wl S<span class="hidden">&#8681;</span><sub>0</sub> =
    WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>unit_propagation_outer_loop_wl_inv<span class="hidden">&#8662;</span></sup>
      (&#955;S. literals_to_update_wl S &#8800; {#})
      (&#955;S. do {
        ASSERT(literals_to_update_wl S &#8800; {#});
        (S&#39;, L) &#8592; select_and_remove_from_literals_to_update_wl S;
        ASSERT(L &#8712;# all_lits_of_mm (mset `# ran_mf (get_clauses_wl S&#39;) + get_unit_clauses_wl S&#39;));
        unit_propagation_inner_loop_wl L S&#39;
      })
      (S<span class="hidden">&#8681;</span><sub>0</sub> :: &#39;v twl_st_wl)
&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unit_propagation_outer_loop_wl_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(unit_propagation_outer_loop_wl, unit_propagation_outer_loop_l)
 &#8712; {(T&#39;::&#39;v twl_st_wl, T).
       (T&#39;, T) &#8712; state_wl_l None &#8743;
       correct_watching T&#39;} &#8594;<span class="hidden">&#8681;</span><sub>f</sub>
    &#10216;{(T&#39;, T).
       (T&#39;, T) &#8712; state_wl_l None &#8743;
       correct_watching T&#39;}&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?u &#8712; ?A &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;?B&#10217; nres_rel&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_outer_loop_wl_inv T&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T&#39;, T) &#8712; {(T&#39;, T). (T&#39;, T) &#8712; state_wl_l None &#8743; correct_watching T&#39;}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_outer_loop_l_inv T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>T&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_outer_loop_wl_inv_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>T</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>select_and_remove_from_literals_to_update_wl</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;select_and_remove_from_literals_to_update_wl S&#39; &#8804;
     &#8659; {((T&#39;, L&#39;), (T, L)). L = L&#39; &#8743; (T&#39;, T) &#8712; state_wl_l (Some (L, 0)) &#8743;
         T&#39; = set_literals_to_update_wl (literals_to_update_wl S&#39; - {#L#}) S&#39; &#8743; L &#8712;# literals_to_update_wl S&#39; &#8743;
         L &#8712;# all_lits_of_mm (mset `# ran_mf (get_clauses_wl S&#39;) + get_unit_clauses_wl S&#39;)
       }
       (select_and_remove_from_literals_to_update S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; state_wl_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S&#39; = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>corr_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>inv_l</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_outer_loop_l_inv S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>D</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>W</span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S&#39; = (M, N, D, NE, UE, Q, W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>R</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S_R</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, R) &#8712; twl_st_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs R&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_l</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_outer_loop_l_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* &#8249;trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of R) = convert_lits_l N M&#8250; *)</span></span></span></span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of R) = mset `# (init_clss_lf N) + NE&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_R</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span> </span><span>S&#39;</span><span> </span><span>twl_st_wl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>no_dup_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued R&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (state<span class="hidden">&#8681;</span><sub>W</sub>_of R)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>          </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# ran_mf N + NE + UE)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>LQ</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# Q&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f o g) ` I = f ` g ` I&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span>g</span><span> </span><span>I</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = - lit_of K&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712;# mset (trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of R))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>no_dup_q</span><span> </span><span>LQ</span><span> </span><span>S_R</span><span> </span><span>S</span><span>
</span><span>        </span><span>mset_le_add_mset_decr_left2</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset L Q&#8250;</span></span></span><span> </span><span>Q</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S&#39;</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>          </span><span>all_lits_of_mm_def</span><span> </span><span>atms_of_ms_def</span><span> </span><span>twl_st_l_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>          </span><span>convert_lit.simps</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span>mset_subset_eq_insertD</span><span> </span><span>in_convert_lits_lD2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of o lit_of&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8712; atm_of ` lits_of_l (get_trail_wl S&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of ` lits_of_l (trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of R)) = atm_of ` lits_of_l (get_trail_wl S&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_R</span><span> </span><span>S</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = - lit_of K&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span> </span><span>image_image</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span>lits_of_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8712; atm_of ` lits_of_l M&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S&#39;</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of ` lits_of_l M
         &#8838; (&#8899;x&#8712;set_mset (init_clss_lf N). atm_of ` set x) &#8746;
           (&#8899;x&#8712;set_mset NE. atms_of x) &#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>alien</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S&#39;</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>              </span><span>all_lits_of_mm_def</span><span> </span><span>atms_of_ms_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of ` lits_of_l M &#8838; (&#8899;x&#8712;set_mset (init_clss_lf N). atm_of ` set x) &#8746;
           (&#8899;x&#8712;set_mset NE. atms_of x)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_Un</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span>set_append</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>            </span><span>append_take_drop_id</span><span>
</span><span>            </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of ` lits_of_l M &#8838; atms_of_mm (mset `# init_clss_lf N + NE)&#8250;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>UN_Un</span><span> </span><span>Un_iff</span><span> </span><span>append_take_drop_id</span><span> </span><span>atms_of_ms_def</span><span> </span><span>atms_of_ms_mset_unfold</span><span> </span><span>set_append</span><span>
</span><span>                </span><span>set_image_mset</span><span> </span><span>set_mset_mset</span><span> </span><span>set_mset_union</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8712; atms_of_mm (mset `# ran_mf N + NE)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_lits_of_mm_union</span><span> </span><span>atms_of_ms_union</span><span> </span><span>all_clss_lf_ran_m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>image_mset_union</span><span> </span><span>set_mset_union</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_all_lits_of_mm_ain_atms_of_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause_to_update L S = {#i &#8712;# fst `# mset (W L). i &#8712;# dom_m N#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# all_lits_of_mm (mset `# ran_mf N + NE + UE)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# Q&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr_w</span><span> </span><span>that</span><span> </span><span>S</span><span> </span><span>H1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching.simps</span><span> </span><span>S&#39;</span><span> </span><span>clause_to_update_def</span><span>
</span><span>        </span><span>Ball_def</span><span> </span><span>ac_simps</span><span> </span><span>all_conj_distrib</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>select_and_remove_from_literals_to_update_wl_def</span><span> </span><span>select_and_remove_from_literals_to_update_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RES_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Bex_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_clauses_to_update_l (clause_to_update (snd s) S)
              (set_literals_to_update_l
                (remove1_mset (snd s) (literals_to_update_l S)) S), snd s)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching.simps</span><span> </span><span>clauses_def</span><span> </span><span>state_wl_l_def</span><span>
</span><span>          </span><span>mset_take_mset_drop_mset&#39;</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>all_lits_of_mm_union</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">:</span><span> </span><span>H</span><span> </span><span>H1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conflict_None</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl T = None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update_wl T &#8800; {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>inv1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_outer_loop_wl_inv T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, T&#39;) &#8712; state_wl_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>inv2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_outer_loop_l_inv T&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_outer_loop_wl_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T&#39;, T&#39;&#39;) &#8712; twl_st_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#39;&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_outer_loop_l_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict T&#39;&#39; &#8800; None &#10230;
       clauses_to_update T&#39;&#39; = {#} &#8743; literals_to_update T&#39;&#39; = {#}&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unit_propagation_outer_loop_wl_def</span><span> </span><span>unit_propagation_outer_loop_l_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>select_and_remove_from_literals_to_update_wl</span><span>
</span><span>      </span><span>unit_propagation_inner_loop_wl_spec</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>fref_param1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fref_to_Down_curry</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conflict_None</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T&#39;</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_wl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decide or Skip&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_unassigned_lit_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v literal option nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_unassigned_lit_wl = (&#955;(M, N, D, NE, UE, WS, Q).
     SPEC (&#955;L.
         (L &#8800; None &#10230;
            undefined_lit M (the L) &#8743;
            atm_of (the L) &#8712; atms_of_mm (clause `# twl_clause_of `# init_clss_lf N + NE)) &#8743;
         (L = None &#10230; (&#8708;L&#39;. undefined_lit M L&#39; &#8743;
            atm_of L&#39; &#8712; atms_of_mm (clause `# twl_clause_of `# init_clss_lf N + NE))))
     )&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>decide_wl_or_skip_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;decide_wl_or_skip_pre S &#10231;
  (&#8707;S&#39;. (S, S&#39;) &#8712; state_wl_l None &#8743;
   decide_l_or_skip_pre S&#39;
  )&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>decide_lit_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;decide_lit_wl = (&#955;L&#39; (M, N, D, NE, UE, Q, W).
      (Decided L&#39; # M, N, D, NE, UE, {#- L&#39;#}, W))&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>decide_wl_or_skip</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; (bool &#215; &#39;v twl_st_wl) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;decide_wl_or_skip S = (do {
    ASSERT(decide_wl_or_skip_pre S);
    L &#8592; find_unassigned_lit_wl S;
    case L of
      None &#8658; RETURN (True, S)
    | Some L &#8658; RETURN (False, decide_lit_wl L S)
  })
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decide_wl_or_skip_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(decide_wl_or_skip, decide_l_or_skip)
    &#8712; {(T&#39;:: &#39;v twl_st_wl, T).
          (T&#39;, T) &#8712; state_wl_l None &#8743;
          correct_watching T&#39; &#8743;
          get_conflict_wl T&#39; = None} &#8594;
        &#10216;{((b&#39;, T&#39;), (b, T)). b&#39; = b &#8743;
         (T&#39;, T) &#8712; state_wl_l None &#8743;
          correct_watching T&#39;}&#10217;nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>find_unassigned_lit_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_unassigned_lit_wl S&#39;
    &#8804; &#8659; Id
        (find_unassigned_lit_l S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; state_wl_l None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>find_unassigned_lit_wl_def</span><span> </span><span>find_unassigned_lit_l_def</span><span>
</span><span>        </span><span>mset_take_mset_drop_mset&#39;</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>option</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, x&#39;) &#8712; &#10216;Id&#10217;option_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = x&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>x&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decide_wl_or_skip_def</span><span> </span><span>decide_l_or_skip_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>find_unassigned_lit_wl</span><span> </span><span>option</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decide_wl_or_skip_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>S&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching.simps</span><span> </span><span>clause_to_update_def</span><span>
</span><span>          </span><span>decide_lit_l_def</span><span> </span><span>decide_lit_wl_def</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Skip or Resolve&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tl_state_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_state_wl = (&#955;(M, N, D, NE, UE, WS, Q). (tl M, N, D, NE, UE, WS, Q))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>resolve_cls_wl&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; nat &#8658; &#39;v literal &#8658; &#39;v clause&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve_cls_wl&#39; S C L  =
   remove1_mset L (remove1_mset (-L) (the (get_conflict_wl S) &#8746;# (mset (get_clauses_wl S &#8733; C))))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update_confl_tl_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; &#39;v literal &#8658; &#39;v twl_st_wl &#8658; bool &#215; &#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_confl_tl_wl = (&#955;C L (M, N, D, NE, UE, WS, Q).
     let D = resolve_cls_wl&#39; (M, N, D, NE, UE, WS, Q) C L in
        (False, (tl M, N, Some D, NE, UE, WS, Q)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>skip_and_resolve_loop_wl_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; bool &#8658; &#39;v twl_st_wl &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;skip_and_resolve_loop_wl_inv S<span class="hidden">&#8681;</span><sub>0</sub> brk S &#10231;
    (&#8707;S&#39; S&#39;<span class="hidden">&#8681;</span><sub>0</sub>. (S, S&#39;) &#8712; state_wl_l None &#8743;
      (S<span class="hidden">&#8681;</span><sub>0</sub>, S&#39;<span class="hidden">&#8681;</span><sub>0</sub>) &#8712; state_wl_l None &#8743;
     skip_and_resolve_loop_inv_l S&#39;<span class="hidden">&#8681;</span><sub>0</sub> brk S&#39; &#8743;
        correct_watching S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>skip_and_resolve_loop_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;skip_and_resolve_loop_wl S<span class="hidden">&#8681;</span><sub>0</sub> =
    do {
      ASSERT(get_conflict_wl S<span class="hidden">&#8681;</span><sub>0</sub> &#8800; None);
      (_, S) &#8592;
        WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>&#955;(brk, S). skip_and_resolve_loop_wl_inv S<span class="hidden">&#8681;</span><sub>0</sub> brk S<span class="hidden">&#8662;</span></sup>
        (&#955;(brk, S). &#172;brk &#8743; &#172;is_decided (hd (get_trail_wl S)))
        (&#955;(_, S).
          do {
            let D&#39; = the (get_conflict_wl S);
            let (L, C) = lit_and_ann_of_propagated (hd (get_trail_wl S));
            if -L &#8713;# D&#39; then
              do {RETURN (False, tl_state_wl S)}
            else
              if get_maximum_level (get_trail_wl S) (remove1_mset (-L) D&#39;) = count_decided (get_trail_wl S)
              then
                do {RETURN (update_confl_tl_wl C L S)}
              else
                do {RETURN (True, S)}
          }
        )
        (False, S<span class="hidden">&#8681;</span><sub>0</sub>);
      RETURN S
    }
  &#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_state_wl_tl_state_l</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; state_wl_l None &#10233; (tl_state_wl S, tl_state_l S&#39;) &#8712; state_wl_l None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>tl_state_wl_def</span><span> </span><span>tl_state_l_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skip_and_resolve_loop_wl_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(skip_and_resolve_loop_wl, skip_and_resolve_loop_l)
    &#8712; {(T&#39;::&#39;v twl_st_wl, T).
         (T&#39;, T) &#8712; state_wl_l None &#8743;
          correct_watching T&#39; &#8743;
          0 &lt; count_decided (get_trail_wl T&#39;)} &#8594;
      &#10216;{(T&#39;, T).
         (T&#39;, T) &#8712; state_wl_l None &#8743;
          correct_watching T&#39;}&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?s &#8712; ?A &#8594; &#10216;?B&#10217;nres_rel&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>get_conflict_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((False, S&#39;), False, S)
    &#8712; Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> {(T&#39;, T). (T&#39;, T) &#8712; state_wl_l None &#8743; correct_watching T&#39;}&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8712; ?B&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; state_wl_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching (tl_state_wl S) = correct_watching S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching.simps</span><span> </span><span>tl_state_wl_def</span><span> </span><span>clause_to_update_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching  (tl aa, ca, da, ea, fa, ha, h) &#10231;
    correct_watching (aa, ca, None, ea, fa, ha, h)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>aa</span><span> </span><span>ba</span><span> </span><span>ca</span><span> </span><span>L</span><span> </span><span>da</span><span> </span><span>ea</span><span> </span><span>fa</span><span> </span><span>ha</span><span> </span><span>h</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching.simps</span><span> </span><span>tl_state_wl_def</span><span> </span><span>clause_to_update_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;NO_MATCH None da &#10233; correct_watching  (aa, ca, da, ea, fa, ha, h) &#10231;
    correct_watching (aa, ca, None, ea, fa, ha, h)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>aa</span><span> </span><span>ba</span><span> </span><span>ca</span><span> </span><span>L</span><span> </span><span>da</span><span> </span><span>ea</span><span> </span><span>fa</span><span> </span><span>ha</span><span> </span><span>h</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching.simps</span><span> </span><span>tl_state_wl_def</span><span> </span><span>clause_to_update_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>update_confl_tl_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
    (brkT, brkT&#39;) &#8712; bool_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> {(T&#39;, T). (T&#39;, T) &#8712; state_wl_l None &#8743; correct_watching T&#39;} &#10233;
    case brkT&#39; of (brk, S) &#8658; skip_and_resolve_loop_inv_l S&#39; brk S &#10233;
    brkT&#39; = (brk&#39;, T&#39;) &#10233;
    brkT = (brk, T) &#10233;
    lit_and_ann_of_propagated (hd (get_trail_l T&#39;)) = (L&#39;, C&#39;) &#10233;
    lit_and_ann_of_propagated (hd (get_trail_wl T)) = (L, C) &#10233;
    (update_confl_tl_wl C L T, update_confl_tl_l C&#39; L&#39; T&#39;) &#8712; bool_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> {(T&#39;, T).
         (T&#39;, T) &#8712; state_wl_l None &#8743; correct_watching T&#39;}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T&#39;</span><span> </span><span>brkT</span><span> </span><span>brk</span><span> </span><span>brkT&#39;</span><span> </span><span>brk&#39;</span><span> </span><span>T</span><span> </span><span>C</span><span> </span><span>C&#39;</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>update_confl_tl_wl_def</span><span> </span><span>update_confl_tl_l_def</span><span> </span><span>resolve_cls_wl&#39;_def</span><span> </span><span>resolve_cls_l&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;skip_and_resolve_loop_wl_inv S&#39; b&#39; T&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; ?A&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S&#39; &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>bt_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case bT of (x, xa) &#8658; skip_and_resolve_loop_inv_l S x xa&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(b&#39;T&#39;, bT) &#8712; ?B&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>b&#39;T&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b&#39;T&#39; = (b&#39;, T&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span>b&#39;T&#39;</span><span> </span><span>bT</span><span> </span><span>b&#39;</span><span> </span><span>T&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bT</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bT = (b, T)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>bT</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>skip_and_resolve_loop_wl_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>T</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>S</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bT</span><span> </span><span>b&#39;T&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?s &#8712; ?A &#8594; &#10216;{(T&#39;, T). (T&#39;, T) &#8712; state_wl_l None &#8743; correct_watching T&#39;}&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>skip_and_resolve_loop_wl_def</span><span> </span><span>skip_and_resolve_loop_l_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>get_conflict_wl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>tl_state_wl_tl_state_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span>b&#39;T&#39;</span><span> </span><span>bT</span><span> </span><span>b&#39;</span><span> </span><span>T&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_confl_tl_wl</span><span class="delimiter">)</span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>correct_watching.simps</span><span> </span><span>clause_to_update_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Backtrack&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_decomp_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_decomp_wl =  (&#955;L (M, N, D, NE, UE, Q, W).
    SPEC(&#955;S. &#8707;K M2 M1. S = (M1, N, D, NE, UE, Q, W) &#8743; (Decided K # M1, M2) &#8712; set (get_all_ann_decomposition M) &#8743;
          get_level M K = get_maximum_level M (the D - {#-L#}) + 1))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_lit_of_max_level_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v literal &#8658; &#39;v literal nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_lit_of_max_level_wl =  (&#955;(M, N, D, NE, UE, Q, W) L.
    SPEC(&#955;L&#39;. L&#39; &#8712;# remove1_mset (-L) (the D) &#8743; get_level M L&#39; = get_maximum_level M (the D - {#-L#})))&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>extract_shorter_conflict_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_shorter_conflict_wl (M, N, D, NE, UE, Q, W) = SPEC(&#955;S.
     &#8707;D&#39;. D&#39; &#8838;# the D &#8743; S = (M, N, Some D&#39;, NE, UE, Q, W) &#8743;
     clause `# twl_clause_of `# ran_mf N + NE + UE &#8872;pm D&#39; &#8743; -(lit_of (hd M)) &#8712;# D&#39;)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>extract_shorter_conflict_wl.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>extract_shorter_conflict_wl_def</span><span> </span><span class="delimiter">=</span><span> </span><span>extract_shorter_conflict_wl.simps</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>backtrack_wl_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_wl_inv S &#10231; (&#8707;S&#39;. (S, S&#39;) &#8712; state_wl_l None &#8743; backtrack_l_inv S&#39; &#8743; correct_watching S)
  &#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Rougly: we get a fresh index that has not yet been used.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_fresh_index_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clauses_l &#8658; _ &#8658; _ &#8658; nat nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_fresh_index_wl N NUE W = SPEC(&#955;i. i &gt; 0 &#8743; i &#8713;# dom_m N &#8743;
   (&#8704;L &#8712;# all_lits_of_mm (mset `# ran_mf N + NUE) . i &#8713; fst ` set (W L)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>propagate_bt_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v literal &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_bt_wl = (&#955;L L&#39; (M, N, D, NE, UE, Q, W). do {
    D&#39;&#39; &#8592; list_of_mset (the D);
    i &#8592; get_fresh_index_wl N (NE + UE) W;
    let b = (length ([-L, L&#39;] @ (remove1 (-L) (remove1 L&#39; D&#39;&#39;))) = 2);
    RETURN (Propagated (-L) i # M,
        fmupd i ([-L, L&#39;] @ (remove1 (-L) (remove1 L&#39; D&#39;&#39;)), False) N,
          None, NE, UE, {#L#}, W(-L:= W (-L) @ [(i, L&#39;, b)], L&#39;:= W L&#39; @ [(i, -L, b)]))
      })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>propagate_unit_bt_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v twl_st_wl &#8658; &#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_unit_bt_wl = (&#955;L (M, N, D, NE, UE, Q, W).
    (Propagated (-L) 0 # M, N, None, NE, add_mset (the D) UE, {#L#}, W))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>backtrack_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_wl S =
    do {
      ASSERT(backtrack_wl_inv S);
      let L = lit_of (hd (get_trail_wl S));
      S &#8592; extract_shorter_conflict_wl S;
      S &#8592; find_decomp_wl L S;

      if size (the (get_conflict_wl S)) &gt; 1
      then do {
        L&#39; &#8592; find_lit_of_max_level_wl S L;
        propagate_bt_wl L L&#39; S
      }
      else do {
        RETURN (propagate_unit_bt_wl L S)
     }
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_watching_learn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>L1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L1 &#8712; atms_of_mm (mset `# ran_mf N + NE)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L2 &#8712; atms_of_mm (mset `# ran_mf N + NE)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>UW</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of (mset UW) &#8838; atms_of_mm (mset `# ran_mf N + NE)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i_dom</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8713;# dom_m N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>fresh</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L. L&#8712;#all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10233; i &#8713; fst ` set (W L)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L1 &#8800; L2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>b</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &#10231; length (L1 # L2 # UW) = 2&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching (K # M, fmupd i (L1 # L2 # UW, b&#39;) N,
    D, NE, UE, Q, W (L1 := W L1 @ [(i, L2, b)], L2 := W L2 @ [(i, L1, b)])) &#10231;
  correct_watching (M, N, D, NE, UE, Q&#39;, W)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?l &#10231; ?c&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching (_, ?N, _) = _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L2 &#8800; L1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L1 &#8800; L2&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>eq_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause_to_update L1 (M, fmupd i (L1 # L2 # UW, b&#39;) N, D, NE, UE, {#}, {#}) =
         add_mset i (clause_to_update L1 (M, N, D, NE, UE, {#}, {#}))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L2</span><span> </span><span>UW</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_dom</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clause_to_update_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>filter_mset_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause_to_update L2 (M, fmupd i (L1 # L2 # UW, b&#39;) N, D, NE, UE, {#}, {#}) =
         add_mset i (clause_to_update L2 (M, N, D, NE, UE, {#}, {#}))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L1</span><span> </span><span>UW</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_dom</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clause_to_update_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>filter_mset_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8800; L1 &#10233; x &#8800; L2 &#10233;
   clause_to_update x (M, fmupd i (L1 # L2 # UW, b&#39;) N, D, NE, UE, {#}, {#}) =
        clause_to_update x (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>UW</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_dom</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clause_to_update_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>filter_mset_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L1 &#8712;# all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE))&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L2 &#8712;# all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_dom</span><span> </span><span>L1</span><span> </span><span>L2</span><span> </span><span>UW</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_m_mapsto_upd_notin</span><span>
</span><span>      </span><span>all_lits_of_mm_add_mset</span><span> </span><span>all_lits_of_m_add_mset</span><span> </span><span>in_all_lits_of_m_ain_atms_of_iff</span><span>
</span><span>      </span><span>in_all_lits_of_mm_ain_atms_of_iff</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H&#39;</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#ia &#8712;# fst `# mset (W x). ia = i &#8744; ia &#8712;# dom_m N#} =  {#ia &#8712;# fst `# mset (W x). ia &#8712;# dom_m N#}&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_dom</span><span> </span><span>fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clause_to_update_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>filter_mset_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause_to_update L1 (K # M, N, D, NE, UE, {#}, {#}) = clause_to_update L1 (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L1</span><span> </span><span>N</span><span> </span><span>D</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>M</span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clause_to_update_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m ?N#} + (NE + UE))) =
    set_mset (all_lits_of_mm ({#mset (fst x). x &#8712;# ran_m N#} + (NE + UE)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_dom</span><span> </span><span>L1</span><span> </span><span>L2</span><span> </span><span>UW</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ran_m_mapsto_upd_notin</span><span>
</span><span>        </span><span>all_lits_of_mm_add_mset</span><span> </span><span>all_lits_of_m_add_mset</span><span> </span><span>in_all_lits_of_m_ain_atms_of_iff</span><span>
</span><span>        </span><span>in_all_lits_of_mm_ain_atms_of_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="var">?l</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L ia K&#39; b&#39;&#39;. (L&#8712;#all_lits_of_mm
        (mset `# ran_mf (fmupd i (L1 # L2 # UW, b&#39;) N) + (NE + UE)) &#10233;
      distinct_watched ((W(L1 := W L1 @ [(i, L2, b)], L2 := W L2 @ [(i, L1, b)])) L) &#8743;
      ((ia, K&#39;, b&#39;&#39;)&#8712;#mset ((W(L1 := W L1 @ [(i, L2, b)], L2 := W L2 @ [(i, L1, b)])) L) &#10230;
          ia &#8712;# dom_m (fmupd i (L1 # L2 # UW, b&#39;) N) &#10230;
          K&#39; &#8712; set (fmupd i (L1 # L2 # UW, b&#39;) N &#8733; ia) &#8743; K&#39; &#8800; L &#8743;
          correctly_marked_as_binary (fmupd i (L1 # L2 # UW, b&#39;) N) (ia, K&#39;, b&#39;&#39;) ) &#8743;
      ((ia, K&#39;, b&#39;&#39;)&#8712;#mset ((W(L1 := W L1 @ [(i, L2, b)], L2 := W L2 @ [(i, L1, b)])) L) &#10230;
          b&#39;&#39; &#10230; ia &#8712;# dom_m (fmupd i (L1 # L2 # UW, b&#39;) N)) &#8743;
      {#ia &#8712;# fst `#
              mset ((W(L1 := W L1 @ [(i, L2, b)], L2 := W L2 @ [(i, L1, b)])) L).
       ia &#8712;# dom_m (fmupd i (L1 # L2 # UW, b&#39;) N)#} =
      clause_to_update L
       (K # M, fmupd i (L1 # L2 # UW, b&#39;) N, D, NE, UE, {#}, {#}))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# all_lits_of_mm (mset `# ran_mf N + (NE + UE)) &#10233;
          distinct_watched (W x) &#8743;
         (xa &#8712;# mset (W x) &#10230; (((case xa of (i, K, b&#39;&#39;) &#8658; i &#8712;# dom_m N &#10230; K &#8712; set (N &#8733; i) &#8743; K &#8800; x &#8743;
           correctly_marked_as_binary N (i, K, b&#39;&#39;)) &#8743;
           (case xa of (i, K, b&#39;&#39;) &#8658; b&#39;&#39; &#10230; i &#8712;# dom_m N)))) &#8743;
         {#i &#8712;# fst `# mset (W x). i &#8712;# dom_m N#} = clause_to_update x (M, N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>xa</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>correctly_marked_as_binary.simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst xa&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd xa)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd xa)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>i_dom</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = L1&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = L2&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>H&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H&#39;</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H&#39;</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>H&#39;</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?c</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching.simps</span><span> </span><span>Ball_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_add_mset</span><span> </span><span>all_lits_of_m_add_mset</span><span>
</span><span>          </span><span>all_conj_distrib</span><span> </span><span>all_lits_of_mm_union</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="var">?c</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L ia K&#39; b&#39;&#39;. (L&#8712;#all_lits_of_mm
        (mset `# ran_mf N + (NE + UE)) &#10233;
      distinct_watched (W L) &#8743;
      ((ia, K&#39;, b&#39;&#39;)&#8712;#mset (W L) &#10230;
          ia &#8712;# dom_m N &#10230;
          K&#39; &#8712; set (N &#8733; ia) &#8743; K&#39; &#8800; L &#8743; correctly_marked_as_binary N (ia, K&#39;, b&#39;&#39;)) &#8743;
      ((ia, K&#39;, b&#39;&#39;)&#8712;#mset (W L) &#10230; b&#39;&#39; &#10230; ia &#8712;# dom_m N) &#8743;
      {#ia &#8712;# fst `# mset (W L). ia &#8712;# dom_m N#} = clause_to_update L (M, N, D, NE, UE, {#}, {#}))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# all_lits_of_mm (mset `# ran_mf (fmupd i (L1 # L2 # UW, b&#39;) N) + (NE + UE)) &#10230;
         distinct_watched ((W(L1 := W L1 @ [(i, L2, b)], L2 := W L2 @ [(i, L1, b)])) x) &#8743;
         (xa &#8712;# mset ((W(L1 := W L1 @ [(i, L2, b)], L2 := W L2 @ [(i, L1, b)])) x) &#10230;
               (case xa of (ia, K, b&#39;&#39;) &#8658; ia &#8712;# dom_m (fmupd i (L1 # L2 # UW, b&#39;) N) &#10230;
                 K &#8712; set (fmupd i (L1 # L2 # UW, b&#39;) N &#8733; ia) &#8743; K &#8800; x &#8743;
                    correctly_marked_as_binary (fmupd i (L1 # L2 # UW, b&#39;) N) (ia, K, b&#39;&#39;))) &#8743;
         (xa &#8712;# mset ((W(L1 := W L1 @ [(i, L2, b)], L2 := W L2 @ [(i, L1, b)])) x) &#10230;
               (case xa of (ia, K, b&#39;&#39;) &#8658; b&#39;&#39; &#10230; ia &#8712;# dom_m (fmupd i (L1 # L2 # UW, b&#39;) N))) &#8743;
         {#ia &#8712;# fst `# mset ((W(L1 := W L1 @ [(i, L2, b)], L2 := W L2 @ [(i, L1, b)])) x). ia &#8712;# dom_m (fmupd i (L1 # L2 # UW, b&#39;) N)#} =
         clause_to_update x (K # M, fmupd i (L1 # L2 # UW, b&#39;) N, D, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xa</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>correctly_marked_as_binary.simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst xa&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (snd xa)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (snd xa)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>fresh</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>i_dom</span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = L1&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = L2&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>H&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>H&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>H&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>H&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?l</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching.simps</span><span> </span><span>Ball_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>equality_except_conflict_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v twl_st_wl &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;equality_except_conflict_wl (M, N, D, NE, UE, WS, Q) (M&#39;, N&#39;, D&#39;, NE&#39;, UE&#39;, WS&#39;, Q&#39;) &#10231;
    M = M&#39; &#8743; N = N&#39; &#8743; NE = NE&#39; &#8743; UE = UE&#39; &#8743; WS = WS&#39; &#8743; Q = Q&#39;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>equality_except_trail_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v twl_st_wl &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;equality_except_trail_wl (M, N, D, NE, UE, WS, Q) (M&#39;, N&#39;, D&#39;, NE&#39;, UE&#39;, WS&#39;, Q&#39;) &#10231;
    N = N&#39; &#8743; D = D&#39; &#8743; NE = NE&#39; &#8743; UE = UE&#39; &#8743; WS = WS&#39; &#8743; Q = Q&#39;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equality_except_conflict_wl_get_clauses_wl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;equality_except_conflict_wl S Y &#10233; get_clauses_wl S = get_clauses_wl Y&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>Y</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equality_except_trail_wl_get_clauses_wl</span><span class="delimiter">:</span><span>
</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;equality_except_trail_wl S Y&#10233; get_clauses_wl S = get_clauses_wl Y&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>Y</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>backtrack_wl_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(backtrack_wl, backtrack_l)
    &#8712; {(T&#39;::&#39;v twl_st_wl, T).
          (T&#39;, T) &#8712; state_wl_l None &#8743;
          correct_watching T&#39; &#8743;
          get_conflict_wl T&#39; &#8800; None &#8743;
          get_conflict_wl T&#39; &#8800; Some {#}} &#8594;
        &#10216;{(T&#39;, T).
          (T&#39;, T) &#8712; state_wl_l None &#8743;
          correct_watching T&#39;}&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?bt &#8712; ?A &#8594; &#10216;?B&#10217;nres_rel&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extract_shorter_conflict_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_shorter_conflict_wl S&#39;
    &#8804; &#8659; {(U&#39;::&#39;v twl_st_wl, U).
          (U&#39;, U) &#8712; state_wl_l None &#8743; equality_except_conflict_wl U&#39; S&#39; &#8743;
          the (get_conflict_wl U&#39;) &#8838;# the (get_conflict_wl S&#39;) &#8743;
          get_conflict_wl U&#39; &#8800; None} (extract_shorter_conflict_l S)&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?extract _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; ?A&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extract_shorter_conflict_wl_def</span><span> </span><span>extract_shorter_conflict_l_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RES_refine</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_shorter_conflict_wl_def</span><span> </span><span>extract_shorter_conflict_l_def</span><span>
</span><span>        </span><span>mset_take_mset_drop_mset</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>find_decomp_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_decomp_wl L T&#39;
    &#8804; &#8659; {(U&#39;::&#39;v twl_st_wl, U).
          (U&#39;, U) &#8712; state_wl_l None &#8743; equality_except_trail_wl U&#39; T&#39; &#8743;
       (&#8707;M. get_trail_wl T&#39; = M @ get_trail_wl U&#39;) } (find_decomp L&#39; T)&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?find _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; ?A&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = L&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T&#39;, T) &#8712; ?extract S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span>T&#39;</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_decomp_wl_def</span><span> </span><span>find_decomp_def</span><span> </span><span>prod.case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RES_refine</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span> </span><span>find_decomp_wl_def</span><span> </span><span>find_decomp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>find_lit_of_max_level_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_lit_of_max_level_wl T&#39; LLK&#39;
    &#8804; &#8659; {(L&#39;, L). L = L&#39; &#8743; L&#39; &#8712;# the (get_conflict_wl T&#39;) &#8743; L&#39; &#8712;# the (get_conflict_wl T&#39;) - {#-LLK&#39;#}}
         (find_lit_of_max_level T L)&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?find_lit _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = LLK&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T&#39;, T) &#8712; ?find S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span>T&#39;</span><span> </span><span>L</span><span> </span><span>LLK&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_lit_of_max_level_wl_def</span><span> </span><span>find_lit_of_max_level_def</span><span> </span><span>prod.case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RES_refine</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>find_lit_of_max_level_wl_def</span><span> </span><span>find_lit_of_max_level_def</span><span> </span><span>state_wl_l_def</span><span>
</span><span>     </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>empty</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_to_update_wl S&#39; = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>bt</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_wl_inv S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bt</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>backtrack_wl_inv_def</span><span> </span><span>backtrack_l_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_struct_invs_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propagate_bt_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_bt_wl (lit_of (hd (get_trail_wl S&#39;))) L&#39; U&#39;
    &#8804; &#8659; {(T&#39;, T). (T&#39;, T) &#8712; state_wl_l None &#8743; correct_watching T&#39;}
        (propagate_bt_l (lit_of (hd (get_trail_l S))) L U)&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; ?propa _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; ?A&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>UU&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(U&#39;, U) &#8712; ?find T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>LL&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(L&#39;, L) &#8712; ?find_lit U&#39; (lit_of (hd (get_trail_wl S&#39;)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>TT&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T&#39;, T) &#8712; ?extract S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>bt</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_wl_inv S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span>T&#39;</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>U</span><span> </span><span>U&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>empty</span><span> </span><span class="delimiter">=</span><span> </span><span>empty</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bt</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>K&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K&#39; = lit_of (hd (get_trail_l S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>MS</span><span> </span><span>NS</span><span> </span><span>DS</span><span> </span><span>NES</span><span> </span><span>UES</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S&#39; = (MS, NS, Some DS, NES, UES, {#}, W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span>empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S&#39;&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>DT</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>T&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T&#39; = (MS, NS, Some DT, NES, UES, {#}, W)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DT &#8838;# DS&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TT&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl T&#39;&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>MU</span><span> </span><span>MU&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>U&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; = (MU, NS, Some DT, NES, UES, {#}, W)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>MU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;MS = MU&#39; @ MU&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>U&#39;U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(U&#39;, U) &#8712; state_wl_l None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UU&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>U&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U = (MU, NS, Some DT, NES, UES, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>U</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;MS &#8800; []&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>backtrack_wl_inv_def</span><span> </span><span>backtrack_l_inv_def</span><span> </span><span>S&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching (MU, NS, None, NES, UES, {#K&#39;#}, W)&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S&#39;</span><span> </span><span>correct_watching.simps</span><span> </span><span>clause_to_update_def</span><span> </span><span>get_clauses_l.simps</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K_hd</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of (hd MS) = K&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>K&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = L&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LL&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trail_no_alien</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of ` lits_of_l (get_trail_wl S&#39;)
           &#8838; atms_of_ms
              ((&#955;x. mset (fst x)) `
               {a. a &#8712;# ran_m (get_clauses_wl S&#39;) &#8743; snd a}) &#8746;
             atms_of_mm (get_unit_init_clss_wl S&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>no_alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of DS &#8838; atms_of_ms
                  ((&#955;x. mset (fst x)) `
                   {a. a &#8712;# ran_m (get_clauses_wl S&#39;) &#8743; snd a}) &#8746;
                 atms_of_mm (get_unit_init_clss_wl S&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset DS&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span>bt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>        </span><span>backtrack_wl_inv_def</span><span> </span><span>backtrack_l_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span> </span><span>twl_st_wl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span> </span><span>twl_st_wl</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span> </span><span>twl_st_wl</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712;# DS&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LL&#39;</span><span> </span><span>TT&#39;</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>T&#39;</span><span> </span><span>S&#39;</span><span> </span><span>U&#39;</span><span> </span><span>mset_take_mset_drop_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>       </span><span>atm_L&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L&#39; &#8712; atms_of_mm (mset `# init_clss_lf NS + NES)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>atm_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#8712;#DS. atm_of L &#8712; atms_of_mm (mset `# init_clss_lf NS + NES)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>S&#39;</span><span>
</span><span>          </span><span>mset_take_mset_drop_mset</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>atm_of_lit_in_atms_of</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>atm_K&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of K&#39; &#8712; atms_of_mm (mset `# init_clss_lf NS + NES)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>trail_no_alien</span><span> </span><span>K_hd</span><span> </span><span>MS</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>MS</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S&#39;</span><span>
</span><span>          </span><span>mset_take_mset_drop_mset</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span>  </span><span>K_hd</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>atm_of_lit_in_atms_of</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset DT&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DT &#8838;# DS&#8250;</span></span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>distinct_mset_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fresh</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_fresh_index_wl N (NUE) W &#8804;
      &#8659; {(i, i&#39;). i = i&#39; &#8743; i &#8713;# dom_m N &#8743;  (&#8704;L &#8712;# all_lits_of_mm (mset `# ran_mf N + NUE). i &#8713; fst ` set (W L))} (get_fresh_index N&#39;)&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N = N&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>N</span><span> </span><span>N&#39;</span><span> </span><span>NUE</span><span> </span><span>W</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>that</span><span> </span><span>get_fresh_index_def</span><span> </span><span>get_fresh_index_wl_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>RES_refine</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>refine0</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;SPEC (&#955;D&#39;. the D = mset D&#39;) &#8804; &#8659; {(D&#39;, E&#39;). D&#39; = E&#39; &#8743; the D = mset D&#39;}
        (SPEC (&#955;D&#39;. the E = mset D&#39;))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D = E&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>D</span><span> </span><span>E</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>RES_refine</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propagate_bt_wl_def</span><span> </span><span>propagate_bt_l_def</span><span> </span><span>S&#39;</span><span> </span><span>T&#39;</span><span> </span><span>U&#39;</span><span> </span><span>U</span><span> </span><span>st_l_of_wl.simps</span><span> </span><span>get_trail_wl.simps</span><span>
</span><span>      </span><span>list_of_mset_def</span><span> </span><span>K&#39;_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>fresh</span><span class="delimiter">;</span><span> </span><span>remove_dummy_vars</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>in_pair_collect_simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>corr</span><span> </span><span>state_wl_l_def</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>correct_watching_learn</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_K&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_clss_lf_ran_m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>image_mset_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_L&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_clss_lf_ran_m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>image_mset_union</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_confl</span><span> </span><span>TT&#39;</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_clss_lf_ran_m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>image_mset_union</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S&#39;</span><span> </span><span>T&#39;</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_atms_of_minusD</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>LL&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>U&#39;</span><span> </span><span>S&#39;</span><span> </span><span>distinct_mset_remove1_All</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>corr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propagate_unit_bt_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(propagate_unit_bt_wl (lit_of (hd (get_trail_wl S&#39;))) U&#39;,
     propagate_unit_bt_l (lit_of (hd (get_trail_l S))) U)
    &#8712; {(T&#39;, T). (T&#39;, T) &#8712; state_wl_l None &#8743; correct_watching T&#39;} &#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(_, _) &#8712; ?propagate_unit_bt_wl _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>     </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; ?A&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>TT&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T&#39;, T) &#8712; ?extract S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>UU&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(U&#39;, U) &#8712; ?find T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>bt</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_wl_inv S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span>T&#39;</span><span> </span><span>L</span><span> </span><span>L&#39;</span><span> </span><span>U</span><span> </span><span>U&#39;</span><span> </span><span>K&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>MS</span><span> </span><span>NS</span><span> </span><span>DS</span><span> </span><span>NES</span><span> </span><span>UES</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S&#39; = (MS, NS, Some DS, NES, UES, {#}, W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span>UU&#39;</span><span> </span><span>empty</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bt</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl S&#39;&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>DT</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>T&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T&#39; = (MS, NS, Some DT, NES, UES, {#}, W)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>DT_DS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DT &#8838;# DS&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TT&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T&#39;</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl T&#39;&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T = (MS, NS, Some DT, NES, UES, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TT&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S&#39;</span><span> </span><span>T&#39;</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>MU</span><span> </span><span>MU&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>U&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; = (MU, NS, Some DT, NES, UES, {#}, W)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>MU</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;MS = MU&#39; @ MU&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(U&#39;, U) &#8712; state_wl_l None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UU&#39;</span><span> </span><span>T&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>U&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U = (MU, NS, Some DT, NES, UES, {#}, {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>UU&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>U&#39;</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S1</span><span> </span><span>S2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S1) &#8712; state_wl_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>S2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S1, S2) &#8712; twl_st_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>backtrack_wl_inv_def</span><span> </span><span>backtrack_l_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (state<span class="hidden">&#8681;</span><sub>W</sub>_of S2)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (all_lits_of_mm (mset `# ran_mf NS + NES + add_mset (the (Some DT)) UES)) =
      set_mset (all_lits_of_mm (mset `# ran_mf NS + (NES + UES)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>all_clss_lf_ran_m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>image_mset_union</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S1</span><span> </span><span>S2</span><span> </span><span>atms_of_subset_mset_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>DT_DS</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_union</span><span> </span><span>all_lits_of_mm_add_mset</span><span> </span><span>state_wl_l_def</span><span>
</span><span>        </span><span>twl_st_l_def</span><span> </span><span>S&#39;</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>        </span><span>mset_take_mset_drop_mset&#39;</span><span> </span><span>in_all_lits_of_mm_ain_atms_of_iff</span><span>
</span><span>        </span><span>in_all_lits_of_m_ain_atms_of_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (all_lits_of_mm (mset `# ran_mf NS + (NES + add_mset (the (Some DT)) UES))) =
      set_mset (all_lits_of_mm (mset `# ran_mf NS + (NES + UES)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>corr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching (Propagated (- lit_of (hd MS)) 0 # MU, NS, None, NES,
      add_mset (the (Some DT)) UES, unmark (hd MS), W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S&#39;</span><span> </span><span>correct_watching.simps</span><span> </span><span>clause_to_update_def</span><span> </span><span>get_clauses_l.simps</span><span> </span><span>K</span><span>
</span><span>        </span><span>K&#39;</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>propagate_unit_bt_wl_def</span><span> </span><span>propagate_unit_bt_l_def</span><span> </span><span>S&#39;</span><span> </span><span>T&#39;</span><span> </span><span>U</span><span> </span><span>U&#39;</span><span>
</span><span>        </span><span>st_l_of_wl.simps</span><span> </span><span>get_trail_wl.simps</span><span> </span><span>list_of_mset_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S&#39;</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>corr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>st_l_of_wl.simps</span><span> </span><span>get_trail_wl.simps</span><span> </span><span>list_of_mset_def</span><span>
</span><span>      </span><span>backtrack_wl_def</span><span> </span><span>backtrack_l_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>find_decomp_wl</span><span> </span><span>find_lit_of_max_level_wl</span><span> </span><span>extract_shorter_conflict_wl</span><span>
</span><span>         </span><span>propagate_bt_wl</span><span> </span><span>propagate_unit_bt_wl</span><span class="delimiter">;</span><span>
</span><span>        </span><span>remove_dummy_vars</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_wl_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Backtrack, Skip, Resolve or Decide&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdcl_twl_o_prog_wl_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o_prog_wl_pre S &#10231;
     (&#8707;S&#39;. (S, S&#39;) &#8712; state_wl_l None &#8743;
        correct_watching S &#8743;
        cdcl_twl_o_prog_l_pre S&#39;)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdcl_twl_o_prog_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; (bool &#215; &#39;v twl_st_wl) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o_prog_wl S =
    do {
      ASSERT(cdcl_twl_o_prog_wl_pre S);
      do {
        if get_conflict_wl S = None
        then decide_wl_or_skip S
        else do {
          if count_decided (get_trail_wl S) &gt; 0
          then do {
            T &#8592; skip_and_resolve_loop_wl S;
            ASSERT(get_conflict_wl T &#8800; None &#8743; get_conflict_wl T &#8800; Some {#});
            U &#8592; backtrack_wl T;
            RETURN (False, U)
          }
          else do {RETURN (True, S)}
        }
      }
    }
  &#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_o_prog_wl_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(cdcl_twl_o_prog_wl, cdcl_twl_o_prog_l) &#8712; {(S::&#39;v twl_st_wl, S&#39;::&#39;v twl_st_l).
     (S, S&#39;) &#8712; state_wl_l None &#8743;
     correct_watching S} &#8594;<span class="hidden">&#8681;</span><sub>f</sub>
   &#10216;{((brk::bool, T::&#39;v twl_st_wl), brk&#39;::bool, T&#39;::&#39;v twl_st_l).
     (T, T&#39;) &#8712; state_wl_l None &#8743;
     brk = brk&#39; &#8743;
     correct_watching T}&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?o &#8712; ?A &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;?B&#10217; nres_rel&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>find_unassigned_lit_wl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_unassigned_lit_wl S &#8804; &#8659; Id (find_unassigned_lit_l S&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; state_wl_l None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>find_unassigned_lit_wl_def</span><span> </span><span>find_unassigned_lit_l_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching (decide_lit_wl L S) &#10231; correct_watching S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>S</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>decide_lit_wl_def</span><span> </span><span>correct_watching.simps</span><span> </span><span>clause_to_update_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(decide_lit_wl L S, decide_lit_l L S&#39;) &#8712; state_wl_l None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; state_wl_l None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>decide_lit_wl_def</span><span> </span><span>decide_lit_l_def</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>option_id</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = x&#39; &#10233; (x,x&#39;) &#8712; &#10216;Id&#10217;option_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>x&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>cdcl_o</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?o &#8712; ?A &#8594;<span class="hidden">&#8681;</span><sub>f</sub>
   &#10216;{((brk::bool, T::&#39;v twl_st_wl), brk&#39;::bool, T&#39;::&#39;v twl_st_l).
     (T, T&#39;) &#8712; state_wl_l None &#8743;
     brk = brk&#39; &#8743;
     correct_watching T}&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_o_prog_wl_def</span><span> </span><span>cdcl_twl_o_prog_l_def</span><span> </span><span>decide_wl_or_skip_def</span><span>
</span><span>      </span><span>decide_l_or_skip_def</span><span> </span><span>fref_param1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>skip_and_resolve_loop_wl_spec</span><span class="delimiter">[</span><span class="string"><span class="delete"><span class="delete">&quot;to_&#8659;&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>backtrack_wl_spec</span><span class="delimiter">[</span><span class="string"><span class="delete"><span class="delete">&quot;to_&#8659;&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>find_unassigned_lit_wl</span><span> </span><span>option_id</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_o_prog_wl_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decide_wl_or_skip_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decide_wl_or_skip_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Full Strategy&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; bool &#215; &#39;v twl_st_wl  &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_wl_inv S<span class="hidden">&#8681;</span><sub>0</sub> &#8801; &#955;(brk, T).
      (&#8707; T&#39; S<span class="hidden">&#8681;</span><sub>0</sub>&#39;.  (T, T&#39;) &#8712; state_wl_l None &#8743;
      (S<span class="hidden">&#8681;</span><sub>0</sub>, S<span class="hidden">&#8681;</span><sub>0</sub>&#39;) &#8712; state_wl_l None &#8743;
      cdcl_twl_stgy_prog_l_inv S<span class="hidden">&#8681;</span><sub>0</sub>&#39; (brk, T&#39;))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdcl_twl_stgy_prog_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_wl S<span class="hidden">&#8681;</span><sub>0</sub> =
  do {
    (brk, T) &#8592; WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>cdcl_twl_stgy_prog_wl_inv S<span class="hidden">&#8681;</span><sub>0</sub><span class="hidden">&#8662;</span></sup>
      (&#955;(brk, _). &#172;brk)
      (&#955;(brk, S). do {
        T &#8592; unit_propagation_outer_loop_wl S;
        cdcl_twl_o_prog_wl T
      })
      (False, S<span class="hidden">&#8681;</span><sub>0</sub>);
    RETURN T
  }&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(cdcl_twl_stgy_prog_wl, cdcl_twl_stgy_prog_l) &#8712; {(S::&#39;v twl_st_wl, S&#39;).
       (S, S&#39;) &#8712; state_wl_l None &#8743;
       correct_watching S} &#8594;
    &#10216;state_wl_l None&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?o &#8712; ?A &#8594; &#10216;?B&#10217; nres_rel&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((False, S&#39;), False, S) &#8712; {((brk&#39;, T&#39;), (brk, T)). (T&#39;, T) &#8712; state_wl_l None &#8743; brk&#39; = brk &#8743;
       correct_watching T&#39;}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; state_wl_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_def</span><span> </span><span>cdcl_twl_stgy_prog_l_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>H</span><span> </span><span>unit_propagation_outer_loop_wl_spec</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">]</span><span>
</span><span>      </span><span>cdcl_twl_o_prog_wl_spec</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span>brk&#39;T&#39;</span><span> </span><span>brkT</span><span> </span><span>brk&#39;</span><span> </span><span>T&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_spec&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(cdcl_twl_stgy_prog_wl, cdcl_twl_stgy_prog_l) &#8712; {(S::&#39;v twl_st_wl, S&#39;).
       (S, S&#39;) &#8712; state_wl_l None &#8743; correct_watching S} &#8594;
    &#10216;{(S::&#39;v twl_st_wl, S&#39;).
       (S, S&#39;) &#8712; state_wl_l None &#8743; correct_watching S}&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?o &#8712; ?A &#8594; &#10216;?B&#10217; nres_rel&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((False, S&#39;), False, S) &#8712; {((brk&#39;, T&#39;), (brk, T)). (T&#39;, T) &#8712; state_wl_l None &#8743; brk&#39; = brk &#8743;
       correct_watching T&#39;}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; state_wl_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>unit_propagation_outer_loop_wl_spec</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_def</span><span> </span><span>cdcl_twl_stgy_prog_l_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>H</span><span> </span><span>unit_propagation_outer_loop_wl_spec</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">]</span><span>
</span><span>      </span><span>cdcl_twl_o_prog_wl_spec</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span>brk&#39;T&#39;</span><span> </span><span>brkT</span><span> </span><span>brk&#39;</span><span> </span><span>T&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_wl_pre S U &#10231;
    (&#8707;T. (S, T) &#8712; state_wl_l None &#8743; cdcl_twl_stgy_prog_l_pre T U &#8743; correct_watching S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_spec_final</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_wl_pre S S&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_wl S &#8804; &#8659; (state_wl_l None O twl_st_l None) (conclusive_TWL_run S&#39;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, T) &#8712; state_wl_l None&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_l_pre T S&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_twl_stgy_prog_wl_spec</span><span class="delimiter">[</span><span class="string"><span class="delete"><span class="delete">&quot;to_&#8659;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ref_two_step&#39;</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl_twl_stgy_prog_l_spec_final</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>S&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conc_fun_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdcl_twl_stgy_prog_break_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl &#8658; &#39;v twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_break_wl S<span class="hidden">&#8681;</span><sub>0</sub> =
  do {
    b &#8592; SPEC(&#955;_. True);
    (b, brk, T) &#8592; WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>&#955;(_, S). cdcl_twl_stgy_prog_wl_inv S<span class="hidden">&#8681;</span><sub>0</sub> S<span class="hidden">&#8662;</span></sup>
      (&#955;(b, brk, _). b &#8743; &#172;brk)
      (&#955;(_, brk, S). do {
        T &#8592; unit_propagation_outer_loop_wl S;
        T &#8592; cdcl_twl_o_prog_wl T;
        b &#8592; SPEC(&#955;_. True);
        RETURN (b, T)
      })
      (b, False, S<span class="hidden">&#8681;</span><sub>0</sub>);
    if brk then RETURN T
    else cdcl_twl_stgy_prog_wl T
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cdcl_twl_stgy_prog_break_wl_spec&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(cdcl_twl_stgy_prog_break_wl, cdcl_twl_stgy_prog_break_l) &#8712; {(S::&#39;v twl_st_wl, S&#39;).
       (S, S&#39;) &#8712; state_wl_l None &#8743; correct_watching S} &#8594;<span class="hidden">&#8681;</span><sub>f</sub>
    &#10216;{(S::&#39;v twl_st_wl, S&#39;). (S, S&#39;) &#8712; state_wl_l None &#8743; correct_watching S}&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?o &#8712; ?A &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;?B&#10217; nres_rel&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((b&#39;, False, S&#39;), b, False, S) &#8712; {((b&#39;, brk&#39;, T&#39;), (b, brk, T)).
      (T&#39;, T) &#8712; state_wl_l None &#8743; brk&#39; = brk &#8743; b&#39; = b &#8743;
       correct_watching T&#39;}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; state_wl_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(b&#39;, b) &#8712; bool_rel&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_wl&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b&#39;</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_break_wl_def</span><span> </span><span>cdcl_twl_stgy_prog_break_l_def</span><span> </span><span>fref_param1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>H</span><span> </span><span>unit_propagation_outer_loop_wl_spec</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">]</span><span>
</span><span>      </span><span>cdcl_twl_o_prog_wl_spec</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">]</span><span>
</span><span>      </span><span>cdcl_twl_stgy_prog_wl_spec&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>fref_param1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span> </span><span>S</span><span> </span><span>brk&#39;T&#39;</span><span> </span><span>brkT</span><span> </span><span>brk&#39;</span><span> </span><span>T&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cdcl_twl_stgy_prog_break_wl_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(cdcl_twl_stgy_prog_break_wl, cdcl_twl_stgy_prog_break_l) &#8712; {(S::&#39;v twl_st_wl, S&#39;).
       (S, S&#39;) &#8712; state_wl_l None &#8743;
       correct_watching S} &#8594;<span class="hidden">&#8681;</span><sub>f</sub>
    &#10216;state_wl_l None&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>   </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?o &#8712; ?A &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;?B&#10217; nres_rel&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_stgy_prog_break_wl_spec&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mem_set_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>match_fun_rel</span><span class="delimiter">,</span><span> </span><span>solves</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>match_fun_rel</span><span class="delimiter">;</span><span> </span><span>solves</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_prog_break_wl_spec_final</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_wl_pre S S&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_break_wl S &#8804; &#8659; (state_wl_l None O twl_st_l None) (conclusive_TWL_run S&#39;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, T) &#8712; state_wl_l None&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_l_pre T S&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_twl_stgy_prog_break_wl_spec</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>fref_param1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;to_&#8659;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ref_two_step&#39;</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl_twl_stgy_prog_break_l_spec_final</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>S&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conc_fun_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


