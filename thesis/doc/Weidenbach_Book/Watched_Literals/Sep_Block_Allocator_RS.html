<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Sep_Block_Allocator_RS (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Sep_Block_Allocator_RS</h1>

<span class="command">theory</span> <span class="name">Sep_Block_Allocator_RS</span><br/>
<span class="keyword">imports</span> <a href="Sep_Lift.html"><span class="name">Sep_Lift</span></a> <a href="LLVM_Basic_Main.html"><span class="name">LLVM_Basic_Main</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Generic Block Allocator --- Resoning Setup&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Sep_Block_Allocator_RS</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Sep_Lift</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;../basic/LLVM_Basic_Main&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list&#945;_at_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;list&#945; &#945; xs (length xs) = 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list&#945;_gt_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&#8805;length xs &#10233; list&#945; &#945; xs i = 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list&#945;_snoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;list&#945; &#945; (xs@[x]) = 0(length xs := &#945; x) + list&#945; &#945; xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_def</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list&#945;_in_range</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;list&#945; &#945; xs i &#8800; 0 &#10233; i&lt;length xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list&#945;_in_rangeD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;list&#945; &#945; xs = x &#10233; x i &#8800; 0 &#10233; i&lt;length xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list&#945;_splitE</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;list&#945; &#945; xs = fun_upd 0 i p + fun_upd f i 0&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p&#8800;0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length xs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945; (xs!i) = p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>option&#945;_splitE</span><span class="delimiter">:</span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;option&#945; &#945; v = p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p&#8800;0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v=Some x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945; x = p&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>v</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>block_allocator2</span><span> </span><span class="delimiter">=</span><span> </span><span>block_allocator1</span><span> </span><span>static_err</span><span> </span><span>mem_err</span><span> </span><span>bload</span><span> </span><span>bstore</span><span> </span><span>bcheck_addr</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>static_err</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;err</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mem_err</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;err</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bload</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;baddr::this_addr &#8658; (&#39;val,_,&#39;block,&#39;err) M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bstore</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;val &#8658; &#39;baddr &#8658; (unit,_,&#39;block,&#39;err) M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bcheck_addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;baddr &#8658; (unit,_,&#39;block,&#39;err) M&quot;</span></span></span><span>
</span><span>    
</span><span>  </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>&#945;b</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;block &#8658; &#39;ablock::unique_zero_sep_algebra&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bpto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;val &#8658; &#39;baddr &#8658; &#39;ablock &#8658; bool&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tag_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;block &#8658; &#39;tag&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>is_complete_tag</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;ablock &#8658; &#39;tag &#8658; bool&quot;</span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bload_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x a. htriple &#945;b (bpto x a) (bload a) (&#955;r. &#8593;(r=x) ** bpto x a)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bstore_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x xx a. htriple &#945;b (bpto xx a) (bstore x a) (&#955;_. bpto x a)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bload_pres_tag</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;s a. wlp (bload a) (&#955;_ s&#39;. tag_of s&#39; = tag_of s) s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bstore_pres_tag</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;s a x. wlp (bstore a x) (&#955;_ s&#39;. tag_of s&#39; = tag_of s) s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>complete_tag</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. &#10214;is_complete_tag ablock (tag_of cblock); ablock ## f; &#945;b cblock = ablock + f&#10215; &#10233; f=0&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bpto_notZ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x a. &#172;bpto x a 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>&#945;tag</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;block &#8658; &#39;tag tsa_opt&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945;tag blk &#8801; TRIV (tag_of blk)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>&#945;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;block memory &#8658; nat &#8658; &#39;ablock &#215; &#39;tag tsa_opt&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945; &#8801; &#955;MEMORY blocks &#8658; list&#945; (option&#945; (&#955;x. (&#945;b x, &#945;tag x))) blocks&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;val &#8658; &#39;baddr addr rptr &#8658; (nat &#8658; &#39;ablock &#215; &#39;tag tsa_opt) &#8658; bool&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pto x &#8801; &#955;RP_ADDR (ADDR bi ba) &#8658; &#955;s. &#8707;ablk. s=0(bi:=(ablk,0)) &#8743; bpto x ba ablk | _ &#8658; sep_false&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tag</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;tag &#8658; &#39;baddr addr rptr &#8658; (nat &#8658; &#39;ablock &#215; &#39;tag tsa_opt) &#8658; bool&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tag t &#8801; &#955;RP_ADDR (ADDR bi ba) &#8658; EXACT (0(bi:=(0,TRIV t))) ** &#8593;(ba=this_addr &#8743; t&#8712;range tag_of) | _ &#8658; sep_false&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>block</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;ablock &#8658; &#39;baddr addr rptr &#8658; (nat &#8658; &#39;ablock &#215; &#39;tag tsa_opt) &#8658; bool&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block b &#8801; &#955;RP_ADDR (ADDR bi ba) &#8658; EXACT (0(bi:=(b,0))) ** &#8593;(ba=this_addr) | _ &#8658; sep_false&quot;</span></span></span><span>
</span><span>  
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>alloc_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple &#945; &#9633; (alloc b) (&#955;r. block (&#945;b b) r ** tag (tag_of b) r)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>htripleI&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>alloc_def</span><span> </span><span>wp_def</span><span> </span><span>run_simps</span><span> </span><span>sep_algebra_simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;block memory&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>blocks</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s = MEMORY blocks&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;p&#39;. p&#39; ## &#945; s &#8743;
              &#945; (put&#39; memory.the_memory<span class="hidden">&#8681;</span><sub>L</sub> (get&#39; memory.the_memory<span class="hidden">&#8681;</span><sub>L</sub> s @ [Some b]) s) = p&#39; + &#945; s &#8743;
              (block (&#945;b b) (RP_ADDR (ADDR (length (get&#39; memory.the_memory<span class="hidden">&#8681;</span><sub>L</sub> s)) this_addr)) &#8743;*
               tag (tag_of b) (RP_ADDR (ADDR (length (get&#39; memory.the_memory<span class="hidden">&#8681;</span><sub>L</sub> s)) this_addr)))
               p&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;0(length blocks := (&#945;b b, TRIV (tag_of b)))&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>&#945;_def</span><span> </span><span>block_def</span><span> </span><span>tag_def</span><span> </span><span>&#945;tag_def</span><span> </span><span>sep_algebra_simps</span><span> </span><span>list&#945;_at_len</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list&#945;_snoc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>EXACT_split</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>complete_splitE</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_complete_tag blk t&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>DISJ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f i ## (blk, TRIV t)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>AEQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;list&#945; (option&#945; (&#955;x. (&#945;b x, &#945;tag x))) xs = f + fun_upd 0 i (blk, TRIV t)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>cblk</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length xs&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs!i = Some cblk&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;blk = &#945;b cblk&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = tag_of cblk&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f i = 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length xs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>list&#945;_in_rangeD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AEQ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>DISJ</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>fib</span><span> </span><span>fit</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f i = (fib,fit)&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f i&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>                
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>DISJ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;blk ## fib&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fit = 0&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>              
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cblk</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs!i = Some cblk&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#945;b cblk = blk + fib&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t = tag_of cblk&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fun_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>AEQ</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs!i&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list&#945;_def</span><span> </span><span>sep_algebra_simps</span><span> </span><span>if_splits</span><span> </span><span>&#945;tag_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>complete_tag</span><span class="delimiter">[</span><span>OF</span><span> </span><span>C</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>fib</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fib=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>that</span><span class="delimiter">[</span><span>of</span><span> </span><span>cblk</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>        
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>free_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple &#945; (block blk a ** tag t a ** &#8593;(is_complete_tag blk t)) (free a) (&#955;_. &#9633;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>htripleI&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>p</span><span> </span><span>s</span><span> </span><span>f</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>free_def</span><span> </span><span>wp_def</span><span> </span><span>run_simps</span><span> </span><span>sep_algebra_simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>addr.splits</span><span> </span><span>rptr.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>block_def</span><span> </span><span>tag_def</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;subst (asm) EXACT_split[symmetric] sep_disj_fun_def; clarsimp simp: sep_algebra_simps&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>&#945;_def</span><span> </span><span>sep_algebra_simps</span><span> </span><span>merge_fun_singleton</span><span> </span><span>split_fun_upd_0</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>complete_splitE</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>complete_splitE</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>i</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sep_disj_funD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>i</span><span class="delimiter">]</span><span> </span><span>list&#945;_in_rangeD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>i</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>complete_splitE</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_lifter bi &#8801; &#10631; 
      sep_lifter.lift = &#955;x. (0(bi:=(x,0))),
      sep_lifter.project = (&#955;f. fst (f bi)),
      sep_lifter.carve = (&#955;f. f(bi:=(0,snd (f bi)))),
      sep_lifter.splittable = (&#955;f. True),
      sep_lifter.L = lens_of_bi bi,
      sep_lifter.&#945;b = &#945;,
      sep_lifter.&#945;s = &#945;b,
      sep_lifter.tyb = &#955;_. (),
      sep_lifter.tys = tag_of
          &#10632;&quot;</span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>block_lifter_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>      
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.lift (block_lifter bi) = (&#955;x. (0(bi:=(x,0))))&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.project (block_lifter bi) = (&#955;f. fst (f bi))&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.carve (block_lifter bi) = (&#955;f. f(bi:=(0,snd (f bi))))&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.splittable (block_lifter bi) = (&#955;f. True)&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.L (block_lifter bi) = lens_of_bi bi&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.&#945;b (block_lifter bi) = &#945;&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.&#945;s (block_lifter bi) = &#945;b&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.tyb (block_lifter bi) = (&#955;_. ())&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter.tys (block_lifter bi) = tag_of&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>block_lifter_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>block_lifter</span><span class="delimiter">:</span><span> </span><span>sep_lifter</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;block_lifter bi&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>aux1</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a ## fst b &#10233; b ## (a, 0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span class="delimiter">)</span><span>
</span><span>        
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sep_lifter (block_lifter bi)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>sep_disj_funD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>bi</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lens_of_bi_def</span><span> </span><span>&#945;_def</span><span> </span><span>list&#945;_def</span><span> </span><span>option&#945;_alt</span><span> </span><span>&#945;tag_def</span><span> </span><span>sep_algebra_simps</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>memory.splits</span><span> </span><span>if_splits</span><span> </span><span>option.splits</span><span>
</span><span>          </span><span>del</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>       
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pto_null_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pto x RP_NULL = sep_false&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pto_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pto_addr_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pto x (RP_ADDR (ADDR bi ba)) = block_lifter.lift_assn bi (bpto x ba)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pto_def</span><span> </span><span>block_lifter.lift_assn_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>fun_upd_same</span><span> </span><span>fun_upd_triv</span><span> </span><span>fun_upd_upd</span><span> </span><span>prod_Z_lower</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>surjective_pairing</span><span> </span><span>zero_fun_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rptr_cases</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rptr_cases (RP_NULL) = ()&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rptr_cases (RP_ADDR (ADDR _ _)) = ()&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>load_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple &#945; (pto x a) (load a) (&#955;r. &#8593;(x=r) ** pto x a)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>load_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rptr_cases.cases</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cons_post_rule</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>block_lifter.lift_operation</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bload_rule</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bpto_notZ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bload_pres_tag</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>store_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;htriple &#945; (pto xx a) (store x a) (&#955;_. pto x a)&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>store_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rptr_cases.cases</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cons_post_rule</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>block_lifter.lift_operation</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>bstore_rule</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bpto_notZ</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bstore_pres_tag</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sep_algebra_simps</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Address Arithmetic&#8250;</span></span></span><span>  
</span><span>  
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
    ptr ~ ptr :: bool   same base
  
    ptr - ptr :: int    if same base
    ptr + int :: ptr
  

    ~ is equivalence relation
    p ~ p
    p<span class="hidden">&#8681;</span><sub>1</sub> ~ p<span class="hidden">&#8681;</span><sub>2</sub> &#10231; p<span class="hidden">&#8681;</span><sub>2</sub> ~ p<span class="hidden">&#8681;</span><sub>1</sub>
    p<span class="hidden">&#8681;</span><sub>1</sub>~p<span class="hidden">&#8681;</span><sub>2</sub> &#8743; p<span class="hidden">&#8681;</span><sub>2</sub>~p<span class="hidden">&#8681;</span><sub>3</sub> &#10230; p<span class="hidden">&#8681;</span><sub>1</sub>~p<span class="hidden">&#8681;</span><sub>3</sub> 
        
    p + i<span class="hidden">&#8681;</span><sub>1</sub> + i<span class="hidden">&#8681;</span><sub>2</sub> = p + (i<span class="hidden">&#8681;</span><sub>1</sub>+i<span class="hidden">&#8681;</span><sub>2</sub>)
    p + 0 = p
    p ~ p+i
    
    p<span class="hidden">&#8681;</span><sub>1</sub>~p<span class="hidden">&#8681;</span><sub>2</sub> &#10233; p<span class="hidden">&#8681;</span><sub>2</sub> + (p<span class="hidden">&#8681;</span><sub>1</sub>-p<span class="hidden">&#8681;</span><sub>2</sub>) = p<span class="hidden">&#8681;</span><sub>1</sub>
  *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a+b&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">class</span></span><span> </span><span>addr_algebra</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>abase</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; bool&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>acompat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;~<span class="hidden">&#8681;</span><sub>a</sub>&quot;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>adiff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; &#39;a &#8658; int&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;-<span class="hidden">&#8681;</span><sub>a</sub>&quot;</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>aidx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; int &#8658; &#39;a&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;+<span class="hidden">&#8681;</span><sub>a</sub>&quot;</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>        </span><span class="comment">&#8213; &#8249;Compatibility is equivalence relation over base pointers&#8250;</span><span>
</span><span>            </span><span>acompat_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;part_equivp acompat&quot;</span></span></span><span>  
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>acompat_dom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a<span class="hidden">&#8681;</span><sub>1</sub> ~<span class="hidden">&#8681;</span><sub>a</sub> a<span class="hidden">&#8681;</span><sub>2</sub> &#10233; abase a<span class="hidden">&#8681;</span><sub>1</sub> &#8743; abase a<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span>
</span><span>        
</span><span>        </span><span class="comment">&#8213; &#8249;Indexing properties&#8250;</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>aidx_Z</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a +<span class="hidden">&#8681;</span><sub>a</sub> 0 = a&quot;</span></span></span><span> </span><span class="comment">&#8213; &#8249;Indexing by zero extended to non-base pointers&#8250;</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>aidx_plus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase a &#10233; a +<span class="hidden">&#8681;</span><sub>a</sub> i<span class="hidden">&#8681;</span><sub>1</sub> +<span class="hidden">&#8681;</span><sub>a</sub> i<span class="hidden">&#8681;</span><sub>2</sub> = a +<span class="hidden">&#8681;</span><sub>a</sub> (i<span class="hidden">&#8681;</span><sub>1</sub> + i<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>aidx_inj</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase a &#10233; a +<span class="hidden">&#8681;</span><sub>a</sub> i = a +<span class="hidden">&#8681;</span><sub>a</sub> j &#10231; i=j&quot;</span></span></span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*and abase_idx[simp, intro!]: &quot;abase a &#10233; abase (a +<span class="hidden">&#8681;</span><sub>a</sub> i)&quot;*)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>abase_idx</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase (a +<span class="hidden">&#8681;</span><sub>a</sub> i) &#10231; abase a&quot;</span></span></span><span>
</span><span>        
</span><span>        </span><span class="comment">&#8213; &#8249;Difference&#8250;</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>adiff_same</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a -<span class="hidden">&#8681;</span><sub>a</sub> a = 0&quot;</span></span></span><span> </span><span class="comment">&#8213; &#8249;Reflexive difference extended to non-base pointers&#8250;</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>aidx_compat</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase a &#10233; a ~<span class="hidden">&#8681;</span><sub>a</sub> a+<span class="hidden">&#8681;</span><sub>a</sub>i&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>adiff_idx</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a ~<span class="hidden">&#8681;</span><sub>a</sub> b &#10233; a +<span class="hidden">&#8681;</span><sub>a</sub> (b -<span class="hidden">&#8681;</span><sub>a</sub> a) = b&quot;</span></span></span><span>
</span><span>        
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>acompat_trans</span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a ~<span class="hidden">&#8681;</span><sub>a</sub> b &#10233; b ~<span class="hidden">&#8681;</span><sub>a</sub> c &#10233; a ~<span class="hidden">&#8681;</span><sub>a</sub> c&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>acompat_equiv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>part_equivp_transp</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>acompat_sym</span><span class="delimiter">[</span><span>sym</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a ~<span class="hidden">&#8681;</span><sub>a</sub> b &#10233; b ~<span class="hidden">&#8681;</span><sub>a</sub> a&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>acompat_equiv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>part_equivp_symp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma acompat_sym_iff[simp]: &quot;p~<span class="hidden">&#8681;</span><sub>a</sub>p&#39; &#10231; p&#39;~<span class="hidden">&#8681;</span><sub>a</sub>p&quot;
      using acompat_sym by auto
    *)</span></span></span></span></span><span>
</span><span>      
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>acompat_refl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a ~<span class="hidden">&#8681;</span><sub>a</sub> a &#10231; abase a&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>acompat_sym</span><span> </span><span>acompat_trans</span><span> </span><span>local.acompat_dom</span><span> </span><span>local.aidx_compat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aidx_compat&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;abase b &#10233; a ~<span class="hidden">&#8681;</span><sub>a</sub> b +<span class="hidden">&#8681;</span><sub>a</sub> i  &#10231; a ~<span class="hidden">&#8681;</span><sub>a</sub> b&quot;</span></span></span><span>  
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;abase a &#10233; a +<span class="hidden">&#8681;</span><sub>a</sub> i ~<span class="hidden">&#8681;</span><sub>a</sub> b &#10231; a ~<span class="hidden">&#8681;</span><sub>a</sub> b&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>acompat_sym</span><span> </span><span>acompat_trans</span><span> </span><span>local.aidx_compat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_Z_iff_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a<span class="hidden">&#8681;</span><sub>1</sub> ~<span class="hidden">&#8681;</span><sub>a</sub> a<span class="hidden">&#8681;</span><sub>2</sub> &#10233; a<span class="hidden">&#8681;</span><sub>1</sub> -<span class="hidden">&#8681;</span><sub>a</sub> a<span class="hidden">&#8681;</span><sub>2</sub> = 0 &#10231; a<span class="hidden">&#8681;</span><sub>1</sub>=a<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>acompat_sym</span><span> </span><span>acompat_trans</span><span> </span><span>local.adiff_idx</span><span> </span><span>local.adiff_same</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_Z_iff_eq&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a<span class="hidden">&#8681;</span><sub>2</sub> ~<span class="hidden">&#8681;</span><sub>a</sub> a<span class="hidden">&#8681;</span><sub>1</sub> &#10233; a<span class="hidden">&#8681;</span><sub>1</sub> -<span class="hidden">&#8681;</span><sub>a</sub> a<span class="hidden">&#8681;</span><sub>2</sub> = 0 &#10231; a<span class="hidden">&#8681;</span><sub>1</sub>=a<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>acompat_sym</span><span> </span><span>acompat_trans</span><span> </span><span>local.adiff_idx</span><span> </span><span>local.adiff_same</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adiff_idx&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b ~<span class="hidden">&#8681;</span><sub>a</sub> a &#10233; a +<span class="hidden">&#8681;</span><sub>a</sub> (b -<span class="hidden">&#8681;</span><sub>a</sub> a) = b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>acompat_sym</span><span> </span><span>local.adiff_idx</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_diff_distrib</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p~<span class="hidden">&#8681;</span><sub>a</sub>p&#39; &#10233; (p+<span class="hidden">&#8681;</span><sub>a</sub>i)-<span class="hidden">&#8681;</span><sub>a</sub>p&#39; = (p-<span class="hidden">&#8681;</span><sub>a</sub>p&#39;)+i&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>acompat_dom</span><span> </span><span>adiff_idx&#39;</span><span> </span><span>aidx_compat</span><span> </span><span>aidx_inj</span><span> </span><span>aidx_plus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idx_diff_distrib&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p&#39;~<span class="hidden">&#8681;</span><sub>a</sub>p &#10233; (p+<span class="hidden">&#8681;</span><sub>a</sub>i)-<span class="hidden">&#8681;</span><sub>a</sub>p&#39; = (p-<span class="hidden">&#8681;</span><sub>a</sub>p&#39;)+i&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>acompat_dom</span><span> </span><span>adiff_idx&#39;</span><span> </span><span>aidx_compat</span><span> </span><span>aidx_inj</span><span> </span><span>aidx_plus</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adiff_idx_idx</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;p~<span class="hidden">&#8681;</span><sub>a</sub>p&#39; &#10233; p +<span class="hidden">&#8681;</span><sub>a</sub> (p&#39; -<span class="hidden">&#8681;</span><sub>a</sub> p + i) = p&#39; +<span class="hidden">&#8681;</span><sub>a</sub> i&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;p&#39;~<span class="hidden">&#8681;</span><sub>a</sub>p &#10233; p +<span class="hidden">&#8681;</span><sub>a</sub> (p&#39; -<span class="hidden">&#8681;</span><sub>a</sub> p + i) = p&#39; +<span class="hidden">&#8681;</span><sub>a</sub> i&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>acompat_dom</span><span> </span><span>adiff_idx</span><span> </span><span>aidx_plus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>acompat_dom</span><span> </span><span>adiff_idx&#39;</span><span> </span><span>aidx_plus</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>acompat_dom&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;p~<span class="hidden">&#8681;</span><sub>a</sub>p&#39; &#10233; abase p&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;p~<span class="hidden">&#8681;</span><sub>a</sub>p&#39; &#10233; abase p&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>acompat_dom</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>            
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>        
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>rptr</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>addr_algebra</span><span class="delimiter">)</span><span> </span><span>addr_algebra</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>abase_rptr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase_rptr (RP_ADDR a) &#10231; abase a&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase_rptr RP_NULL &#10231; False&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>abase_rptr_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase p &#10231; (case p of (RP_ADDR a) &#8658; abase a | RP_NULL &#8658; False)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>acompat_rptr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;acompat_rptr (RP_ADDR a<span class="hidden">&#8681;</span><sub>1</sub>) (RP_ADDR a<span class="hidden">&#8681;</span><sub>2</sub>) &#10231; a<span class="hidden">&#8681;</span><sub>1</sub> ~<span class="hidden">&#8681;</span><sub>a</sub> a<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;acompat_rptr _ _ &#10231; False&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>acompat_rptr_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p<span class="hidden">&#8681;</span><sub>1</sub> ~<span class="hidden">&#8681;</span><sub>a</sub> p<span class="hidden">&#8681;</span><sub>2</sub> &#10231; (case (p<span class="hidden">&#8681;</span><sub>1</sub>,p<span class="hidden">&#8681;</span><sub>2</sub>) of (RP_ADDR a<span class="hidden">&#8681;</span><sub>1</sub>, RP_ADDR a<span class="hidden">&#8681;</span><sub>2</sub>) &#8658; a<span class="hidden">&#8681;</span><sub>1</sub> ~<span class="hidden">&#8681;</span><sub>a</sub> a<span class="hidden">&#8681;</span><sub>2</sub> | _ &#8658; False)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>p<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>adiff_rptr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;adiff_rptr (RP_ADDR a<span class="hidden">&#8681;</span><sub>1</sub>) (RP_ADDR a<span class="hidden">&#8681;</span><sub>2</sub>) = (a<span class="hidden">&#8681;</span><sub>1</sub> -<span class="hidden">&#8681;</span><sub>a</sub> a<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;adiff_rptr (RP_NULL) (RP_NULL) = 0&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;adiff_rptr _ _ = undefined&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adiff_rptr_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p<span class="hidden">&#8681;</span><sub>1</sub> -<span class="hidden">&#8681;</span><sub>a</sub> p<span class="hidden">&#8681;</span><sub>2</sub> = (case (p<span class="hidden">&#8681;</span><sub>1</sub>,p<span class="hidden">&#8681;</span><sub>2</sub>) of (RP_ADDR a<span class="hidden">&#8681;</span><sub>1</sub>, RP_ADDR a<span class="hidden">&#8681;</span><sub>2</sub>) &#8658; a<span class="hidden">&#8681;</span><sub>1</sub> -<span class="hidden">&#8681;</span><sub>a</sub> a<span class="hidden">&#8681;</span><sub>2</sub> | (RP_NULL,RP_NULL) &#8658; 0 | _ &#8658; undefined)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>p<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>aidx_rptr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;aidx_rptr (RP_ADDR a) i = RP_ADDR (a +<span class="hidden">&#8681;</span><sub>a</sub> i)&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;aidx_rptr RP_NULL _ = RP_NULL&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aidx_rptr_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p<span class="hidden">&#8681;</span><sub>1</sub> +<span class="hidden">&#8681;</span><sub>a</sub> i = (case p<span class="hidden">&#8681;</span><sub>1</sub> of RP_ADDR a<span class="hidden">&#8681;</span><sub>1</sub> &#8658; RP_ADDR (a<span class="hidden">&#8681;</span><sub>1</sub> +<span class="hidden">&#8681;</span><sub>a</sub> i) | _ &#8658; RP_NULL)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ptr_neq_null_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p&#8800;RP_NULL &#10231; (&#8707;a. p=RP_ADDR a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>part_equivpI</span><span> </span><span>sympI</span><span> </span><span>transpI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>acompat_equiv</span><span> </span><span>acompat_rptr.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>part_equivp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>acompat_rptr_alt</span><span> </span><span>aidx_rptr_alt</span><span> </span><span>adiff_rptr_alt</span><span> </span><span>acompat_dom</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>rptr.splits</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>sympI</span><span> </span><span>transpI</span><span> </span><span>reflpI</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>acompat_sym</span><span> </span><span>acompat_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>rptr_the_block_index</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;rptr_the_block_index (RP_ADDR (ADDR bi _)) = bi&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rptr_the_block_index _ = undefined&quot;</span></span></span><span>
</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>addr</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>addr_algebra</span><span class="delimiter">)</span><span> </span><span>addr_algebra</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>abase_addr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase_addr (ADDR bi ba) &#10231; abase ba&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>acompat_addr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ADDR bi<span class="hidden">&#8681;</span><sub>1</sub> ba<span class="hidden">&#8681;</span><sub>1</sub> ~<span class="hidden">&#8681;</span><sub>a</sub> ADDR bi<span class="hidden">&#8681;</span><sub>2</sub> ba<span class="hidden">&#8681;</span><sub>2</sub> &#10231; bi<span class="hidden">&#8681;</span><sub>1</sub>=bi<span class="hidden">&#8681;</span><sub>2</sub> &#8743; ba<span class="hidden">&#8681;</span><sub>1</sub>~<span class="hidden">&#8681;</span><sub>a</sub>ba<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>aidx_addr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ADDR bi ba +<span class="hidden">&#8681;</span><sub>a</sub> i = ADDR bi (ba +<span class="hidden">&#8681;</span><sub>a</sub> i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>adiff_addr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ADDR bi<span class="hidden">&#8681;</span><sub>1</sub> ba<span class="hidden">&#8681;</span><sub>1</sub> -<span class="hidden">&#8681;</span><sub>a</sub> ADDR bi<span class="hidden">&#8681;</span><sub>2</sub> ba<span class="hidden">&#8681;</span><sub>2</sub> = ba<span class="hidden">&#8681;</span><sub>1</sub> -<span class="hidden">&#8681;</span><sub>a</sub> ba<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>abase_addr_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abase = (&#955;(ADDR bi ba) &#8658; abase ba)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>addr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>acomp_addr_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(~<span class="hidden">&#8681;</span><sub>a</sub>) = (&#955;ADDR bi<span class="hidden">&#8681;</span><sub>1</sub> ba<span class="hidden">&#8681;</span><sub>1</sub> &#8658; &#955;ADDR bi<span class="hidden">&#8681;</span><sub>2</sub> ba<span class="hidden">&#8681;</span><sub>2</sub> &#8658; bi<span class="hidden">&#8681;</span><sub>1</sub>=bi<span class="hidden">&#8681;</span><sub>2</sub> &#8743; ba<span class="hidden">&#8681;</span><sub>1</sub>~<span class="hidden">&#8681;</span><sub>a</sub>ba<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>addr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aidx_addr_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(+<span class="hidden">&#8681;</span><sub>a</sub>) = (&#955;ADDR bi ba &#8658; &#955;i. ADDR bi (ba +<span class="hidden">&#8681;</span><sub>a</sub> i))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>addr.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>adiff_addr_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(-<span class="hidden">&#8681;</span><sub>a</sub>) = (&#955;ADDR bi<span class="hidden">&#8681;</span><sub>1</sub> ba<span class="hidden">&#8681;</span><sub>1</sub> &#8658; &#955;ADDR bi<span class="hidden">&#8681;</span><sub>2</sub> ba<span class="hidden">&#8681;</span><sub>2</sub> &#8658; ba<span class="hidden">&#8681;</span><sub>1</sub> -<span class="hidden">&#8681;</span><sub>a</sub> ba<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>addr.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>part_equivpI</span><span> </span><span>sympI</span><span> </span><span>transpI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>acompat_equiv</span><span> </span><span>acompat_addr.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>part_equivp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>abase_addr_alt</span><span> </span><span>acomp_addr_alt</span><span> </span><span>aidx_addr_alt</span><span> </span><span>adiff_addr_alt</span><span> </span><span>acompat_dom</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>addr.splits</span><span> 
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>acompat_sym</span><span> </span><span>acompat_trans</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>    
</span><span>    
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


