<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory IICF_Abs_Heapmap (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory IICF_Abs_Heapmap</h1>

<span class="command">theory</span> <span class="name">IICF_Abs_Heapmap</span><br/>
<span class="keyword">imports</span> <a href="IICF_Abs_Heap.html"><span class="name">IICF_Abs_Heap</span></a> <a href="IICF_Prio_Map.html"><span class="name">IICF_Prio_Map</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Priority Maps implemented with List and Map&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IICF_Abs_Heapmap</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IICF_Abs_Heap</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Library.Rewrite&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;../../Intf/IICF_Prio_Map&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;k</span><span class="delimiter">,</span><span class="tfree">&#39;v</span><span class="delimiter">)</span><span> </span><span>ahm</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;k list &#215; (&#39;k &#8640; &#39;v)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Basic Setup&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;First, we define a mapping to list-based heaps&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hmr_&#945;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; &#39;v heap&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;hmr_&#945; &#8801; &#955;(pq,m). map (the o m) pq&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmr_invar &#8801; &#955;(pq,m). distinct pq &#8743; dom m &#8839; set pq&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmr_rel &#8801; br hmr_&#945; hmr_invar&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hmr_rel_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>hmr_rel_def</span><span> </span><span>hmr_&#945;_def</span><span> </span><span>hmr_invar_def</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmr_empty_invar</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmr_invar ([],Map.empty)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_invar_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>hmstruct</span><span> </span><span class="delimiter">=</span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span>heapstruct</span><span> </span><span>prio</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>prio</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;v &#8658; &#39;b::linorder&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Next, we define a mapping to priority maps.&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>heapmap_&#945;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; (&#39;k &#8640; &#39;v)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_&#945; &#8801; &#955;(pq,m). m |` set pq&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>heapmap_invar</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_invar &#8801; &#955;hm. hmr_invar hm &#8743; h.heap_invar (hmr_&#945; hm)&quot;</span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_rel &#8801; br heapmap_&#945; heapmap_invar&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>heapmap_rel_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>heapmap_rel_def</span><span> </span><span>br_def</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>heapmap_invar_def</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>refine_dref_RELATES</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RELATES hmr_rel&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RELATES_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>h_heap_invarI</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_invar hm &#10233; h.heap_invar (hmr_&#945; hm)&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>heapmap_invar_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmr_invarI</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_invar hm &#10233; hmr_invar hm&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_hmr_&#945;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmr_invar hm &#10233; set (hmr_&#945; hm) = ran (heapmap_&#945; hm)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_&#945;_def</span><span> </span><span>hmr_invar_def</span><span> </span><span>heapmap_&#945;_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Int_absorb1</span><span> </span><span>comp_apply</span><span> </span><span>dom_restrict</span><span> </span><span>image_cong</span><span> </span><span>ran_is_image</span><span> </span><span>restrict_in</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_h_hmr_&#945;_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmr_invar hm &#10233; x &#8712;# h.&#945; (hmr_&#945; hm) &#10231; x &#8712; ran (heapmap_&#945; hm)&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_&#945;_def</span><span> </span><span>hmr_invar_def</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>in_multiset_in_set</span><span> </span><span>ran_is_image</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Int_absorb1</span><span> </span><span>comp_apply</span><span> </span><span>image_cong</span><span> </span><span>restrict_in</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Basic Operations&#8250;</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* length, val_of_op, update, butlast, append, empty *)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In this section, we define the basic operations on heapmaps, 
      and their relations to heaps and maps.&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Length&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Length of the list that represents the heap&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_length</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_length &#8801; &#955;(pq,_). length pq&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_length_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_length, length) &#8712; hmr_rel &#8594; nat_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_length_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_rel_defs</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_length_hmr_&#945;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (hmr_&#945; hm) = hm_length hm&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_length_def</span><span> </span><span>hmr_&#945;_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_length_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Valid&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Check whether index is valid&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_valid hm i &#8801; i&gt;0 &#8743; i&#8804; hm_length hm&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_valid_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_valid,h.valid)&#8712;hmr_rel &#8594; nat_rel &#8594; bool_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_valid_def</span><span> </span><span>h.valid_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>parametricity</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hm_length_refine</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_valid_hmr_&#945;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h.valid (hmr_&#945; hm) = hm_valid hm&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>h.valid_def</span><span> </span><span>hm_valid_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Has-Child&#8250;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_has_child_op hm k &#10231; 2*k &#8804; hm_length hm&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_left_child_op (k::nat) &#8801; 2*k&quot;</span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_next_child_op (k::nat) &#8801; k+1&quot;</span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_has_next_child_op hm k &#8801; k+1 &#8804; hm_length hm&quot;</span></span></span><span>   
</span><span>    
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Key-Of&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_key_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; nat &#8658; &#39;k&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_key_of &#8801; &#955;(pq,m) i. pq!(i - 1)&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_key_of_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; nat &#8658; &#39;k nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_key_of_op &#8801; &#955;(pq,m) i. ASSERT (i&gt;0) &#10914; mop_list_get pq (i - 1)&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_key_of_op_unfold</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_key_of_op hm i = ASSERT (hm_valid hm i) &#10914; RETURN (hm_key_of hm i)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span> </span><span>hm_key_of_op_def</span><span> </span><span>hm_key_of_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_eq_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>val_of_hmr_&#945;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_valid hm i &#10233; h.val_of (hmr_&#945; hm) i 
      = the (heapmap_&#945; hm (hm_key_of hm i))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_&#945;_def</span><span> </span><span>h.val_of_def</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hm_key_of_def</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_&#945;_key_ex</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hmr_invar hm; hm_valid hm i&#10215; &#10233; (heapmap_&#945; hm (hm_key_of hm i) &#8800; None)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_invar_def</span><span> </span><span>hmr_invar_def</span><span> </span><span>hm_valid_def</span><span> </span><span>heapmap_&#945;_def</span><span> 
</span><span>        </span><span>hm_key_of_def</span><span> </span><span>hm_length_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>domD</span><span> </span><span>in_set_conv_nth</span><span> </span><span>nz_le_conv_less</span><span> </span><span>subset_code</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Lookup&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hm_lookup</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_lookup &#8801; heapmap_&#945;&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_the_lookup_op k hm &#8801; 
      ASSERT (heapmap_&#945; hm k &#8800; None &#8743; hmr_invar hm) 
      &#10914; RETURN (the (heapmap_&#945; hm k))&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*definition &quot;hm_the_lookup_op&#39; hm k &#8801; do {
      let (pq,ml) = hm;
      (*ASSERT (heapmap_&#945; (hm_impl1_&#945; hm) k &#8800; None &#8743; hm_impl1_invar hm);*)
      v &#8592; mop_map_lookup ml k;
      RETURN v
    }&quot;
      
    lemma hm_the_lookup_op&#39;_refine: 
      &quot;(hm_the_lookup_op&#39;, hm_the_lookup_op) &#8712; hmr_rel &#8594; nat_rel &#8594; &#10216;Id&#10217;nres_rel&quot;
      apply (intro fun_relI nres_relI)
      unfolding hm_the_lookup_op&#39;_def hm_the_lookup_op_def
      apply refine_vcg
      apply (auto)
      apply (auto simp: hm_impl1_rel_defs heapmap_&#945;_def hmr_invar_def split: if_split_asm)
      done
    *)</span></span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Exchange&#8250;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Exchange two indices&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_exch_op &#8801; &#955;(pq,m) i j. do {
      ASSERT (hm_valid (pq,m) i);
      ASSERT (hm_valid (pq,m) j);
      ASSERT (hmr_invar (pq,m));
      pq &#8592; mop_list_swap pq (i - 1) (j - 1);
      RETURN (pq,m)
    }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_exch_op_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_exch_op hm i j &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC hmr_invar&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_exch_op_def</span><span> </span><span>h.exch_op_def</span><span> </span><span>h.val_of_op_def</span><span> </span><span>h.update_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_valid_def</span><span> </span><span>map_swap</span><span> </span><span>hm_length_def</span><span> </span><span>hmr_rel_defs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_exch_op_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_exch_op,h.exch_op) &#8712; hmr_rel &#8594; nat_rel &#8594; nat_rel &#8594; &#10216;hmr_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_exch_op_def</span><span> </span><span>h.exch_op_def</span><span> </span><span>h.val_of_op_def</span><span> </span><span>h.update_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_valid_def</span><span> </span><span>map_swap</span><span> </span><span>hm_length_def</span><span> </span><span>hmr_rel_defs</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_exch_op_refine&#39;</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_exch_op_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_exch</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; nat &#8658; nat &#8658; (&#39;k,&#39;v) ahm&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_exch &#8801; &#955;(pq,m) i j. (swap pq (i-1) (j-1),m)&quot;</span></span></span><span>
</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_exch_op_&#945;_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_exch_op hm i j &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. 
      hm_valid hm i &#8743; hm_valid hm j &#8743; hm&#39;=hm_exch hm i j
      )&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_exch_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hm_key_of_def</span><span> </span><span>hm_exch_def</span><span> </span><span>swap_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_exch_&#945;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hm_valid hm i; hm_valid hm j&#10215; 
      &#10233; heapmap_&#945; (hm_exch hm i j) = (heapmap_&#945; hm)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hm_exch_def</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_exch_valid</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_valid (hm_exch hm i j) = hm_valid hm&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span> </span><span>hm_exch_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_exch_length</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_length (hm_exch hm i j) = hm_length hm&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_length_def</span><span> </span><span>hm_exch_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_exch_same</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_exch hm i i = hm&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_exch_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_key_of_exch_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hm_valid hm i; hm_valid hm j; hm_valid hm k&#10215; &#10233; 
        hm_key_of (hm_exch hm i j) k = (
          if k=i then hm_key_of hm j
          else if k=j then hm_key_of hm i
          else hm_key_of hm k
          )&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_exch_def</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span> </span><span>hm_key_of_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_key_of_exch_matching</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hm_valid hm i; hm_valid hm j&#10215; &#10233; hm_key_of (hm_exch hm i j) i = hm_key_of hm j&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hm_valid hm i; hm_valid hm j&#10215; &#10233; hm_key_of (hm_exch hm i j) j = hm_key_of hm i&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Index&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Obtaining the index of a key&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_index &#8801; &#955;(pq,m) k. index pq k + 1&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_index_valid</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hmr_invar hm; heapmap_&#945; hm k &#8800; None&#10215; &#10233; hm_valid hm (hm_index hm k)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_valid_def</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hmr_invar_def</span><span> </span><span>hm_index_def</span><span> </span><span>hm_length_def</span><span> </span><span>Suc_le_eq</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>restrict_map_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_index_key_of</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hmr_invar hm; heapmap_&#945; hm k &#8800; None&#10215; &#10233; hm_key_of hm (hm_index hm k) = k&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_valid_def</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hmr_invar_def</span><span> </span><span>hm_index_def</span><span> </span><span>hm_length_def</span><span> </span><span>hm_key_of_def</span><span> </span><span>Suc_le_eq</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>restrict_map_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_index_op &#8801; &#955;(pq,m) k. 
      do {
        ASSERT (hmr_invar (pq,m) &#8743; heapmap_&#945; (pq,m) k &#8800; None);
        i &#8592; mop_list_index pq k;
        RETURN (i+1)
      }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_index_op_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmr_invar hm&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_&#945; hm k &#8800; None&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_index_op hm k &#8804; SPEC (&#955;r. r= hm_index hm k)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_index_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hmr_invar_def</span><span> </span><span>hm_index_def</span><span> </span><span>index_nth_id</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>refine_vcg</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_index_op_correct</span><span>  
</span><span>      
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Update&#8250;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Updating the heap at an index&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_update_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; nat &#8658; &#39;v &#8658; (&#39;k,&#39;v) ahm nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_update_op &#8801; &#955;(pq,m) i v. do {
        ASSERT (hm_valid (pq,m) i &#8743; hmr_invar (pq,m));
        k &#8592; mop_list_get pq (i - 1);
        RETURN (pq, m(k &#8614; v))
      }&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_update_op_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_update_op hm k v &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC hmr_invar&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_update_op_def</span><span> </span><span>h.update_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_rel_defs</span><span> </span><span>map_distinct_upd_conv</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_update_op_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_update_op, h.update_op) &#8712; hmr_rel &#8594; nat_rel &#8594; Id &#8594; &#10216;hmr_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_update_op_def</span><span> </span><span>h.update_op_def</span><span> </span><span>mop_list_get_alt</span><span> </span><span>mop_list_set_alt</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_rel_defs</span><span> </span><span>map_distinct_upd_conv</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_update_op_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_update_op_&#945;_correct</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmr_invar hm&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_&#945; hm k &#8800; None&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_update_op hm (hm_index hm k) v &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. heapmap_&#945; hm&#39; = (heapmap_&#945; hm)(k&#8614;v))&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_update_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_rel_defs</span><span> </span><span>hmr_rel_defs</span><span> </span><span>hm_index_def</span><span> </span><span>restrict_map_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Butlast&#8250;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Remove last element&#8250;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_butlast_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; (&#39;k,&#39;v) ahm nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_butlast_op &#8801; &#955;(pq,m). do {
        ASSERT (hmr_invar (pq,m));
        ASSERT (pq&#8800;[]);
        k &#8592; mop_list_get pq (length pq - 1);
        pq &#8592; mop_list_butlast pq;
        RETURN (pq,m)
      }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_butlast_op_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_butlast_op, h.butlast_op) &#8712; hmr_rel &#8594; &#10216;hmr_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>map_upd_eq_restrict</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_butlast_op_def</span><span> </span><span>h.butlast_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_rel_defs</span><span> </span><span>map_butlast</span><span> </span><span>distinct_butlast</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>neq_Nil_rev_conv</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_butlast_op_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_butlast_op_&#945;_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_butlast_op hm &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (
      &#955;hm&#39;. heapmap_&#945; hm&#39; = (heapmap_&#945; hm)( hm_key_of hm (hm_length hm) := None ))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AUX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[] 
        &#10233; set (butlast xs) = (if xs!(length xs - 1) &#8712; set (butlast xs) then set xs else set xs - {xs!(length xs - 1)})&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a list&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AUX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; distinct xs; xs&#8800;[] &#10215; &#10233; set (butlast xs) = set xs - {xs!(length xs - 1)}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a list&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_butlast_op_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hm_key_of_def</span><span> </span><span>hm_length_def</span><span> </span><span>hmr_invar_def</span><span> </span><span>AUX</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Append&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Append new element at end of heap&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_append_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; &#39;k &#8658; &#39;v &#8658; (&#39;k,&#39;v) ahm nres&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_append_op &#8801; &#955;(pq,m) k v. do {
        ASSERT (k &#8713; set pq);
        ASSERT (hmr_invar (pq,m));
        pq &#8592; mop_list_append pq k;
        let m = m (k &#8614; v);
        RETURN (pq,m)
      }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_append_op_invar</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_append_op hm k v &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC hmr_invar&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_append_op_def</span><span> </span><span>h.append_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hmr_rel_defs</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_append_op_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; heapmap_&#945; hm k = None; (hm,h)&#8712;hmr_rel &#10215; 
      &#10233; (hm_append_op hm k v, h.append_op h v) &#8712; &#10216;hmr_rel&#10217;nres_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_append_op_def</span><span> </span><span>h.append_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hmr_rel_defs</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_append_op_refine&#39;</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_append_op_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_append_op_&#945;_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_append_op hm k v &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. heapmap_&#945; hm&#39; = (heapmap_&#945; hm) (k &#8614; v))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_append_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_&#945;_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Auxiliary Operations&#8250;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Auxiliary operations on heapmaps, which are derived 
      from the basic operations, but do not correspond to 
      operations of the priority map interface&#8250;</span></span></span><span>
</span><span>    
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We start with some setup&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heapmap_hmr_relI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm,h)&#8712;heapmap_rel &#10233; (hm,hmr_&#945; hm) &#8712; hmr_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_rel_defs</span><span> </span><span>hmr_rel_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heapmap_hmr_relI&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_invar hm &#10233; (hm,hmr_&#945; hm) &#8712; hmr_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_rel_defs</span><span> </span><span>hmr_rel_defs</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The basic principle how we prove correctness of our operations:
      Invariant preservation is shown by relating the operations to 
      operations on heaps. Then, only correctness on the abstraction 
      remains to be shown, assuming the operation does not fail.
      &#8250;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heapmap_nres_relI&#39;</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm &#8804; &#8659;hmr_rel h&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h&#39; &#8804; SPEC (h.heap_invar)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. RETURN (heapmap_&#945; hm&#39;) &#8804; h)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm &#8804; &#8659;heapmap_rel h&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_defs</span><span> </span><span>hmr_rel_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>pw_leof_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heapmap_nres_relI&#39;&#39;</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm &#8804; &#8659;hmr_rel h&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h&#39; &#8804; SPEC &#934;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;h&#39;. &#934; h&#39; &#10233; h.heap_invar h&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. RETURN (heapmap_&#945; hm&#39;) &#8804; h)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm &#8804; &#8659;heapmap_rel h&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heapmap_nres_relI&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">,</span><span> </span><span>fact</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">;</span><span> </span><span>fact</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fact</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Val-of&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Indexing into the heap&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_val_of_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; nat &#8658; &#39;v nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_val_of_op &#8801; &#955;hm i. do {
        k &#8592; hm_key_of_op hm i;
        v &#8592; hm_the_lookup_op k hm;
        RETURN v
      }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_val_of_op_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_val_of_op,h.val_of_op) &#8712; (hmr_rel &#8594; nat_rel &#8594; &#10216;Id&#10217;nres_rel)&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_val_of_op_def</span><span> </span><span>h.val_of_op_def</span><span> 
</span><span>        </span><span>hm_key_of_op_def</span><span> </span><span>hm_key_of_def</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span>
</span><span>        </span><span>hm_the_lookup_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refine_IdD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_rel_defs</span><span> </span><span>in_br_conv</span><span> </span><span>heapmap_&#945;_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>domD</span><span> </span><span>nth_mem</span><span> </span><span>subsetCE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_val_of_op_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Prio-of&#8250;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Priority of key&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_prio_of_op h i &#8801; do {v &#8592; hm_val_of_op h i; RETURN (prio v)}&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_prio_of_op_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_prio_of_op, h.prio_of_op) &#8712; hmr_rel &#8594; nat_rel &#8594; &#10216;Id&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_prio_of_op_def</span><span> </span><span>h.prio_of_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_prio_of_op_refine&#39;</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_prio_of_op_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Swim&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_swim_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; nat &#8658; (&#39;k,&#39;v) ahm nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_swim_op h i &#8801; do {
        RECT (&#955;swim (h,i). do {
          ASSERT (hm_valid h i &#8743; h.swim_invar (hmr_&#945; h) i);
          if hm_valid h (h.parent i) then do {
            ppi &#8592; hm_prio_of_op h (h.parent i);
            pi &#8592; hm_prio_of_op h i;
            if (&#172;ppi &#8804; pi) then do {
              h &#8592; hm_exch_op h i (h.parent i);
              swim (h, h.parent i)
            } else
              RETURN h
          } else 
            RETURN h
        }) (h,i)
      }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_swim_op_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_swim_op, h.swim_op) &#8712; hmr_rel &#8594; nat_rel &#8594; &#10216;hmr_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_swim_op_def</span><span> </span><span>h.swim_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_valid_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>IdD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hmr_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_swim_op_refine&#39;</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_swim_op_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_swim_op_nofail_imp_valid</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;nofail (hm_swim_op hm i) &#10233; hm_valid hm i &#8743; h.swim_invar (hmr_&#945; hm) i&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_swim_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>RECT_unfold</span><span class="delimiter">,</span><span> </span><span>refine_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_swim_op_&#945;_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_swim_op hm i &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. heapmap_&#945; hm&#39; = heapmap_&#945; hm)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>leof_add_nofailI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>hm_swim_op_nofail_imp_valid</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_swim_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RECT_rule_leof</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>            </span><span>pre</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;(hm&#39;,i). hm_valid hm&#39; i &#8743; heapmap_&#945; hm&#39; = heapmap_&#945; hm&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_image less_than snd&quot;</span></span></span><span>
</span><span>            </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_prio_of_op_def</span><span> </span><span>hm_val_of_op_def</span><span> 
</span><span>        </span><span>hm_exch_op_def</span><span> </span><span>hm_key_of_op_def</span><span> </span><span>hm_the_lookup_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rprems</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>h.parent_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Sink&#8250;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_sink_op</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span>   
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_sink_op h k &#8801; RECT (&#955;D (h,k). do {
        ASSERT (k&gt;0 &#8743; k&#8804;hm_length h);
        if hm_has_child_op h k then do {
          let j = hm_left_child_op k;
          pj &#8592; hm_prio_of_op h j;

          j &#8592; (
            if hm_has_next_child_op h j then do {
              let j&#39; = hm_next_child_op j;
              psj &#8592; hm_prio_of_op h j&#39;;
              if pj&gt;psj then RETURN j&#39; else RETURN j
            } else RETURN j);

          pj &#8592; hm_prio_of_op h j;
          pk &#8592; hm_prio_of_op h k;
          if (pk &gt; pj) then do {
            h &#8592; hm_exch_op h k j;
            D (h,j)
          } else
            RETURN h
        } else RETURN h    
      }) (h,k)&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_sink_op_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_sink_op, h.sink_op) &#8712; hmr_rel &#8594; nat_rel &#8594; &#10216;hmr_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_sink_op_def</span><span> </span><span>h.sink_op_opt_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>h.sink_op_opt_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_has_child_op_def</span><span> </span><span>hm_has_next_child_op_def</span><span>
</span><span>        </span><span>hm_left_child_op_def</span><span> </span><span>hm_next_child_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;let _ = length _ in _&quot;</span></span></span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;let _ = _ + 1 in _&quot;</span></span></span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_dref_type</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hmr_rel_def</span><span> </span><span>heapmap_rel_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_sink_op_refine&#39;</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_sink_op_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_sink_op_nofail_imp_valid</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nofail (hm_sink_op hm i) &#10233; hm_valid hm i&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_sink_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>RECT_unfold</span><span class="delimiter">,</span><span> </span><span>refine_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>refine_pw_simps</span><span> </span><span>hm_valid_def</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_sink_op_&#945;_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_sink_op hm i &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. heapmap_&#945; hm&#39; = heapmap_&#945; hm)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>leof_add_nofailI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>hm_sink_op_nofail_imp_valid</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_sink_op_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_left_child_op_def</span><span> </span><span>hm_has_child_op_def</span><span> </span><span>hm_has_next_child_op_def</span><span> </span><span>hm_next_child_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RECT_rule_leof</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>            </span><span>pre</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;(hm&#39;,i). hm_valid hm&#39; i &#8743; heapmap_&#945; hm&#39; = heapmap_&#945; hm &#8743; hm_length hm&#39; = hm_length hm&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;measure (&#955;(hm&#39;,i). hm_length hm&#39; - i)&quot;</span></span></span><span>
</span><span>            </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_prio_of_op_def</span><span> </span><span>hm_val_of_op_def</span><span> </span><span>hm_exch_op_def</span><span> 
</span><span>        </span><span>hm_key_of_op_def</span><span> </span><span>hm_the_lookup_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Takes long *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rprems</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>h.parent_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Repair&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_repair_op hm i &#8801; do {
      hm &#8592; hm_sink_op hm i;
      hm &#8592; hm_swim_op hm i;
      RETURN hm
    }&quot;</span></span></span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_repair_op_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_repair_op, h.repair_op) &#8712; hmr_rel &#8594; nat_rel &#8594; &#10216;hmr_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_repair_op_def</span><span> </span><span>h.repair_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>refine_rcg</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hm_repair_op_refine&#39;</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hm_repair_op_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_repair_op_&#945;_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_repair_op hm i &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. heapmap_&#945; hm&#39; = heapmap_&#945; hm)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_repair_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> 
</span><span>        </span><span>hm_swim_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>hm_sink_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Operations&#8250;</span></span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In this section, we define the operations that implement the priority-map interface&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Empty&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_empty_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm nres&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_empty_op &#8801; do { m&#8592;mop_map_empty; RETURN ([],m) }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_empty_op_aref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_empty_op,mop_map_empty) &#8712; &#10216;heapmap_rel&#10217;nres_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_empty_op_def</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_rel_defs</span><span> </span><span>hmr_rel_defs</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Insert&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_insert_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;k &#8658; &#39;v &#8658; (&#39;k,&#39;v) ahm &#8658; (&#39;k,&#39;v) ahm nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_insert_op &#8801; &#955;k v h. do {
        ASSERT (h.heap_invar (hmr_&#945; h));
        h &#8592; hm_append_op h k v;
        let l = hm_length h;
        h &#8592; hm_swim_op h l;
        RETURN h
      }&quot;</span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_insert_op_refine</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; heapmap_&#945; hm k = None; (hm,h)&#8712;hmr_rel &#10215; &#10233;
      hm_insert_op k v hm &#8804; &#8659;hmr_rel (h.insert_op v h)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_insert_op_def</span><span> </span><span>h.insert_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_insert_op_aref</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_insert_op,mop_map_update_new) &#8712; Id &#8594; Id &#8594; heapmap_rel &#8594; &#10216;heapmap_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mop_map_update_new_alt</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ASSERT_refine_right</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heapmap_nres_relI&#39;&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hm_insert_op_refine</span><span> </span><span>h.insert_op_correct</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>heapmap_hmr_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_insert_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> 
</span><span>        </span><span>hm_append_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>hm_swim_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Is-Empty&#8250;</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hmr_&#945;_empty_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hmr_invar hm &#10233; hmr_&#945; hm = [] &#10231; heapmap_&#945; hm = Map.empty&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_&#945;_def</span><span> </span><span>heapmap_invar_def</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hmr_invar_def</span><span> </span><span>restrict_map_def</span><span> </span><span>fun_eq_iff</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_is_empty_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; bool nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_is_empty_op &#8801; &#955;hm. do {
        ASSERT (hmr_invar hm);
        let l = hm_length hm;
        RETURN (l=0)
      }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_is_empty_op_refine</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_is_empty_op, h.is_empty_op) &#8712; hmr_rel &#8594; &#10216;bool_rel&#10217;nres_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_is_empty_op_def</span><span> </span><span>h.is_empty_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_rel_defs</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>parametricity</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hm_length_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_is_empty_op_aref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_is_empty_op, mop_map_is_empty) &#8712; heapmap_rel &#8594; &#10216;bool_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_is_empty_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_rel_defs</span><span> </span><span>in_br_conv</span><span> </span><span>heapmap_rel_defs</span><span> </span><span>hm_length_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Int_absorb1</span><span> </span><span>dom_restrict</span><span> </span><span>length_greater_0_conv</span><span> </span><span>ndomIff</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Lookup&#8250;</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_lookup_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;k &#8658; (&#39;k,&#39;v) ahm &#8658; &#39;v option nres&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_lookup_op &#8801; &#955;k hm. ASSERT (heapmap_invar hm) &#10914; RETURN (hm_lookup hm k)&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_lookup_op_aref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_lookup_op,RETURN oo op_map_lookup) &#8712; Id &#8594; heapmap_rel &#8594; &#10216;&#10216;Id&#10217;option_rel&#10217;nres_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_lookup_op_def</span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_the_lookup_op_aref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_the_lookup_op,mop_map_the_lookup) &#8712; Id &#8594; heapmap_rel &#8594; &#10216;Id&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_the_lookup_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>nres_relI</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_eq_iff</span><span> </span><span>refine_pw_simps</span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Contains-Key&#8250;</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_contains_key_op &#8801; &#955;k (pq,m). ASSERT (heapmap_invar (pq,m)) &#10914; mop_list_contains k pq&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_contains_key_op_aref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_contains_key_op,mop_map_contains_key) &#8712; Id &#8594; heapmap_rel &#8594; &#10216;bool_rel&#10217;nres_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_contains_key_op_def</span><span> </span><span>heapmap_rel_defs</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hmr_invar_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decrease-Key&#8250;</span></span></span><span>  
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_decrease_key_op &#8801; &#955;k v hm. do {
      ASSERT (heapmap_invar hm);
      ASSERT (heapmap_&#945; hm k &#8800; None &#8743; prio v &#8804; prio (the (heapmap_&#945; hm k)));
      i &#8592; hm_index_op hm k;
      hm &#8592; hm_update_op hm i v;
      hm_swim_op hm i
    }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>heapstruct</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;decrease_key_op i v h &#8801; do {
      ASSERT (valid h i &#8743; prio v &#8804; prio_of h i);
      h &#8592; update_op h i v;
      swim_op h i
    }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>heapstruct</span><span class="delimiter">)</span><span> </span><span>decrease_key_op_invar</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;heap_invar h; valid h i; prio v &#8804; prio_of h i&#10215; &#10233; decrease_key_op i v h &#8804; SPEC heap_invar&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decrease_key_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swim_invar_decr</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>index_op_inline_refine</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_invar hm&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_&#945; hm k &#8800; None&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f (hm_index hm k) &#8804; m&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;do {i &#8592; hm_index_op hm k; f i} &#8804; m&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hm_index_op_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>hm</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_decrease_key_op_refine</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(hm,h)&#8712;hmr_rel; (hm,m)&#8712;heapmap_rel; m k = Some v&#39;&#10215; 
        &#10233; hm_decrease_key_op k v hm &#8804;&#8659;hmr_rel (h.decrease_key_op (hm_index hm k) v h)&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_decrease_key_op_def</span><span> </span><span>h.decrease_key_op_def</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply (rewrite at &quot;Let (hm_index hm k) _&quot; Let_def)*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>index_op_inline_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hmr_rel_def</span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_index_op_inline_leof</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f (hm_index hm k) &#8804;<span class="hidden">&#8681;</span><sub>n</sub> m&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;do {i &#8592; hm_index_op hm k; f i} &#8804;<span class="hidden">&#8681;</span><sub>n</sub> m&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hm_index_op_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>hm</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_index_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>pw_leof_iff</span><span> </span><span>refine_pw_simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_decrease_key_op_&#945;_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_invar hm &#10233; hm_decrease_key_op k v hm &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. heapmap_&#945; hm&#39; = heapmap_&#945; hm(k&#8614;v))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_decrease_key_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> 
</span><span>        </span><span>hm_update_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>hm_swim_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>hm_index_op_inline_leof</span><span>
</span><span>        </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_decrease_key_op_aref</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_decrease_key_op, PR_CONST (mop_pm_decrease_key prio)) &#8712; Id &#8594; Id &#8594; heapmap_rel &#8594; &#10216;heapmap_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>heapmap_hmr_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mop_pm_decrease_key_alt</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ASSERT_refine_right</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heapmap_nres_relI&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hm_decrease_key_op_refine</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_def</span><span> </span><span>hmr_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>h.decrease_key_op_invar</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>hm_decrease_key_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Increase-Key&#8250;</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_increase_key_op &#8801; &#955;k v hm. do {
      ASSERT (heapmap_invar hm);
      ASSERT (heapmap_&#945; hm k &#8800; None &#8743; prio v &#8805; prio (the (heapmap_&#945; hm k)));
      i &#8592; hm_index_op hm k;
      hm &#8592; hm_update_op hm i v;
      hm_sink_op hm i
    }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>heapstruct</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;increase_key_op i v h &#8801; do {
      ASSERT (valid h i &#8743; prio v &#8805; prio_of h i);
      h &#8592; update_op h i v;
      sink_op h i
    }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>heapstruct</span><span class="delimiter">)</span><span> </span><span>increase_key_op_invar</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;heap_invar h; valid h i; prio v &#8805; prio_of h i&#10215; &#10233; increase_key_op i v h &#8804; SPEC heap_invar&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>increase_key_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sink_invar_incr</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_increase_key_op_refine</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(hm,h)&#8712;hmr_rel; (hm,m)&#8712;heapmap_rel; m k = Some v&#39;&#10215; 
        &#10233; hm_increase_key_op k v hm &#8804;&#8659;hmr_rel (h.increase_key_op (hm_index hm k) v h)&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_increase_key_op_def</span><span> </span><span>h.increase_key_op_def</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply (rewrite at &quot;Let (hm_index hm k) _&quot; Let_def)*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>index_op_inline_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hmr_rel_def</span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_increase_key_op_&#945;_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_invar hm &#10233; hm_increase_key_op k v hm &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. heapmap_&#945; hm&#39; = heapmap_&#945; hm(k&#8614;v))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_increase_key_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> 
</span><span>        </span><span>hm_update_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>hm_sink_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>hm_index_op_inline_leof</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_increase_key_op_aref</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_increase_key_op, PR_CONST (mop_pm_increase_key prio)) &#8712; Id &#8594; Id &#8594; heapmap_rel &#8594; &#10216;heapmap_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>heapmap_hmr_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mop_pm_increase_key_alt</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ASSERT_refine_right</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heapmap_nres_relI&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hm_increase_key_op_refine</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_def</span><span> </span><span>hmr_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>h.increase_key_op_invar</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>hm_increase_key_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Change-Key&#8250;</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_change_key_op &#8801; &#955;k v hm. do {
      ASSERT (heapmap_invar hm);
      ASSERT (heapmap_&#945; hm k &#8800; None);
      i &#8592; hm_index_op hm k;
      hm &#8592; hm_update_op hm i v;
      hm_repair_op hm i
    }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>heapstruct</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;change_key_op i v h &#8801; do {
      ASSERT (valid h i);
      h &#8592; update_op h i v;
      repair_op h i
    }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>heapstruct</span><span class="delimiter">)</span><span> </span><span>change_key_op_invar</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;heap_invar h; valid h i&#10215; &#10233; change_key_op i v h &#8804; SPEC heap_invar&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>change_key_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sink_invar_incr</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_change_key_op_refine</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(hm,h)&#8712;hmr_rel; (hm,m)&#8712;heapmap_rel; m k = Some v&#39;&#10215; 
        &#10233; hm_change_key_op k v hm &#8804;&#8659;hmr_rel (h.change_key_op (hm_index hm k) v h)&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_change_key_op_def</span><span> </span><span>h.change_key_op_def</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply (rewrite at &quot;Let (hm_index hm k) _&quot; Let_def)*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>index_op_inline_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hmr_rel_def</span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp_all</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_change_key_op_&#945;_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_invar hm &#10233; hm_change_key_op k v hm &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. heapmap_&#945; hm&#39; = heapmap_&#945; hm(k&#8614;v))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_change_key_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> 
</span><span>        </span><span>hm_update_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>hm_repair_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>hm_index_op_inline_leof</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_change_key_op_aref</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_change_key_op, mop_map_update_ex) &#8712; Id &#8594; Id &#8594; heapmap_rel &#8594; &#10216;heapmap_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>heapmap_hmr_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mop_map_update_ex_alt</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ASSERT_refine_right</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heapmap_nres_relI&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hm_change_key_op_refine</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_def</span><span> </span><span>hmr_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>h.change_key_op_invar</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span> </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>hm_change_key_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Set&#8250;</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Realized as generic algorithm!&#8250;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Implement as such! *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>op_pm_set_gen_impl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;RETURN ooo op_map_update = (&#955;k v m. do {
      c &#8592; RETURN (op_map_contains_key k m);
      if c then 
        mop_map_update_ex k v m
      else
        mop_map_update_new k v m
    })&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_map_contains_key_def</span><span> </span><span>mop_map_update_ex_def</span><span> </span><span>mop_map_update_new_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_set_op k v hm &#8801; do {
      c &#8592; hm_contains_key_op k hm;
      if c then
        hm_change_key_op k v hm
      else
        hm_insert_op k v hm
    }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move. Near RETURN_to_SPEC_rule *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>RETURN_to_SPEC_rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SPEC_to_RETURN_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m &#8804; RETURN x &#10233; m &#8804; SPEC ((=) x)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_set_op_aref</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_set_op, mop_map_update) &#8712; Id &#8594; Id &#8594; heapmap_rel &#8594; &#10216;heapmap_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>op_pm_set_gen_impl</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_set_op_def</span><span> </span><span>o_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hm_contains_key_op_aref</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hm_change_key_op_aref</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hm_insert_op_aref</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>pw_nres_rel_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** Takes long *)</span></span></span></span></span><span>
</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pop-Min&#8250;</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_pop_min_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; ((&#39;k&#215;&#39;v) &#215; (&#39;k,&#39;v) ahm) nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_pop_min_op hm &#8801; do {
        ASSERT (heapmap_invar hm);
        ASSERT (hm_valid hm 1);
        k &#8592; hm_key_of_op hm 1;
        v &#8592; hm_the_lookup_op k hm;
        let l = hm_length hm;
        hm &#8592; hm_exch_op hm 1 l;
        hm &#8592; hm_butlast_op hm;
        
        if (l&#8800;1) then do {
          hm &#8592; hm_sink_op hm 1;
          RETURN ((k,v),hm)
        } else RETURN ((k,v),hm)
      }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_pop_min_op_refine</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_pop_min_op, h.pop_min_op) &#8712; hmr_rel &#8594; &#10216;UNIV &#215;<span class="hidden">&#8681;</span><sub>r</sub> hmr_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_pop_min_op_def</span><span> </span><span>h.pop_min_op_def</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Project away stuff of second component *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ignore_snd_refine_conv</span><span> </span><span>hm_the_lookup_op_def</span><span> </span><span>hm_key_of_op_unfold</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unused_bind_conv</span><span> </span><span>h.val_of_op_def</span><span> </span><span>refine_pw_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Prove refinement *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hmr_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>heapmap_invar_def</span><span class="delimiter">;</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We demonstrate two different approaches for proving correctness 
      here.
      The first approach uses the relation to plain heaps only to establish
      the invariant. 

      The second approach also uses the relation to heaps to establish 
      correctness of the result.

      The first approach seems to be more robust against badly set 
      up simpsets, which may be the case in early stages of development.

      Assuming a working simpset, the second approach may be less work,
      and the proof may look more elegant.
      &#8250;</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\paragraph{First approach}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Transfer heapmin-property to heapmap-domain&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heapmap_min_prop</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_invar hm&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;heapmap_&#945; hm k = Some v&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_valid hm (Suc 0)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prio (the (heapmap_&#945; hm (hm_key_of hm (Suc 0)))) &#8804; prio v&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>      </span><span class="comment">&#8213; &#8249;Transform into the domain of heaps&#8250;</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pq</span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm=(pq,m)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>hm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pq&#8800;[]&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CNV_LHS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prio (the (heapmap_&#945; hm (hm_key_of hm (Suc 0)))) 
        = h.prio_of (hmr_&#945; hm) (Suc 0)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hm_key_of_def</span><span> </span><span>hmr_&#945;_def</span><span> </span><span>h.val_of_def</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>INV&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h.heap_invar (hmr_&#945; hm)&quot;</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>V&#39;</span><span> </span><span>INV</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>IDX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h.valid (hmr_&#945; hm) i&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CNV_RHS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;prio v&#39; = h.prio_of (hmr_&#945; hm) i&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>heapmap_invar_def</span><span> </span><span>hmr_invar_def</span><span> </span><span>hmr_&#945;_def</span><span>
</span><span>          </span><span>h.valid_def</span><span> </span><span>h.val_of_def</span><span> </span><span>restrict_map_eq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Suc_leI</span><span> </span><span>comp_apply</span><span> </span><span>diff_Suc_Suc</span><span> 
</span><span>          </span><span>diff_zero</span><span> </span><span>index_less_size_conv</span><span> </span><span>neq0_conv</span><span> </span><span>nth_index</span><span> </span><span>nth_map</span><span> 
</span><span>          </span><span>old.nat.distinct</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>option.sel</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>h.heap_min_prop</span><span class="delimiter">[</span><span>OF</span><span> </span><span>INV&#39;</span><span> </span><span>IDX</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CNV_LHS</span><span> </span><span>CNV_RHS</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;With the above lemma, the correctness proof is straightforward&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_pop_min_&#945;_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_pop_min_op hm &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;((k,v),hm&#39;). 
        heapmap_&#945; hm k = Some v 
      &#8743; heapmap_&#945; hm&#39; = (heapmap_&#945; hm)(k:=None) 
      &#8743; (&#8704;k&#39; v&#39;. heapmap_&#945; hm k&#39; = Some v&#39; &#10230; prio v &#8804; prio v&#39;))&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_pop_min_op_def</span><span> </span><span>hm_key_of_op_unfold</span><span> </span><span>hm_the_lookup_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> 
</span><span>        </span><span>hm_exch_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>hm_butlast_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>hm_sink_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>heapmap_min_prop</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heapmap_nres_rel_prodI</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmx &#8804; &#8659;(UNIV &#215;<span class="hidden">&#8681;</span><sub>r</sub> hmr_rel) h&#39;x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h&#39;x &#8804; SPEC (&#955;(_,h&#39;). h.heap_invar h&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmx &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;(r,hm&#39;). RETURN (r,heapmap_&#945; hm&#39;) &#8804; &#8659;(R&#215;<span class="hidden">&#8681;</span><sub>r</sub>Id) hx)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmx &#8804; &#8659;(R&#215;<span class="hidden">&#8681;</span><sub>r</sub>heapmap_rel) hx&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_def</span><span> </span><span>hmr_rel_def</span><span> </span><span>br_def</span><span> </span><span>heapmap_invar_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>pw_leof_iff</span><span> </span><span>refine_pw_simps</span><span class="delimiter">;</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_pop_min_op_aref</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_pop_min_op, PR_CONST (mop_pm_pop_min prio)) &#8712; heapmap_rel &#8594; &#10216;(Id&#215;<span class="hidden">&#8681;</span><sub>r</sub>Id)&#215;<span class="hidden">&#8681;</span><sub>r</sub>heapmap_rel&#10217;nres_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>heapmap_hmr_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mop_pm_pop_min_alt</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ASSERT_refine_right</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heapmap_nres_rel_prodI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hm_pop_min_op_refine</span><span class="delimiter">[</span><span>param_fo</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>nres_relD</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_def</span><span> </span><span>hmr_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>hm_pop_min_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\paragraph{Second approach}&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Alternative approach: Also use knowledge about result
      in multiset domain. Obtaining property seems infeasible at first attempt! *)</span></span></span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_kv_of_op hm i &#8801; do {
      ASSERT (hm_valid hm i &#8743; hmr_invar hm);
      k &#8592; hm_key_of_op hm i;
      v &#8592; hm_the_lookup_op k hm;
      RETURN (k, v)
    }&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;kvi_rel hm i &#8801; {((k,v),v) | k v. hm_key_of hm i = k}&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_kv_op_refine</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm,h)&#8712;hmr_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_kv_of_op hm i &#8804; &#8659;(kvi_rel hm i) (h.val_of_op h i)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_kv_of_op_def</span><span> </span><span>h.val_of_op_def</span><span> </span><span>kvi_rel_def</span><span> 
</span><span>        </span><span>hm_key_of_op_unfold</span><span> </span><span>hm_the_lookup_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hm_valid_def</span><span> </span><span>hm_length_def</span><span> </span><span>hmr_rel_defs</span><span> </span><span>in_br_conv</span><span> </span><span>heapmap_&#945;_def</span><span> </span><span>hm_key_of_def</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>contra_subsetD</span><span> </span><span>domIff</span><span> </span><span>not_None_eq</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_pop_min_op&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; ((&#39;k&#215;&#39;v) &#215; (&#39;k,&#39;v) ahm) nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_pop_min_op&#39; hm &#8801; do {
        ASSERT (heapmap_invar hm);
        ASSERT (hm_valid hm 1);
        kv &#8592; hm_kv_of_op hm 1;
        let l = hm_length hm;
        hm &#8592; hm_exch_op hm 1 l;
        hm &#8592; hm_butlast_op hm;
        
        if (l&#8800;1) then do {
          hm &#8592; hm_sink_op hm 1;
          RETURN (kv,hm)
        } else RETURN (kv,hm)
      }&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_pop_min_op_refine&#39;</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (hm,h)&#8712;hmr_rel &#10215; &#10233; hm_pop_min_op&#39; hm &#8804; &#8659;(kvi_rel hm 1 &#215;<span class="hidden">&#8681;</span><sub>r</sub> hmr_rel) (h.pop_min_op h)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_pop_min_op&#39;_def</span><span> </span><span>h.pop_min_op_def</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Project away stuff of second component *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ignore_snd_refine_conv</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Prove refinement *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_rcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hmr_rel_def</span><span> </span><span>heapmap_rel_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>heapmap_invar_def</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>heapmap_nres_rel_prodI&#39;</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmx &#8804; &#8659;(S &#215;<span class="hidden">&#8681;</span><sub>r</sub> hmr_rel) h&#39;x&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h&#39;x &#8804; SPEC &#934;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;h&#39; r. &#934; (r,h&#39;) &#10233; h.heap_invar h&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmx &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;(r,hm&#39;). (&#8707;r&#39;. (r,r&#39;)&#8712;S &#8743; &#934; (r&#39;,hmr_&#945; hm&#39;)) &#8743; hmr_invar hm&#39; &#10230; RETURN (r,heapmap_&#945; hm&#39;) &#8804; &#8659;(R&#215;<span class="hidden">&#8681;</span><sub>r</sub>Id) hx)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmx &#8804; &#8659;(R&#215;<span class="hidden">&#8681;</span><sub>r</sub>heapmap_rel) hx&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_def</span><span> </span><span>hmr_rel_def</span><span> </span><span>heapmap_invar_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>pw_leof_iff</span><span> </span><span>refine_pw_simps</span><span> </span><span>in_br_conv</span><span>
</span><span>        </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ex_in_kvi_rel_conv</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;r&#39;. (r,r&#39;)&#8712;kvi_rel hm i &#8743; &#934; r&#39;) &#10231; (fst r = hm_key_of hm i &#8743; &#934; (snd r))&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>kvi_rel_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_pop_min_aref&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_pop_min_op&#39;, mop_pm_pop_min prio) &#8712; heapmap_rel &#8594; &#10216;(Id&#215;<span class="hidden">&#8681;</span><sub>r</sub>Id) &#215;<span class="hidden">&#8681;</span><sub>r</sub> heapmap_rel&#10217;nres_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>heapmap_hmr_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mop_pm_pop_min_alt</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>ASSERT_refine_right</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heapmap_nres_rel_prodI&#39;</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>hm_pop_min_op_refine&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>heapmap_rel_def</span><span> </span><span>hmr_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>h.pop_min_op_correct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ex_in_kvi_rel_conv</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_pop_min_op&#39;_def</span><span> </span><span>hm_kv_of_op_def</span><span> </span><span>hm_key_of_op_unfold</span><span>
</span><span>          </span><span>hm_the_lookup_op_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> 
</span><span>          </span><span>hm_exch_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>          </span><span>hm_butlast_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>          </span><span>hm_sink_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_def</span><span> </span><span>hmr_rel_def</span><span> </span><span>in_br_conv</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ranI</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Remove&#8250;</span></span></span><span>  
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_remove_op k hm &#8801; do {
      ASSERT (heapmap_invar hm);
      ASSERT (k &#8712; dom (heapmap_&#945; hm));
      i &#8592; hm_index_op hm k;
      let l = hm_length hm;
      hm &#8592; hm_exch_op hm i l;
      hm &#8592; hm_butlast_op hm;
      if i &#8800; l then
        hm_repair_op hm i
      else  
        RETURN hm
    }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>heapstruct</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;remove_op i h &#8801; do {
      ASSERT (heap_invar h);
      ASSERT (valid h i);
      let l = length h;
      h &#8592; exch_op h i l;
      h &#8592; butlast_op h;
      if i &#8800; l then
        repair_op h i
      else  
        RETURN h
    }&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>swap_empty_iff</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;swap l i j = [] &#10231; l=[]&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swap_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>heapstruct</span><span class="delimiter">)</span><span> 
</span><span>      </span><span>butlast_exch_last</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;butlast (exch h i (length h)) = update (butlast h) i (last h)&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>exch_def</span><span> </span><span>update_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>h</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>swap_def</span><span> </span><span>butlast_list_update</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>heapstruct</span><span class="delimiter">)</span><span> </span><span>remove_op_invar</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; heap_invar h; valid h i &#10215; &#10233; remove_op i h &#8804; SPEC heap_invar&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_def</span><span> </span><span>exch_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>butlast_exch_last</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>valid_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_remove_op_refine</span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (hm,m)&#8712;heapmap_rel; (hm,h)&#8712;hmr_rel; heapmap_&#945; hm k &#8800; None&#10215; &#10233; 
        hm_remove_op k hm &#8804; &#8659;hmr_rel (h.remove_op (hm_index hm k) h)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_remove_op_def</span><span> </span><span>h.remove_op_def</span><span> </span><span>heapmap_rel_def</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply (rewrite at &quot;Let (hm_index hm k) _&quot; Let_def)*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>index_op_inline_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hmr_rel_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_remove_op_&#945;_correct</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_remove_op k hm &#8804;<span class="hidden">&#8681;</span><sub>n</sub> SPEC (&#955;hm&#39;. heapmap_&#945; hm&#39; = (heapmap_&#945; hm)(k:=None))&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_remove_op_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> 
</span><span>        </span><span>hm_exch_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>hm_butlast_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>hm_repair_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span>
</span><span>        </span><span>hm_index_op_inline_leof</span><span>
</span><span>        </span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_index _ k = hm_length _&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>asm</span><span> </span><span>eq_commute</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_remove_op_aref</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_remove_op,mop_map_delete_ex) &#8712; Id &#8594; heapmap_rel &#8594; &#10216;heapmap_rel&#10217;nres_rel&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mop_map_delete_ex_alt</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ASSERT_refine_right</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>heapmap_hmr_relI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>heapmap_nres_relI&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hm_remove_op_refine</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_def</span><span> </span><span>hmr_rel_def</span><span> </span><span>in_br_conv</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>h.remove_op_invar</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>hm_remove_op_&#945;_correct</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>leof_trans</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Peek-Min&#8250;</span></span></span><span> 
</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hm_peek_min_op</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;k,&#39;v) ahm &#8658; (&#39;k&#215;&#39;v) nres&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;hm_peek_min_op hm &#8801; hm_kv_of_op hm 1&quot;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hm_peek_min_op_aref</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(hm_peek_min_op, PR_CONST (mop_pm_peek_min prio)) &#8712; heapmap_rel &#8594; &#10216;Id&#215;<span class="hidden">&#8681;</span><sub>r</sub>Id&#10217;nres_rel&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PR_CONST_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>fun_relI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>hm</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;k &#8640; &#39;v&quot;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(hm,m)&#8712;heapmap_rel&quot;</span></span></span><span>
</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h.heap_invar (hmr_&#945; hm)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hmr_invar hm&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m=heapmap_&#945; hm&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>heapmap_rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>heapmap_invar_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_peek_min_op hm &#8804; &#8659; (kvi_rel hm 1) (h.peek_min_op (hmr_&#945; hm))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hm_peek_min_op_def</span><span>  </span><span>h.peek_min_op_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span> </span><span>hm_kv_op_refine</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>heapmap_hmr_relI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;hmr_&#945; hm &#8800; []&#10215; &#10233; (h.peek_min_op (hmr_&#945; hm)) 
        &#8804; SPEC (&#955;v. v&#8712;ran (heapmap_&#945; hm) &#8743; (&#8704;v&#39;&#8712;ran (heapmap_&#945; hm). prio v &#8804; prio v&#39;))&quot;</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hm_peek_min_op hm &#8804; &#8659; (Id &#215;<span class="hidden">&#8681;</span><sub>r</sub> Id) (mop_pm_peek_min prio m)&quot;</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mop_pm_peek_min_alt</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pw_le_iff</span><span> </span><span>refine_pw_simps</span><span> </span><span>hm_peek_min_op_def</span><span> </span><span>hm_kv_of_op_def</span><span> 
</span><span>            </span><span>hm_key_of_op_unfold</span><span> </span><span>hm_the_lookup_op_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>kvi_rel_def</span><span> </span><span>ran_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


