<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory LLVM_Integer (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory LLVM_Integer</h1>

<span class="command">theory</span> <span class="name">LLVM_Integer</span><br/>
<span class="keyword">imports</span> <a href="Bits_Natural.html"><span class="name">Bits_Natural</span></a> <a href="Word_Lemmas.html"><span class="name">Word_Lemmas</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;LLVM like Integer Types with Flexible Bit-Width&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>LLVM_Integer</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Word.Word&quot;</span></span></span><span> </span><span>Bits_Natural</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Word_Lib.Word_Lemmas&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Fix in Word.thy! 
  Introducing proper infix-syntax for signed comparisons. So, also (&lt;s) and (&lt;=s) get available.
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>word_sle</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(_/ &lt;=s _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>50</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>word_sless</span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;(_/ &lt;s _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>50</span><span class="delimiter">,</span><span> </span><span>51</span><span class="delimiter">]</span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>word_sle</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&lt;=s&quot;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>word_sless</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&lt;s&quot;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Try to remove some useless stuff that Word_Lemmas imported via Complex_Main. *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>coercion_enabled</span><span> </span><span class="delimiter">=</span><span> </span><span>false</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Additional Lemmas&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">class</span></span><span> </span><span>len2</span><span> </span><span class="delimiter">=</span><span> </span><span>len</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>len2_not_1</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LENGTH(&#39;a) &#8800; Suc 0&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>len2_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;LENGTH(&#39;a::len2) &gt; Suc 0&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;LENGTH(&#39;a::len2) &#8805; 2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_lessI</span><span> </span><span>len2_not_1</span><span> </span><span>len_gt_0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc 0 &lt; LENGTH(&#39;a)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>len2E</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LENGTH(&#39;a::len2) = 2+n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LENGTH(&#39;a)&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>bit0</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>len</span><span class="delimiter">)</span><span> </span><span>len2</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>bit1</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>len</span><span class="delimiter">)</span><span> </span><span>len2</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span>simp</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;len2 (TYPE(&#39;a::len2)) &#8801; True&quot;</span></span></span><span>  
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Original theorem is in simpset, but useless due to non-normalized LHS *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>word_sbin.norm_Rep</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_bl_scast_down</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_down SCAST(&#39;a::len &#8594; &#39;b::len) &#10233; to_bl (SCAST(&#39;a &#8594; &#39;b) w) = drop (LENGTH(&#39;a)-LENGTH(&#39;b)) (to_bl w)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_down</span><span> </span><span>scast_down_drop</span><span> </span><span>source_size</span><span> </span><span>target_size</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;from_bool &#934; = 0 &#10231; &#172;&#934;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>from_bool_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>word_unat.Rep_inject</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>word_uint.Rep_inject</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>msb_uint_big</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;msb (w::&#39;a::len word) &#10231; uint w &#8805; 2^(LENGTH(&#39;a)-1)&quot;</span></span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>msb_big</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred&#39;</span><span> </span><span>diff_le_self</span><span> </span><span>le_antisym</span><span> </span><span>len_gt_0</span><span> </span><span>n_not_Suc_n</span><span> </span><span>p2_eq_0</span><span> </span><span>uint_2p</span><span> </span><span>word_le_def</span><span> </span><span>word_neq_0_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>msb_unat_big</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;msb (w::&#39;a::len word) &#10231; unat w &#8805; 2^(LENGTH(&#39;a)-1)&quot;</span></span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>msb_big</span><span> </span><span>word_le_nat_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word1_neqZ_is_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a::1 word) &#8800; 0 &#10231; a=1&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_last a&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word1_cases</span><span class="delimiter">[</span><span>cases</span><span> </span><span>type</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1 word&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="delimiter">(</span><span>zero</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a=0&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>one</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a=1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a=0&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word1_neqZ_is_one</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word1_NOT_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;~~(x::1 word) = x+1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>NOT_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>upcast_no_msb</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LENGTH(&#39;small::len) &lt; LENGTH(&#39;big::len) &#10233; &#172;msb (UCAST(&#39;small &#8594; &#39;big) x)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ucast_def</span><span> </span><span>msb_word_of_int</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_bintr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Integer Division with Rounding Towards Zero&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Division with rounding towards zero&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_sgn_cases</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span class="delimiter">::</span><span>int</span><span> </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="delimiter">(</span><span>negative</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&lt;0&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>zero</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a=0&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>positive</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&gt;0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>linorder_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Lemmas to match original definitions from this development to 
  definitions from Word-Library, to which we switched at some point.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sdiv_int_original_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a::int) sdiv b = (if a&#8805;0 &#10231; b&#8805;0 then &#166;a&#166; div &#166;b&#166; else - ( &#166;a&#166; div &#166;b&#166;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>int_sgn_cases</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>int_sgn_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sdiv_int_def</span><span> </span><span>sgn_mult</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>srem_int_original_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a::int) smod b = (if a&#8805;0 then &#166;a&#166; mod &#166;b&#166; else - (&#166;a&#166; mod &#166;b&#166;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>int_sgn_cases</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>int_sgn_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>simp</span><span class="delimiter">:</span><span> </span><span>smod_int_def</span><span> </span><span>sdiv_int_def</span><span> </span><span>sgn_mult</span><span> </span><span>algebra_simps</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>minus_mod_eq_mult_div</span><span> </span><span>mult_minus_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Standard properties of remainders&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_rem_rtz_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a::int) sdiv b * b + a smod b = a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>smod_int_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>abs_rem_rtz_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#8800;0 &#10233; &#166;a smod b&#166; &lt; &#166;b::int&#166;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>srem_int_original_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;LLVM documentation: The remainder is either zero, or has the same sign as the dividend&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rem_rtz_sign</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a::int) smod b = 0 &#8744; sgn ((a::int) smod b) = sgn a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>srem_int_original_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Euclidean_Division.pos_mod_sign</span><span> </span><span>sgn_pos</span><span> </span><span>zmod_trival_iff</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sdiv_positive</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a::int)&#8805;0 &#10233; b&#8805;0 &#10233; a sdiv b = a div b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sdiv_int_original_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>smod_positive</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a::int)&#8805;0 &#10233; b&#8805;0 &#10233; a smod b = a mod b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>srem_int_original_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Additions to @{theory &quot;HOL-Word.Bits_Int&quot;}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>bin_to_bl_def</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map2_eq_Nil_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map2 f a b = [] &#10231; a=[] &#8744; b=[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_eq_Nil_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_to_bl w i = [] &#10231; w=0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_to_bl_aux.Z</span><span> </span><span>bin_to_bl_def</span><span> </span><span>size_bin_to_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_aux_eq_Nil_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_to_bl_aux w i acc = [] &#10231; w=0 &#8743; acc=[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_to_bl_aux.Z</span><span> </span><span>bin_to_bl_eq_Nil_conv</span><span> </span><span>take.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>take_bin2bl_lem1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_to_bin_True</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_bin (True # bl) = bl_to_bin bl + 2^length bl&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Bit_B1</span><span> </span><span>add.commute</span><span> </span><span>add.right_neutral</span><span> </span><span>bin_bl_bin</span><span> </span><span>bin_cat_num</span><span> </span><span>bl_bin_bl</span><span> </span><span>bl_to_bin_aux.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bl_to_bin_aux_alt</span><span> </span><span>mult_1s</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mult_zero_left</span><span> </span><span>numeral_code</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_to_bin_append_num</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_bin (a@b) = 2^length b * bl_to_bin a + bl_to_bin b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bin_cat_num</span><span> </span><span>bl_to_bin_app_cat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_to_bin_rep_True</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_bin (replicate n True) = 2 ^ n - 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_bl_bin</span><span> </span><span>bin_to_bl_minus1</span><span> </span><span>bintr_Min</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_to_bin_rep_T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_bin (replicate n True @ bl) = 2 ^ length bl * (2 ^ n - 1) + bl_to_bin bl&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bl_to_bin_append_num</span><span> </span><span>bl_to_bin_rep_True</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_strunc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;w<span class="hidden">&#8681;</span><sub>1</sub> &#8804; w<span class="hidden">&#8681;</span><sub>2</sub> + 1 &#10233; bin_to_bl w<span class="hidden">&#8681;</span><sub>1</sub> (sbintrunc w<span class="hidden">&#8681;</span><sub>2</sub> i) = bin_to_bl w<span class="hidden">&#8681;</span><sub>1</sub> i&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bintrunc_sbintrunc_le</span><span> </span><span>bl_to_bin_inj</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_last_x2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_last (2*n) = False&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bin_last_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_rest_x2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_rest (2*n) = n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bin_rest_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_x2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w&#8800;0 &#10233; bin_to_bl w (2*n) = bin_to_bl (w-1) n @ [False]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>w</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bin_to_bl_def</span><span> </span><span>bin_to_bl_aux_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_xp2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8804;w&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_to_bl w (x * 2^n) = bin_to_bl (w-n) x @ replicate n False&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x * (2 * 2 ^ n) = 2 * (x*2^n)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>drop_bin2bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>replicate_append_same</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bintrunc_eq_if_in_range</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bintrunc w i = i &#10231; i&#8712;uints w&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>int_mod_lem</span><span> </span><span>uints_num</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sbintrunc_eq_if_in_range</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sbintrunc (w-Suc 0) i = i &#10231; i&#8712;sints w&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sints_def</span><span> </span><span>sbintrunc_eq_in_range</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_to_bin_in_uints</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_bin x &#8712; uints (length x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bl_to_bin_def</span><span> </span><span>bintrunc_eq_if_in_range</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: This is probably a special case of a more general scheme! *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>pull_mods</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Scan.succeed (fn ctxt =&gt;  SIMPLE_METHOD&#39; (
  CONVERSION (Conv.top_conv (K (Conv.try_conv (Conv.rewrs_conv @{thms pull_mods}))) ctxt)
))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>pull_push_mods</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Scan.succeed (fn ctxt =&gt; SIMPLE_METHOD&#39; (
  CONVERSION (Conv.top_conv (K (Conv.try_conv (Conv.rewrs_conv @{thms pull_mods}))) ctxt)
  THEN&#39; (full_simp_tac (put_simpset HOL_basic_ss ctxt addsimps @{thms mod_mod_trivial push_mods}))
))&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pull in, then push out modulos&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Signed integers in Two&#39;s Complement Representation&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bl_to_sbin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool list &#8658; int&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_sbin bl = sbintrunc (length bl - 1) (bl_to_bin bl)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_to_sbin_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_sbin bl = (case bl of [] &#8658; 0 | b#bl &#8658; (if b then -(2^length bl) else 0) + bl_to_bin bl)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_to_sbin_def</span><span> </span><span>sbintrunc_mod2p</span><span> </span><span>bl_to_bin_ge0</span><span> </span><span>bl_to_bin_lt2p</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>bl_to_bin_ge0</span><span> </span><span>bl_to_bin_lt2p</span><span> </span><span>int_mod_eq&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_sbin_bl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_to_bl (length bs) (bl_to_sbin bs) = bs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bl_to_sbin_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sbin_bl_bin</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;0&lt;w &#10233; bl_to_sbin (bin_to_bl w i) = sbintrunc (w-1) i&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bl_to_sbin_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_to_sbin_in_sints</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_sbin x &#8712; sints (length x)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bl_to_sbin_def</span><span> </span><span>sbintrunc_eq_if_in_range</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Lifting of Operations&#8250;</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop1 f a &#8801; bin_to_bl (length a) (f (bl_to_bin a))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 nel f a b &#8801; 
  if length a = length b then 
    bin_to_bl (length a) (f (bl_to_bin a) (bl_to_bin b))
  else nel ()&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2b nel f a b &#8801; if length a = length b then
    f (bl_to_bin a) (bl_to_bin b)
  else nel ()&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_uop1_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_bin (cnv_uop1 f a) = bintrunc (length a) (f (bl_to_bin a))
  &#8743; length (cnv_uop1 f a) = length a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop1_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_uop2_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b 
    &#10233; bl_to_bin (cnv_uop2 nel f a b) = bintrunc (length a) (f (bl_to_bin a) (bl_to_bin b))
      &#8743; length (cnv_uop2 nel f a b) = length b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_uop2b_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b &#10233; cnv_uop2b nel f a b = f (bl_to_bin a) (bl_to_bin b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2b_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_sop1 f a &#8801; bin_to_bl (length a) (f (bl_to_sbin a))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_sop2 nel f a b &#8801; 
  if length a = length b then
    bin_to_bl (length a) (f (bl_to_sbin a) (bl_to_sbin b))
  else 
    nel ()&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_sop2b nel f a b &#8801; if length a = length b then
    f (bl_to_sbin a) (bl_to_sbin b)
  else nel ()&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_cnv_sop1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (cnv_sop1 f a) = length a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cnv_sop1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_sop1_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8800;[] 
  &#10233; bl_to_sbin (cnv_sop1 f a) = sbintrunc (length a - 1) (f (bl_to_sbin a))
    &#8743; length (cnv_sop1 f a) = length a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_sop1_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_sop2_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8800;[] &#10233; length a = length b 
  &#10233; bl_to_sbin (cnv_sop2 nel f a b) = sbintrunc (length a - 1) (f (bl_to_sbin a) (bl_to_sbin b))
    &#8743; length (cnv_sop2 nel f a b) = length b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_sop2_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sbin_bl_bin</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_sop2_correct&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#8800;[] &#10233; length a = length b 
  &#10233; bl_to_sbin (cnv_sop2 nel f a b) = sbintrunc (length a - 1) (f (bl_to_sbin a) (bl_to_sbin b))
    &#8743; length (cnv_sop2 nel f a b) = length b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cnv_sop2_correct</span><span> </span><span>length_0_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_sop2b_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b &#10233; cnv_sop2b nel f a b = f (bl_to_sbin a) (bl_to_sbin b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_sop2b_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_uop1_empty_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop1 f a = [] &#10231; a=[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop1_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_uop2_empty_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 nel f a b = [] &#10231; (if length a = length b then a=[] else nel () = [])&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_sop2_empty_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_sop2 nel f a b = [] &#10231; (if length a = length b then a=[] else nel () = [])&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_sop2_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_sop1_empty_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_sop1 f a = [] &#10231; a=[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_sop1_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Operations Independent of Signed/Unsigned Interpretation &#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_unsigned_compat1 f &#8801; &#8704;w a. sbintrunc w (f (sbintrunc w a)) = sbintrunc w (f a)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_unsigned_compat2 f &#8801; &#8704;w a b. sbintrunc w (f (sbintrunc w a) (sbintrunc w b)) = sbintrunc w (f a b)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_uop1_to_sop1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_unsigned_compat1 f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop1 f a = cnv_sop1 f a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop1_def</span><span> </span><span>cnv_sop1_def</span><span> </span><span>bl_to_sbin_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>signed_unsigned_compat1_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bin_bl_bin</span><span> </span><span>bintrunc_sbintruncS0</span><span> </span><span>bl_bin_bl</span><span> </span><span>length_greater_0_conv</span><span> </span><span>size_bin_to_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_uop2_to_sop2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_unsigned_compat2 f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 nel f a b = cnv_sop2 nel f a b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span> </span><span>cnv_sop2_def</span><span> </span><span>bl_to_sbin_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>signed_unsigned_compat2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>bin_bl_bin</span><span> </span><span>bintrunc_sbintruncS0</span><span> </span><span>bl_bin_bl</span><span> </span><span>length_greater_0_conv</span><span> </span><span>size_bin_to_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_uop1_compat_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_unsigned_compat1 f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8800;[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_sbin (cnv_uop1 f a) = sbintrunc (length a - 1) (f (bl_to_sbin a))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop1_to_sop1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_uop2_compat_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_unsigned_compat2 f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#8800;[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_sbin (cnv_uop2 nel f a b) = sbintrunc (length a - 1) (f (bl_to_sbin a) (bl_to_sbin b))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_to_sop2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_uop2_compat_correct&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_unsigned_compat2 f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b&#8800;[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_sbin (cnv_uop2 nel f a b) = sbintrunc (length a - 1) (f (bl_to_sbin a) (bl_to_sbin b))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span> </span><span>cnv_uop2_compat_correct</span><span> </span><span>length_0_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>signed_unsigned_compat2_plus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_unsigned_compat2 (+)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>signed_unsigned_compat2_def</span><span> </span><span>sbintrunc_mod2p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>pull_push_mods</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>signed_unsigned_compat2_minus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_unsigned_compat2 (-)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>signed_unsigned_compat2_def</span><span> </span><span>sbintrunc_mod2p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>pull_push_mods</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>signed_unsigned_compat2_mult</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_unsigned_compat2 (*)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>signed_unsigned_compat2_def</span><span> </span><span>sbintrunc_mod2p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>pull_push_mods</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Bitwise Interpretation of Operations&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Provides an additional sanity check, by equating our definitions with the definitions found in
  @{theory &quot;HOL-Word.Bits_Int&quot;}. Unfortunately, they do not define minus there.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_plus_rbl_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b &#10233; cnv_uop2 nel (+) a b = rev (rbl_add (rev a) (rev b))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span> </span><span>rbl_add</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>bl_bin_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_mult_rbl_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b &#10233; cnv_uop2 nel (*) a b = rev (rbl_mult (rev a) (rev b))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span> </span><span>rbl_mult</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>bl_bin_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_AND_bl_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b &#10233; cnv_uop2 nel (AND) a b = map2 (&#8743;) a b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span> </span><span>bl_and_bin</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>bl_bin_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_OR_bl_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b &#10233; cnv_uop2 nel (OR) a b = map2 (&#8744;) a b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span> </span><span>bl_or_bin</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>bl_bin_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Lemma bl_xor_bin has non-normalized lhs! *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_XOR_bl_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length a = length b &#10233; cnv_uop2 nel (XOR) a b = map2 (&#8800;) a b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>b</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_xor_bin</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>cnv_uop2_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>bl_bin_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_NOT_bl_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop1 (bitNOT) a = map Not a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>bl_bin_bl</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>bl_not_bin</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop1_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_SHL_bl_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8804;length a &#10233; cnv_uop1 (&#955;x. x * 2^n) a = drop n a @ replicate n False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop1_def</span><span> </span><span>bl_bin_bl_rep_drop</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>butlast_bin_to_bl_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;acc&#8800;[] &#10233; butlast (bin_to_bl_aux w i acc) = bin_to_bl_aux w i (butlast acc)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bin_to_bl_aux_alt</span><span> </span><span>butlast_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_rest_div2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_rest (n div 2) = bin_rest n div 2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bin_rest_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_last_div2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_last (n div 2) = bin_last (bin_rest n)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bin_rest_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span>bin_to_bl_aux</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(@)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_Suc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_to_bl (Suc w) i = bin_to_bl w (bin_rest i) @ [bin_last i]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bin_to_bl_aux_append</span><span> </span><span>bin_to_bl_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;butlast (bin_to_bl w n) = bin_to_bl (w-1) (bin_rest n)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>butlast_rest_bin</span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_to_bl _ _ ! _&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_div2_shift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;w&#8800;0; n&#8805;0; n&lt;2^w&#10215; &#10233; bin_to_bl w (n div 2) = False # butlast (bin_to_bl w n)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>w</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>butlast_rest_bin</span><span> </span><span>bin_rest_def</span><span> </span><span>nth_Cons</span><span> </span><span>nth_bin_to_bl</span><span> </span><span>bin_nth_eq_mod</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>nat.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_div_p2_eq_div_p2s</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;w div (2^a) div (2^b) = (w::int) div 2^(a+b)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;w div 2 div (2^b) = (w::int) div 2^(Suc b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>div_mult2_eq</span><span> </span><span>power_add</span><span> </span><span>zdiv_zmult2_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_div2p_shift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;n&#8805;0; n&lt;2^w; k&#8804;w&#10215; &#10233; bin_to_bl w (n div 2^k) = replicate k False @ take (w-k) (bin_to_bl w n)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>butlast_rest_bin</span><span> </span><span>bin_rest_def</span><span> </span><span>nth_Cons</span><span> </span><span>nth_append</span><span> </span><span>nth_bin_to_bl</span><span> </span><span>bin_nth_eq_mod</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>nat.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>div_div_p2_eq_div_p2s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Nat.le_add_diff</span><span> </span><span>Suc_leI</span><span> </span><span>div_pos_pos_trivial</span><span> </span><span>even_zero</span><span> </span><span>not_less</span><span> </span><span>power_strict_increasing_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Nat.add_diff_assoc2</span><span> </span><span>Suc_leI</span><span> </span><span>add.commute</span><span> </span><span>power_add</span><span> </span><span>zdiv_zmult2_eq</span><span> </span><span>zero_le_power_eq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Nat.add_diff_assoc2</span><span> </span><span>Suc_leI</span><span> </span><span>add.commute</span><span> </span><span>power_add</span><span> </span><span>zdiv_zmult2_eq</span><span> </span><span>zero_le_power_eq</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>  
</span><span>   
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_LSHR_bl_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8804;length a &#10233; cnv_uop1 (&#955;x. x div 2^n) a = replicate n False @ take (length a - n) a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length a&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop1_def</span><span> </span><span>bin_to_bl_div2p_shift</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_to_bl_div2p_shift</span><span> </span><span>bl_bin_bl</span><span> </span><span>bl_to_bin_ge0</span><span> </span><span>bl_to_bin_lt2p</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Note: This division is with rounding down!&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_sdiv2_shift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ran</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;-(2^w)&#8804;i&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;2^w&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_to_bl (Suc w) (i div 2) = hd (bin_to_bl (Suc w) i) # butlast (bin_to_bl (Suc w) i)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; &#172; 0 &#8804; (i::int)&#10215; &#10233; i div (2*2^w) = -1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ran</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>cancel_div_mod_rules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>div_pos_pos_trivial</span><span> </span><span>mod_add_self2</span><span> </span><span>mult_cancel_left1</span><span> </span><span>mult_minus_right</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ran</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>butlast_rest_bin</span><span> </span><span>bin_rest_def</span><span> </span><span>nth_Cons</span><span> </span><span>bl_sbin_sign</span><span> </span><span>nth_bin_to_bl</span><span> </span><span>bin_nth_eq_mod</span><span> </span><span>bin_sign_def</span><span> </span><span>sbintrunc_mod2p</span><span> </span><span>div_div_p2_eq_div_p2s</span><span> 
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>nat.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_sdiv2p_shift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ran</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;-(2^w)&#8804;i&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;2^w&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k&lt;Suc w&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_to_bl (Suc w) (i div 2^k) = replicate k (hd (bin_to_bl (Suc w) i)) @ take (Suc w - k) (bin_to_bl (Suc w) i)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#172;0&#8804;i; x&#8805;w&#10215; &#10233; i div (2^x) = -1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ran</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>cancel_div_mod_rules</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>int_mod_eq&#39;</span><span> </span><span>linorder_not_le</span><span> </span><span>mod_add_self2</span><span> </span><span>mult_cancel_left1</span><span> </span><span>mult_minus_right</span><span> </span><span>power_strict_increasing_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ran</span><span> </span><span>K</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>butlast_rest_bin</span><span> </span><span>bin_rest_def</span><span> </span><span>nth_Cons</span><span> </span><span>bl_sbin_sign</span><span> </span><span>nth_bin_to_bl</span><span> </span><span>bin_nth_eq_mod</span><span> </span><span>bin_sign_def</span><span> </span><span>sbintrunc_mod2p</span><span> </span><span>div_div_p2_eq_div_p2s</span><span> 
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span> </span><span>algebra_simps</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>nat.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Nat.le_add_diff</span><span> </span><span>diff_is_0_eq&#39;</span><span> </span><span>div_pos_pos_trivial</span><span> </span><span>even_zero</span><span> </span><span>less_imp_le</span><span> </span><span>power_strict_increasing_iff</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_ASHR_bl_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&lt;length a &#10233; cnv_sop1 (&#955;x. x div 2^n) a = replicate n (hd a) @ take (length a - n) a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length a&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_sop1_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_to_bl_sdiv2p_shift</span><span> </span><span>bl_sbin_bl</span><span> </span><span>bl_to_sbin_def</span><span> </span><span>diff_Suc_1</span><span> </span><span>sbintr_ge</span><span> </span><span>sbintr_lt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Signed and Unsigned Extension and Truncation&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bl_trunc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; bool list &#8658; bool list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_trunc w bl &#8801; drop (length bl - w) bl&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_trunc_ge</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bl &lt; w &#10233; bl_trunc w bl = bl&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bl_trunc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trunc_bl_to_bin</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_bin (bl_trunc w bl) = bintrunc w (bl_to_bin bl)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bl_trunc_def</span><span> </span><span>trunc_bl2bin</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trunc_bl_to_sbin</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;w&gt;0 &#10233; bl_to_sbin (bl_trunc w bl) = sbintrunc (w-1) (bl_to_sbin bl)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w &#8804; length bl&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_trunc_def</span><span> </span><span>bl_to_sbin_def</span><span> </span><span>bl2bin_drop</span><span> </span><span>min_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_trunc_len</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (bl_trunc w bl) = min w (length bl)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_trunc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_trunc_eq_Nil_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_trunc w l = [] &#10231; w=0 &#8744; l=[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_trunc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bl_zext</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; bool list &#8658; bool list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_zext w bl &#8801; replicate (w - length bl) False @ bl&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_zext_le</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w&#8804;length bl &#10233; bl_zext w bl = bl&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_zext_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_zext_to_bin</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_bin (bl_zext w bl) = bl_to_bin bl&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_zext_def</span><span> </span><span>bl_to_bin_rep_F</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_zext_len</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (bl_zext w bl) = max w (length bl)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_zext_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_zext_Nil_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_zext w bl = [] &#10231; w=0 &#8743; bl = []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_zext_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bl_sext</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; bool list &#8658; bool list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_sext w bl &#8801; replicate (w - length bl) (hd bl) @ bl&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_sext_le</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w&#8804;length bl &#10233; bl_sext w bl = bl&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_sext_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_to_sbin_pos_conv_bin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;hd bl &#10233; bl_to_sbin bl = bl_to_bin bl&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_to_sbin_alt</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_to_sbin_neg_conv_bin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl&#8800;[] &#10233; hd bl &#10233; bl_to_sbin bl = bl_to_bin bl - 2^(length bl)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_to_sbin_alt</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_sext_to_sbin</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl&#8800;[]&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_to_sbin (bl_sext w bl) = bl_to_sbin bl&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w&gt;length bl&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hd bl&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bl &lt; w&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_to_sbin_neg_conv_bin</span><span> </span><span>bl_sext_def</span><span> </span><span>bl_to_bin_rep_T</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_add_inverse</span><span> </span><span>less_imp_add_positive</span><span> </span><span>power_add</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length bl &lt; w&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_to_sbin_pos_conv_bin</span><span> </span><span>bl_sext_def</span><span> </span><span>bl_to_bin_rep_F</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_sext_len</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (bl_sext w bl) = max w (length bl)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_sext_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bl_sext_Nil_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_sext w bl = [] &#10231; w=0 &#8743; bl = []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_sext_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;LLVM Integer Datatype&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span>lint</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{l::bool list. True }&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">morphisms</span></span><span> </span><span>lint_to_bits</span><span> </span><span>bits_to_lint</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_lint</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma Rep_lint_neq_Nil[simp]: &quot;lint_to_bits x &#8800; []&quot;
  using lint_to_bits by simp
*)</span></span></span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>lint</span><span> </span><span class="delimiter">::</span><span> </span><span>equal</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>equal_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;equal_class.equal&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>intro_classes</span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equal_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>width</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>lint_to_uint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; int&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>bl_to_bin</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>lint_to_sint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; int&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>bl_to_sbin</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma width_notZ[simp]: &quot;width a &#8800; 0&quot; by transfer auto*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_lower_bound</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&#8804;lint_to_uint a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bl_to_bin_ge0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_upper_bound</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint a &lt; 2^width a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bl_to_bin_lt2p</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_lower_bound</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;-(2^(width a - 1))&#8804;lint_to_sint a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bl_to_sbin_def</span><span> </span><span>sbintr_ge</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_upper_bound</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_sint a &lt; 2^(width a - 1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bl_to_sbin_def</span><span> </span><span>sbintr_lt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Overflows&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uovf1 f a &#8801; f (lint_to_uint a) &#8713; uints (width a)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sovf1 f a &#8801; f (lint_to_sint a) &#8713; sints (width a)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uovf2 f a b &#8801; f (lint_to_uint a) (lint_to_uint b) &#8713; uints (width a)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sovf2 f a b &#8801; f (lint_to_sint a) (lint_to_sint b) &#8713; sints (width a)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Operations&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>lconst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; int &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;w i. bin_to_bl w i&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_lconst</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (lconst w i) = w&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_const</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (lconst w c) = bintrunc w c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_const</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w&#8800;0 &#10233; lint_to_sint (lconst w c) = sbintrunc (w-1) c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bits_zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_bits (lconst w 0) = replicate w False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bin_to_bl_zero</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bits_minus1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_bits (lconst w (-1)) = replicate w True&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bin_to_bl_minus1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lconst_eq_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lconst w c = lconst w&#39; c&#39; &#10231; w&#39;=w &#8743; (c&#39; mod 2^w = c mod 2^w)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>len_bin_to_bl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_bl_bin</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>len_bin_to_bl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_def</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>bl_to_bin_inj</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>    
</span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_abort (_::unit) &#8801; lint_to_bits undefined&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_abort_bool (_::unit) &#8801; undefined::bool&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma l_abort_ne[simp]: &quot;lint_abort () &#8800; []&quot; unfolding lint_abort_def by auto*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span> </span><span>code</span><span> </span><span>abort</span><span class="delimiter">:</span><span> </span><span>lint_abort</span><span> </span><span>lint_abort_bool</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{plus,minus,times,divide,modulo,uminus,signed_div}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>plus_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 (lint_abort) (+)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>minus_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 (lint_abort) (-)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>times_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 (lint_abort) (*)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>divide_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 (lint_abort) (div)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>modulo_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 (lint_abort) (mod)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>uminus_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_sop1 uminus&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sdivrem_ovf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;sdivrem_ovf a b &#8801; lint_to_sint a sdiv lint_to_sint b &#8713; sints (width a)&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>sdiv_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; lint&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a b. if bl_to_sbin a sdiv bl_to_sbin b &#8712; sints (length a) then cnv_sop2 lint_abort (sdiv) a b else lint_abort ()&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>smod_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; lint&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a b. if bl_to_sbin a sdiv bl_to_sbin b &#8712; sints (length a) then cnv_sop2 lint_abort (smod) a b else lint_abort ()&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_plus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (a+b) = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_plus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (a+b) = bintrunc (width b) (lint_to_uint a + lint_to_uint b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_plus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width b &#8800; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_sint (a+b) = sbintrunc (width b - 1) (lint_to_sint a + lint_to_sint b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_compat_correct&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_minus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (a-b) = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_minus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (a-b) = bintrunc (width b) (lint_to_uint a - lint_to_uint b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_minus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width b &#8800; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_sint (a-b) = sbintrunc (width b - 1) (lint_to_sint a - lint_to_sint b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_compat_correct&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_times</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (a*b) = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_times</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (a*b) = bintrunc (width b) (lint_to_uint a * lint_to_uint b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_times</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width b &#8800; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_sint (a*b) = sbintrunc (width b - 1) (lint_to_sint a * lint_to_sint b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_compat_correct&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_divide</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (a div b) = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_divide</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (a div b) = bintrunc (width b) (lint_to_uint a div lint_to_uint b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_sdivide</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width b &#8800; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;sdivrem_ovf a b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (a sdiv b) = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sdivrem_ovf_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_sdivide</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width b &#8800; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;sdivrem_ovf a b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_sint (a sdiv b) = sbintrunc (width b - 1) ((lint_to_sint a) sdiv (lint_to_sint b))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sdivrem_ovf_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_modulo</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (a mod b) = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_modulo</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (a mod b) = bintrunc (width b) (lint_to_uint a mod lint_to_uint b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_srem</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width b &#8800; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;sdivrem_ovf a b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (a smod b) = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sdivrem_ovf_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_remainder</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width b &#8800; 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;sdivrem_ovf a b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_sint (a smod b) = sbintrunc (width b - 1) ((lint_to_sint a) smod (lint_to_sint b))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sdivrem_ovf_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_uminus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;width (- a) = width a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_uminus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;width a &#8800; 0 &#10233; lint_to_sint (- a) = sbintrunc (width a - 1) (- lint_to_sint a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{ord}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>less_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2b lint_abort_bool (&lt;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>less_eq_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2b lint_abort_bool (&#8804;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>sless_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&lt;<span class="hidden">&#8681;</span><sub>s</sub>&quot;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_sop2b lint_abort_bool (&lt;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>sless_eq_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8804;<span class="hidden">&#8681;</span><sub>s</sub>&quot;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_sop2b lint_abort_bool (&#8804;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_less</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &lt; b &#10231; lint_to_uint a &lt; lint_to_uint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_less_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8804; b &#10231; lint_to_uint a &#8804; lint_to_uint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_less</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &lt;<span class="hidden">&#8681;</span><sub>s</sub> b &#10231; lint_to_sint a &lt; lint_to_sint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_less_eq</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8804;<span class="hidden">&#8681;</span><sub>s</sub> b &#10231; lint_to_sint a &#8804; lint_to_sint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Yields &#8249;0<span class="hidden">&#8681;</span><sub>1</sub>&#8250; on attempt to truncate to zero&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>trunc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;w a. if w=0 then [False] else bl_trunc w a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_trunc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w&#8800;0 &#10233; width (trunc w a) = min w (width a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_trunc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w&#8800;0 &#10233; lint_to_uint (trunc w a) = bintrunc w (lint_to_uint a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_trunc</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w&#8800;0 &#10233; lint_to_sint (trunc w a) = sbintrunc (w-1) (lint_to_sint a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zext</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_zext&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>sext</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bl_sext&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_zext</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (zext w a) = max w (width a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_sext</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (sext w a) = max w (width a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_zext</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (zext w a) = lint_to_uint a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_sext</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a &#8800; 0 &#10233; lint_to_sint (sext w a) = lint_to_sint a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>lint</span><span> </span><span class="delimiter">::</span><span> </span><span>bit_operations</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitAND_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 lint_abort (AND)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitOR_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 lint_abort (OR)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitXOR_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop2 lint_abort (XOR)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitNOT_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cnv_uop1 (bitNOT)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_AND</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (a AND b) = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_AND</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (a AND b) = lint_to_uint a AND lint_to_uint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_trunc_ao</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>trunc_bl2bin_len</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_OR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (a OR b) = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_OR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (a OR b) = lint_to_uint a OR lint_to_uint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_trunc_ao</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>cnv_uop2_correct</span><span> </span><span>trunc_bl2bin_len</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_XOR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (a XOR b) = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_XOR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (a XOR b) = lint_to_uint a XOR lint_to_uint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_trunc_xor&#39;</span><span> </span><span>cnv_uop2_correct</span><span> </span><span>trunc_bl2bin_len</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_NOT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;width (NOT a) = width a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_NOT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (NOT a) = bintrunc (width a) (NOT (lint_to_uint a))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bits_NOT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_bits (NOT a) = map Not (lint_to_bits a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_NOT_bl_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bits_AND</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b &#10233; lint_to_bits (a AND b) = map2 (&#8743;) (lint_to_bits a) (lint_to_bits b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_AND_bl_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bits_OR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b &#10233; lint_to_bits (a OR b) = map2 (&#8744;) (lint_to_bits a) (lint_to_bits b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_OR_bl_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bits_XOR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = width b &#10233; lint_to_bits (a XOR b) = map2 (&#8800;) (lint_to_bits a) (lint_to_bits b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_XOR_bl_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitSHL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; nat &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;bl n. cnv_uop1 (&#955;x. x*2^n) bl&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitLSHR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; nat &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;bl n. cnv_uop1 (&#955;x. x div 2^n) bl&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitASHR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; nat &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;bl n. cnv_sop1 (&#955;x. x div 2^n) bl&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_bitSHL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (bitSHL a n) = width a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_bitSHL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (bitSHL a n) = bintrunc (width a) (2^n * lint_to_uint a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_bitSHL</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a &#8800; 0 &#10233; lint_to_sint (bitSHL a n) = sbintrunc (width a - 1) (2^n * lint_to_sint a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bl_to_sbin_def</span><span> </span><span>sbintrunc_mod2p</span><span> </span><span>bintrunc_mod2p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>pull_push_mods</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_bitLSHR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (bitLSHR a n) = width a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_bitLSHR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (bitLSHR a n) = lint_to_uint a div 2^n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>algebra_simps</span><span> </span><span>pos_imp_zdiv_nonneg_iff</span><span> </span><span>bl_to_bin_ge0</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mod_pos_pos_trivial</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>bl_to_bin_ge0</span><span> </span><span>bl_to_bin_lt2p</span><span> </span><span>div_by_1</span><span> </span><span>div_pos_pos_trivial</span><span> </span><span>int_div_less_self</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_bitASHR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (bitASHR a n) = width a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_bitASHR</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a &#8800; 0 &#10233; lint_to_sint (bitASHR a n) = lint_to_sint a div 2^n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bl_to_sbin_in_sints</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sbintrunc_eq_if_in_range</span><span> </span><span>sints_num</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>div_by_1</span><span> </span><span>pos_imp_zdiv_nonneg_iff</span><span> </span><span>zdiv_mono2</span><span> </span><span>zdiv_mono2_neg</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a = b &#10231; lint_to_uint a = lint_to_uint b &#8743; width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bl_to_bin_inj</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a = b &#10231; lint_to_sint a = lint_to_sint b &#8743; width a = width b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bl_sbin_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lconst_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lconst w a = lconst w b &#10231; a mod 2^w = b mod 2^w&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8249;i1&#8250; as Boolean&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ltrue &#8801; lconst 1 1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lfalse &#8801; lconst 1 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool_to_lint b &#8801; if b then ltrue else lfalse&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_bool a &#8801; if a = ltrue then True else if a = lfalse then False else lint_abort_bool ()&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lbool_cases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width a = 1 &#10233; a=ltrue &#8744; a=lfalse&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ltrue_def</span><span> </span><span>lfalse_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>BIT_special_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>bin_bl_bin</span><span> </span><span>bin_to_bl_aux.Z</span><span> </span><span>bin_to_bl_def</span><span> </span><span>bin_to_bl_zero</span><span> </span><span>bintrunc.Suc</span><span> </span><span>bintrunc_n_0</span><span> </span><span>bl_bin_bl</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lint_bool_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;width ltrue = 1&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;width lfalse = 1&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint ltrue = 1&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint lfalse = 0&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_sint ltrue = -1&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_sint lfalse = 0&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;width (bool_to_lint b) = 1&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;width a = 1 &#10233; lint_to_bool a &#10231; a = ltrue&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_bool (bool_to_lint b) = b&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;width a = 1 &#10233; bool_to_lint (lint_to_bool a) = a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lbool_cases</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ltrue_def</span><span> </span><span>lfalse_def</span><span> </span><span>bool_to_lint_def</span><span> </span><span>lint_to_bool_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Connection to Word Datatype&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lint_to_word</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint &#8658; &#39;a::len0 word&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_word &#8801; word_of_int o lint_to_uint&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>word_to_lint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len0 word &#8658; lint&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint &#8801; lconst (len_of TYPE(&#39;a)) o uint&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lint_word_inv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_word (word_to_lint w) = w&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_lint_inv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LENGTH (&#39;a::len0) = width i &#10233; word_to_lint (lint_to_word i :: &#39;a word) = i&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>uint_const</span><span> </span><span>uint_eq</span><span> </span><span>uint_lower_bound</span><span> </span><span>uint_upper_bound</span><span> </span><span>width_lconst</span><span> </span><span>word_of_int_inverse</span><span> </span><span>word_ubin.norm_Rep</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_to_bl_eq_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bin_to_bl w x = bin_to_bl w y &#10231; bintrunc w x = bintrunc w y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_bl_bin</span><span> </span><span>bl_bin_bl</span><span> </span><span>size_bin_to_bl</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>word_to_lint_convs</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_plus</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a+b) = word_to_lint a + word_to_lint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span> </span><span>bin_to_bl_eq_iff</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>mod_add_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_minus</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a-b) = word_to_lint a - word_to_lint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span> </span><span>bin_to_bl_eq_iff</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>mod_diff_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_mult</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a*b) = word_to_lint a * word_to_lint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span> </span><span>bin_to_bl_eq_iff</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>mod_mult_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_eq</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint a = word_to_lint b &#10231; a=b&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>word_uint.Rep_inject</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_ule</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint a &#8804; word_to_lint b &#10231; a&#8804;b&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span> </span><span>word_le_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_ult</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint a &lt; word_to_lint b &#10231; a&lt;b&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span> </span><span>word_less_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_sle</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint a &#8804;<span class="hidden">&#8681;</span><sub>s</sub> word_to_lint b &#10231; a &lt;=s b&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span> </span><span>word_sle_def</span><span> </span><span>sint_uint</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_slt</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint a &lt;<span class="hidden">&#8681;</span><sub>s</sub> word_to_lint b &#10231; a &lt;s b&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span> </span><span>word_sless_alt</span><span> </span><span>sint_uint</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_div</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a div b) = word_to_lint a div word_to_lint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span> </span><span>bin_to_bl_eq_iff</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>uint_div_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_mod</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a mod b) = word_to_lint a mod word_to_lint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop2_def</span><span> </span><span>bin_to_bl_eq_iff</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>uint_mod_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_sdiv</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len word&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint a sdiv sint b &#8712; sints LENGTH(&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a sdiv b) = word_to_lint a sdiv word_to_lint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span> </span><span>sints_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>bl_sbin_bl</span><span> </span><span>bl_to_sbin_in_sints</span><span> </span><span>cnv_sop2_def</span><span> 
</span><span>      </span><span>len_gt_0</span><span> </span><span>sbin_bl_bin</span><span> </span><span>sdiv_word_def</span><span> </span><span>sint_sbintrunc&#39;</span><span> </span><span>sint_uint</span><span> </span><span>size_bin_to_bl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_smod</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len word&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint a sdiv sint b &#8712; sints LENGTH(&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a smod b) = word_to_lint a smod word_to_lint b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>lint_to_word_def</span><span> </span><span>sints_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>bl_to_sbin_in_sints</span><span> </span><span>cnv_sop2_def</span><span> </span><span>len_gt_0</span><span> </span><span>sbin_bl_bin</span><span> </span><span>sint_uint</span><span> </span><span>size_bin_to_bl</span><span> </span><span>smod_word_def</span><span> </span><span>to_bl_of_bin</span><span> </span><span>word_uint.Rep_inverse</span><span class="delimiter">)</span><span>
</span><span>        
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_shl</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint ((a::_::len word) &lt;&lt; n) = bitSHL (word_to_lint a) n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop1_def</span><span> </span><span>bin_to_bl_eq_iff</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>shiftl_t2n</span><span> </span><span>uint_word_ariths</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mod_mult_right_eq</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>shiftl_int_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_lshr</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint ((a::_::len word) &gt;&gt; n) = bitLSHR (word_to_lint a) n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_uop1_def</span><span> </span><span>bin_to_bl_eq_iff</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>uint_word_ariths</span><span> </span><span>shiftr_div_2n</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_ashr</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a &gt;&gt;&gt; n) = bitASHR (word_to_lint (a::&#39;a::len word)) n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>word_to_lint_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cnv_sop1_def</span><span> </span><span>uint_sint</span><span> </span><span>sshiftr_div_2n</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_ucast_down</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_down UCAST(&#39;a &#8594; &#39;b) &#10233; word_to_lint (UCAST(&#39;a::len&#8594;&#39;b::len) a) = trunc (LENGTH(&#39;b)) (word_to_lint a)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>word_to_lint_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cast_simps</span><span> </span><span>to_bl_ucast</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>to_bl_bin</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bl_bin_bl</span><span> </span><span>bl_trunc_def</span><span> </span><span>diff_diff_cancel</span><span> </span><span>length_drop</span><span> </span><span>word_bl_Rep&#39;</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_scast_down</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_down SCAST(&#39;a &#8594; &#39;b) &#10233; word_to_lint (SCAST(&#39;a::len&#8594;&#39;b::len) a) = trunc (LENGTH(&#39;b)) (word_to_lint a)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>word_to_lint_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cast_simps</span><span> </span><span>to_bl_scast_down</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>to_bl_bin</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bl_bin_bl</span><span> </span><span>bl_trunc_def</span><span> </span><span>diff_diff_cancel</span><span> </span><span>length_drop</span><span> </span><span>word_bl_Rep&#39;</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zext_in_range</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;w&#39;&#8800;0; w&#39;&#8804;w; 0&#8804;a; a&lt;2^w&#39;&#10215; &#10233; zext w (lconst w&#39; a) = lconst w a&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bl_zext_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>bin_bl_bin</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>bl_bin_bl_rep_drop</span><span> </span><span>diff_is_0_eq&#39;</span><span> </span><span>diff_zero</span><span> </span><span>drop_bin2bl</span><span> </span><span>len_bin_to_bl</span><span> </span><span>mod_pos_pos_trivial</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_ucast_up</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;is_up UCAST(&#39;a::len&#8594;&#39;b::len) &#10233; word_to_lint (UCAST(&#39;a&#8594;&#39;b) a) = zext LENGTH (&#39;b) (word_to_lint a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>word_to_lint_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zext_in_range</span><span> </span><span>is_up</span><span> </span><span>cast_simps</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_scast_up</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;is_up SCAST(&#39;a::len&#8594;&#39;b::len) &#10233; word_to_lint (SCAST(&#39;a&#8594;&#39;b) a) = sext LENGTH (&#39;b) (word_to_lint a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>word_to_lint_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_up</span><span> </span><span>sint_eq</span><span> </span><span>uint_sint</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_up</span><span> </span><span>sint_up_scast</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_and_simp</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a AND b) = word_to_lint a AND word_to_lint b&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uint_eq</span><span> </span><span>word_to_lint_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uint_and</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_or_simp</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a OR b) = word_to_lint a OR word_to_lint b&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uint_eq</span><span> </span><span>word_to_lint_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uint_or</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_xor_simp</span><span class="delimiter">[</span><span>word_to_lint_convs</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_to_lint (a XOR b) = word_to_lint a XOR word_to_lint b&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uint_eq</span><span> </span><span>word_to_lint_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uint_xor</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>    
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Quite arbitrary lemmas! Sort them! *)</span></span></span></span></span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>from_bool_lint_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(from_bool b :: 1 word) = lint_to_word (bool_to_lint b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>from_bool_def</span><span> </span><span>bool_to_lint_def</span><span> </span><span>ltrue_def</span><span> </span><span>lfalse_def</span><span> </span><span>lint_to_word_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_to_uint_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_uint (word_to_lint a) = uint a&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_to_sint_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lint_to_sint (word_to_lint a) = sint a&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span> </span><span>sint_uint</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_to_uint_0_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(lint_to_uint (word_to_lint b) = 0) = (b = 0)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_to_uint_conv</span><span> </span><span>uint_0_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_to_lint_to_sint_0_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(lint_to_sint (word_to_lint (b::_::len word)) = 0) = (b = 0)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_to_sint_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>width_word_to_lint</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;width (word_to_lint (w::&#39;a::len0 word)) = LENGTH (&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_to_lint_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_up&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::len0 word &#8658; &#39;b::len0 word) &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_up&#39; c &#10231; source_size c &lt; target_size c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_down&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a::len0 word &#8658; &#39;b::len0 word) &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_down&#39; c &#10231; target_size c &lt; source_size c&quot;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_down&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_down&#39; c &#10231; len_of TYPE(&#39;b) &lt; len_of TYPE(&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len0 word &#8658; &#39;b::len0 word&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>is_down&#39;_def</span><span> </span><span>source_size</span><span> </span><span>target_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_up&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_up&#39; c &#10231; len_of TYPE(&#39;a) &lt; len_of TYPE(&#39;b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len0 word &#8658; &#39;b::len0 word&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>is_up&#39;_def</span><span> </span><span>source_size</span><span> </span><span>target_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>is_down&#39;_imp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>is_down&#39;</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>is_up&#39;_imp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>is_up&#39;</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_down&#39;_imp_down</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_down&#39; c &#10233; is_down c&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_down</span><span> </span><span>is_down&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_up&#39;_imp_up</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_up&#39; c &#10233; is_up c&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_up</span><span> </span><span>is_up&#39;</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span>  
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


