<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory LLVM_DS_Arith (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory LLVM_DS_Arith</h1>

<span class="command">theory</span> <span class="name">LLVM_DS_Arith</span><br/>
<span class="keyword">imports</span> <a href="LLVM_VCG_Main.html"><span class="name">LLVM_VCG_Main</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Fixed-Width Integer Arithmetic&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>LLVM_DS_Arith</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;../vcg/LLVM_VCG_Main&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Implementing integers and natural numbers
  by fixed-width integers&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>snats</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snats n = {i. i &lt; 2 ^ (n-1)}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>max_unat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;max_unat n &#8801; 2^n&quot;</span></span></span><span>  
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_uint &#8801; 0::int&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>max_uint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; int&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;max_uint n &#8801; 2^n&quot;</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>min_sint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; int&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_sint n &#8801; -(2^(n-1))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>max_sint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; int&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;max_sint n &#8801; 2^(n-1)&quot;</span></span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;max_snat n &#8801; (2::nat)^(n-1)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_unats_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;unats n &#10231; x&lt;max_unat n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unats_def</span><span> </span><span>max_unat_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_sints_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8800;0 &#10233; x&#8712;sints n &#10231; min_sint n &#8804; x &#8743; x&lt;max_sint n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sints_num</span><span> </span><span>min_sint_def</span><span> </span><span>max_sint_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_uints_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;uints n &#10231; min_uint &#8804; x &#8743; x&lt;max_uint n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uints_num</span><span> </span><span>max_uint_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_snats_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8712;snats N &#10231; n&lt;max_snat N&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snats_def</span><span> </span><span>max_snat_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_range_uint_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;range (uint::&#39;a::len word &#8658; _) &#10231; min_uint &#8804; x &#8743; x&lt;max_uint LENGTH(&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uints_num</span><span> </span><span>max_uint_def</span><span> </span><span>word_uint.Rep_range</span><span class="delimiter">)</span><span> 
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_lt_max_uint</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint (w::&#39;a::len word) &lt; max_uint LENGTH(&#39;a)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_uint_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_lt_max_unat</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat (w::&#39;a::len word) &lt; max_unat LENGTH(&#39;a)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max_unat_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_cmp_extr_sint</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;min_sint LENGTH(&#39;a) &#8804; sint (w::&#39;a::len word)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sint (w::&#39;a::len word) &lt; max_sint LENGTH(&#39;a)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>max_sint_def</span><span> </span><span>min_sint_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sint_range&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>snat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_::len2 word &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat &#8801; nat o sint&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>       
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_bin_nth_if_less</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;0&#8804;i; i&lt;2^n&#10215; &#10233; &#172;(bin_nth i n)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bintrunc_mod2p</span><span> </span><span>nth_bintr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>       
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_zero</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat 0 = 0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_one</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat (1) = 1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_numeral</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>b</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;w::&#39;a::len2 word &#8801; numeral b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n::nat &#8801; numeral b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&lt;max_snat LENGTH(&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat w = n&quot;</span></span></span><span>    
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>MSB</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;msb w&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>w_def</span><span> </span><span>n_def</span><span> </span><span>max_snat_def</span><span> </span><span>not_bin_nth_if_less</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>not_bin_nth_if_less</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>of_nat_less_iff</span><span> </span><span>of_nat_numeral</span><span> </span><span>semiring_1_class.of_nat_power</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat w = nat (sint w)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>snat_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint w = uint w&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>MSB</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sint_eq_uint</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = numeral b mod 2^LENGTH(&#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>w_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>uint_numeral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = numeral b&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mod_pos_pos_trivial</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int n &lt; int (Suc 1 ^ len_of (TYPE(&#39;a)::&#39;a itself))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>diff_le_self</span><span> </span><span>lessI</span><span> </span><span>max_snat_def</span><span> </span><span>numerals</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>of_nat_less_iff</span><span> </span><span>order_less_le_trans</span><span> </span><span>power_increasing_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(numeral b::int) &lt; 2 ^ len_of (TYPE(&#39;a)::&#39;a itself)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>n_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_len &#8801; &#955;_::&#39;a::len0 word. LENGTH(&#39;a)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_lt_max_snat</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat w &lt; max_snat (word_len w)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_def</span><span> </span><span>max_snat_def</span><span> </span><span>sint_range&#39;</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Constant Folding&#8250;</span></span></span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
   TODO: No idea how complete these are 
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>llvm_num_const_simps</span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="delimiter">=</span><span> </span><span>Num.arith_simps</span><span> </span><span>power_numeral</span><span> </span><span>pred_numeral_simps</span><span> </span><span>power_0</span><span>
</span><span>    </span><span>arith_special</span><span> </span><span>numeral_One</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Reflection of Maximum Representable Values&#8250;</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ll_max_uint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;l::len word llM&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ll_max_uint &#8801; ll_sub 0 1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ll_max_sint</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;l::len2 word llM&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ll_max_sint &#8801; doM {r &#8592; ll_max_uint; ll_lshr r 1}&quot;</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_max_uint_simp</span><span class="delimiter">[</span><span>vcg_normalize_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(ll_max_uint::&#39;l::len word llM) = return (word_of_int (max_uint LENGTH(&#39;l) - 1))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ll_max_uint_def</span><span> </span><span>max_uint_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_normalize</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_of_int_minus</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>len_neq_one_conv</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;LENGTH(&#39;l::len) &#8800; Suc 0 &#10231; (&#8707;n. LENGTH(&#39;l) = Suc (Suc n))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_pred&#39;</span><span> </span><span>len_gt_0</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_of_int_div2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&#8804;w &#10233; w&lt;2^LENGTH(&#39;a) &#10233; word_of_int w div (2::&#39;a::len word) = word_of_int (w div 2)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_uint_eq_iff</span><span> </span><span>uint_word_of_int</span><span> </span><span>uint_div</span><span> </span><span>bintrunc_mod2p</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>int_mod_eq&#39;</span><span> </span><span>mod_self</span><span> </span><span>zdiv_eq_0_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>word_of_int_shr1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&#8804;w &#10233; w&lt;2^LENGTH(&#39;a::len) &#10233; (word_of_int w :: &#39;a word) &gt;&gt; Suc 0 = word_of_int (w div 2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>shiftr1_is_div_2</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>word_of_int_div2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_max_sint_aux1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((4::int) * 2 ^ n - 1) div 2 &lt; 4 * 2 ^ n&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((4::int) * 2 ^ n - 1) &lt; (4::int) * 2 ^ n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((4::int) * 2 ^ n - 1) div 2 &#8804; ((4::int) * 2 ^ n) div 2&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; &lt; 4 * 2^n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_max_sint_simp</span><span class="delimiter">[</span><span>vcg_normalize_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(ll_max_sint::&#39;l::len2 word llM) = return (word_of_int (max_sint LENGTH(&#39;l) - 1))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ll_max_sint_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>Suc_lessI</span><span> </span><span>max_sint_def</span><span> </span><span>max_uint_def</span><span> </span><span>len_neq_one_conv</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg_normalize</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_of_int_shr1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>len2E</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">=</span><span class="tfree">&#39;l</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>word_of_int_inj</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>field_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nonneg_mod_div</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ll_max_sint_aux1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>one_le_power</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pos_add_strict</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_max_uint_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple &#9633; (ll_max_uint::&#39;l::len word llM) (&#955;r. &#8593;(uint r = max_uint (LENGTH(&#39;l)) - 1))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>max_uint_def</span><span> </span><span>zmod_minus1</span><span> </span><span>uint_word_ariths</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ll_max_uint_def</span><span> </span><span>max_uint_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_max_sint_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#9633;) (ll_max_sint::&#39;l::len2 word llM) (&#955;r. &#8593;(uint r = max_sint LENGTH(&#39;l) - 1))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uint_word_of_int</span><span> </span><span>max_sint_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>diff_le_self</span><span> </span><span>int_mod_eq</span><span> </span><span>power_increasing_iff</span><span> </span><span>zless2p</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Signed Integers&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>sint</span><span class="delimiter">:</span><span> </span><span>standard_opr_abstraction</span><span> </span><span>sint</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;_. True&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;op (_::&#39;a::len word itself) a. op a &#8712; sints LENGTH(&#39;a)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;op (_::&#39;a::len word itself) a b. op a b &#8712; sints LENGTH(&#39;a)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a c. a&#8712;sints LENGTH(&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>prove_sint_op</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>  </span><span>rule</span><span> </span><span>sint.is_bin_opI</span><span> </span><span>sint.is_cmp_opI</span><span> </span><span>sint.is_un_opI</span><span class="delimiter">;</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>min_sint_def</span><span> </span><span>max_sint_def</span><span> </span><span>vcg_normalize_simps</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">;</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>determ</span><span> </span><span>uint_arith</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_neq_ZD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint b &#8800; 0 &#10233; b&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>                                             
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_bin_ops</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sint.is_bin_op&#39; ll_add (+) (+)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sint.is_bin_op&#39; ll_sub (-) (-)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sint.is_bin_op&#39; ll_mul (*) (*)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sint.is_bin_op (&#955;(_::&#39;a::len word itself) a b. b&#8800;0 &#8743; a sdiv b &#8712; sints LENGTH(&#39;a)) ll_sdiv (sdiv) (sdiv)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sint.is_bin_op (&#955;(_::&#39;a::len word itself) a b. b&#8800;0 &#8743; a sdiv b &#8712; sints LENGTH(&#39;a)) ll_srem (smod) (smod)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>in_sints_conv</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;prove_sint_op simp:  sint_neq_ZD&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sbintrunc_eq_if_in_range</span><span> </span><span>sint_word_ariths</span><span> </span><span>signed_mod_arith</span><span> </span><span>signed_div_arith</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smod_word_min</span><span> </span><span>smod_word_max</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_sints_conv</span><span> </span><span>min_sint_def</span><span> </span><span>max_sint_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint_cmp_ops</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sint.is_cmp_op ll_icmp_eq (=) (=)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sint.is_cmp_op ll_icmp_ne (&#8800;) (&#8800;)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sint.is_cmp_op ll_icmp_sle (&#955;a b. a &lt;=s b) (&#8804;)&quot;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME: Why isn&#39;t &lt;=s and &lt;s proper infix operator? *)</span></span></span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;sint.is_cmp_op ll_icmp_slt (&#955;a b. a &lt;s b) (&lt;)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;prove_sint_op simp: word_sle_def word_sless_def le_less&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>sint_rules</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>  
</span><span>  </span><span>sint_bin_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sint.bin_op_tmpl</span><span class="delimiter">]</span><span>
</span><span>  </span><span>sint_cmp_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sint.cmp_op_tmpl</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>    
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>signed</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len word &#8658; &#39;a word&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed c &#8801; c&quot;</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed (numeral a)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed (-numeral a)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed 0&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed (-0)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed 1&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed (-1)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monadify_signed</span><span class="delimiter">[</span><span>vcg_monadify_xforms</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;return (signed x) = ll_const (signed x)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ll_const_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_const_signed_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;n&#8800;0; - (2 ^ (n - Suc 0)) &#8804; i; i &lt; 2 ^ (n - Suc 0)&#10215;
         &#10233; (i + 2 ^ (n - Suc 0)) mod 2 ^ n - 2 ^ (n - Suc 0) = (i::int)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>n</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_const_signed_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple &#9633; (ll_const (signed 0)) (&#955;r. &#8639;sint.assn 0 r)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#8593;<span class="hidden">&#8681;</span><sub>d</sub>(LENGTH(&#39;a::len) &#8800; 1)) (ll_const (signed (1::&#39;a word))) (&#955;r. &#8639;sint.assn 1 r)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#8593;<span class="hidden">&#8681;</span><sub>d</sub>(numeral w &#8712; sints LENGTH(&#39;a))) (ll_const (signed (numeral w::&#39;a::len word))) (&#955;r. &#8639;sint.assn (numeral w) r)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ll_const_def</span><span> </span><span>signed_def</span><span> </span><span>sint.assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>sbintrunc_mod2p</span><span> </span><span>max_sint_def</span><span> </span><span>min_sint_def</span><span> </span><span>ll_const_signed_aux</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lt_exp2n_signed_estimate</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>int</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8801;LENGTH(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ASSUMPTION (n &gt; n&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&lt;2^n&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &lt; max_sint n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ASSUMPTION_def</span><span> </span><span>max_sint_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_le_mono</span><span> </span><span>Suc_pred</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>len_gt_0</span><span> </span><span>less_eq_Suc_le</span><span> </span><span>power_increasing_iff</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>  
</span><span>    
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Unsigned Integers&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>uint</span><span class="delimiter">:</span><span> </span><span>standard_opr_abstraction</span><span> </span><span>uint</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;_. True&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;op (_::&#39;a::len word itself) a. op a &#8712; uints LENGTH(&#39;a)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;op (_::&#39;a::len word itself) a b. op a b &#8712; uints LENGTH(&#39;a)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a c. a&#8712;uints LENGTH(&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>prove_uint_op</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>  </span><span>rule</span><span> </span><span>uint.is_bin_opI</span><span> </span><span>uint.is_cmp_opI</span><span> </span><span>uint.is_un_opI</span><span class="delimiter">;</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_uint_def</span><span> </span><span>vcg_normalize_simps</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">;</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>determ</span><span> </span><span>uint_arith</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_neq_ZD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint b &#8800; 0 &#10233; b&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>                                             
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_bin_ops_arith</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_bin_op (&#955;(_::&#39;a::len word itself) a b. a+b &lt; max_uint LENGTH(&#39;a)) ll_add (+) (+)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_bin_op (&#955;_ a b. b&#8804;a) ll_sub (-) (-)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_bin_op (&#955;(_::&#39;a::len word itself) a b. a*b &lt; max_uint LENGTH(&#39;a)) ll_mul (*) (*)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_bin_op (&#955;_ a b. b&#8800;0) ll_udiv (div) (div)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_bin_op (&#955;_ a b. b&#8800;0) ll_urem (mod) (mod)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;prove_uint_op simp: uint_mult_lem uint_neq_ZD uint_div uint_mod&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Remove preconditions! *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_bin_ops_bitwise</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_bin_op (&#955;_ _ _. True) ll_and (AND) (AND)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_bin_op (&#955;_ _ _. True) ll_or (OR) (OR)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_bin_op (&#955;_ _ _. True) ll_xor (XOR) (XOR)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;prove_uint_op simp: uint_and uint_or uint_xor&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>uint_bin_ops</span><span> </span><span class="delimiter">=</span><span> </span><span>uint_bin_ops_arith</span><span> </span><span>uint_bin_ops_bitwise</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_cmp_ops</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_cmp_op ll_icmp_eq (=) (=)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_cmp_op ll_icmp_ne (&#8800;) (&#8800;)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_cmp_op ll_icmp_ule (&#8804;) (&#8804;)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint.is_cmp_op ll_icmp_ult (&lt;) (&lt;)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;prove_uint_op&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>uint_rules</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>uint_bin_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>uint.bin_op_tmpl</span><span class="delimiter">]</span><span>
</span><span>  </span><span>uint_cmp_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>uint.cmp_op_tmpl</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unsigned</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len word &#8658; &#39;a word&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsigned c &#8801; c&quot;</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsigned (numeral a)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsigned 0&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsigned 1&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monadify_unsigned</span><span class="delimiter">[</span><span>vcg_monadify_xforms</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;return (unsigned x) = ll_const (unsigned x)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ll_const_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_const_unsigned_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple &#9633; (ll_const (unsigned 0)) (&#955;r. &#8639;uint.assn 0 r)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple &#9633; (ll_const (unsigned 1)) (&#955;r. &#8639;uint.assn 1 r)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#8593;<span class="hidden">&#8681;</span><sub>d</sub>(numeral w &#8712; uints LENGTH(&#39;a))) (ll_const (unsigned (numeral w::&#39;a::len word))) (&#955;r. &#8639;uint.assn (numeral w) r)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ll_const_def</span><span> </span><span>unsigned_def</span><span> </span><span>uint.assn_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>max_uint_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lt_exp2n_estimate</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>int</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8801;LENGTH(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ASSUMPTION (n &#8805; n&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&lt;2^n&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &lt; max_uint n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ASSUMPTION_def</span><span> </span><span>max_uint_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>power_increasing_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Natural Numbers by unsigned&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint _ &lt; max_uint _&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>unat</span><span class="delimiter">:</span><span> </span><span>standard_opr_abstraction</span><span> </span><span>unat</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;_. True&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;op (_::&#39;a::len word itself) a. op a &#8712; unats LENGTH(&#39;a)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;op (_::&#39;a::len word itself) a b. op a b &#8712; unats LENGTH(&#39;a)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a c. a&#8712;unats LENGTH(&#39;a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>prove_unat_op</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>  </span><span>rule</span><span> </span><span>unat.is_bin_opI</span><span> </span><span>unat.is_cmp_opI</span><span class="delimiter">;</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_unat_def</span><span> </span><span>vcg_normalize_simps</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">;</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>determ</span><span> </span><span>unat_arith</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_neq_ZD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat b &#8800; 0 &#10233; b&#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>                                             
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_bin_ops</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_bin_op (&#955;(_::&#39;a::len word itself) a b. a+b &lt; max_unat LENGTH(&#39;a)) ll_add (+) (+)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_bin_op (&#955;_ a b. b&#8804;a) ll_sub (-) (-)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_bin_op (&#955;(_::&#39;a::len word itself) a b. a*b &lt; max_unat LENGTH(&#39;a)) ll_mul (*) (*)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_bin_op (&#955;_ a b. b&#8800;0) ll_udiv (div) (div)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_bin_op (&#955;_ a b. b&#8800;0) ll_urem (mod) (mod)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;prove_unat_op simp: unat_mult_lem unat_neq_ZD unat_div unat_mod&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_bin_ops_bitwise</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_bin_op (&#955;_ _ _. True) ll_and (AND) (AND)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_bin_op (&#955;_ _ _. True) ll_or (OR) (OR)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_bin_op (&#955;_ _ _. True) ll_xor (XOR) (XOR)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;prove_unat_op simp: unat_and unat_or unat_xor&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_cmp_ops</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_cmp_op ll_icmp_eq (=) (=)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_cmp_op ll_icmp_ne (&#8800;) (&#8800;)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_cmp_op ll_icmp_ule (&#8804;) (&#8804;)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat.is_cmp_op ll_icmp_ult (&lt;) (&lt;)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;prove_unat_op&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>unat_rules</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>unat_bin_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>unat.bin_op_tmpl</span><span class="delimiter">]</span><span>
</span><span>  </span><span>unat_cmp_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>unat.cmp_op_tmpl</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unsigned_nat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len word &#8658; &#39;a word&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsigned_nat c &#8801; c&quot;</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsigned_nat (numeral a)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsigned_nat 0&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsigned_nat 1&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monadify_unsigned_nat</span><span class="delimiter">[</span><span>vcg_monadify_xforms</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;return (unsigned_nat x) = ll_const (unsigned_nat x)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ll_const_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_const_unsigned_nat_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple &#9633; (ll_const (unsigned_nat 0)) (&#955;r. &#8639;unat.assn 0 r)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple &#9633; (ll_const (unsigned_nat 1)) (&#955;r. &#8639;unat.assn 1 r)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#8593;<span class="hidden">&#8681;</span><sub>d</sub>(numeral w &#8712; unats LENGTH(&#39;a))) (ll_const (unsigned_nat (numeral w::&#39;a::len word))) (&#955;r. &#8639;unat.assn (numeral w) r)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ll_const_def</span><span> </span><span>unsigned_nat_def</span><span> </span><span>unat.assn_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>bintrunc_mod2p</span><span> </span><span>max_unat_def</span><span> </span><span>unat_numeral</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>unat_bintrunc</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg</span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lt_exp2n_nat_estimate</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8801;LENGTH(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ASSUMPTION (n &#8805; n&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&lt;2^n&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &lt; max_unat n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ASSUMPTION_def</span><span> </span><span>max_unat_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>le_def</span><span> </span><span>le_less_trans</span><span> </span><span>nat_power_less_imp_less</span><span> </span><span>pos2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Natural Numbers by signed&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_invar (w::&#39;a::len2 word) &#8801; &#172;msb w&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>snat</span><span class="delimiter">:</span><span> </span><span>standard_opr_abstraction</span><span> </span><span>snat</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_invar&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;op (_::&#39;a::len2 word itself) a. op a &#8712; snats LENGTH(&#39;a)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;op (_::&#39;a::len2 word itself) a b. op a b &#8712; snats LENGTH(&#39;a)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a c. a&#8712;snats LENGTH(&#39;a)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_invar_alt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_invar (w::&#39;a::len2 word) &#10231; (&#8707;n. word_len w = Suc n &#8743; unat w &lt; 2^n)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_len w&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span> </span><span>msb_unat_big</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_eq_unat</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unat w &lt; 2^(word_len w - 1) &#10233; snat w = unat w&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat_invar w &#10233; snat w = unat w&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_def</span><span> </span><span>unat_def</span><span> </span><span>sint_eq_uint</span><span> </span><span>msb_uint_big</span><span> </span><span>snat_invar_alt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cnv_snat_to_uint</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_invar w&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat w = nat (uint w)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sint w = uint w&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat w = nat (uint w)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>unat_def</span><span> </span><span>sint_eq_uint</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sint_eq_uint</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unat_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method</span></span><span> </span><span>prove_snat_op</span><span> </span><span class="keyword2"><span class="keyword">uses</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">=</span><span> </span><span class="delimiter">(</span><span>
</span><span>  </span><span>rule</span><span> </span><span>snat.is_bin_opI</span><span> </span><span>snat.is_cmp_opI</span><span class="delimiter">;</span><span> 
</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_snat_def</span><span> </span><span>snat_invar_alt</span><span> </span><span>snat_eq_unat</span><span> </span><span>vcg_normalize_simps</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>  
</span><span>    
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>                                             
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_in_bounds_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(a::nat)&lt;2^(x-Suc 0) &#10233; a&lt;2^x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>diff_le_self</span><span> </span><span>leI</span><span> </span><span>le_less_trans</span><span> </span><span>less_not_refl</span><span> </span><span>nat_power_less_imp_less</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_bin_ops</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_bin_op&#39; ll_add (+) (+)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_bin_op (&#955;_ a b. b&#8804;a) ll_sub (-) (-)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_bin_op&#39; ll_mul (*) (*)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_bin_op (&#955;_ a b. b&#8800;0) ll_udiv (div) (div)&quot;</span></span></span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_bin_op (&#955;_ a b. b&#8800;0) ll_urem (mod) (mod)&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_word_ariths</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_word_ariths</span><span> </span><span>unat_sub_if&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_word_ariths</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_word_ariths</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ll_udiv_simp</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>div_le_dividend</span><span> </span><span>le_less_trans</span><span> </span><span>power_Suc</span><span> </span><span>unat_div</span><span> </span><span>unat_of_nat</span><span> </span><span>word_arith_nat_defs</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>snat_eq_unat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_div</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>div_le_dividend</span><span> </span><span>le_less_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_word_ariths</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>ll_urem_simp</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>le_less_trans</span><span> </span><span>mod_less_eq_dividend</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>snat_eq_unat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_mod</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>le_less_trans</span><span> </span><span>mod_less_eq_dividend</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_cmp_ops</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_cmp_op ll_icmp_eq (=) (=)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_cmp_op ll_icmp_ne (&#8800;) (&#8800;)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_cmp_op ll_icmp_ule (&#8804;) (&#8804;)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_cmp_op ll_icmp_ult (&lt;) (&lt;)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_cmp_op ll_icmp_sle (&#955;a b. a &lt;=s b) (&#8804;)&quot;</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;snat.is_cmp_op ll_icmp_slt (&#955;a b. a &lt;s b) (&lt;)&quot;</span></span></span><span> 
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_le_nat_alt</span><span> </span><span>word_less_nat_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_le_nat_alt</span><span> </span><span>word_less_nat_alt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_le_nat_alt</span><span> </span><span>word_less_nat_alt</span><span> </span><span>word_sle_msb_le</span><span> </span><span>msb_unat_big</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>prove_snat_op</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>word_le_nat_alt</span><span> </span><span>word_less_nat_alt</span><span> </span><span>word_sle_msb_le</span><span> </span><span>word_sless_msb_less</span><span> </span><span>msb_unat_big</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>snat_rules</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>snat_bin_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>snat.bin_op_tmpl</span><span class="delimiter">]</span><span>
</span><span>  </span><span>snat_cmp_ops</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>snat.cmp_op_tmpl</span><span class="delimiter">]</span><span>
</span><span>  
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>signed_nat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::len2 word &#8658; &#39;a word&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_nat c &#8801; c&quot;</span></span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_nat (numeral a)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_nat 0&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>vcg_const</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;signed_nat 1&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monadify_signed_nat</span><span class="delimiter">[</span><span>vcg_monadify_xforms</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;return (signed_nat x) = ll_const (signed_nat x)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ll_const_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_const_signed_nat_aux1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(w::nat) &lt; 2^(n-1) &#10233; w mod (2^n) = w&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>snat_in_bounds_aux</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_const_signed_nat_aux2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;numeral w &lt; (2::nat) ^ (LENGTH(&#39;a::len2) - Suc 0)&#10215; &#10233; &#172;msb (numeral w::&#39;a word)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>msb_unat_big</span><span> </span><span>snat_in_bounds_aux</span><span> </span><span>unat_numeral</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>unat_bintrunc</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_const_signed_nat_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#9633;) (ll_const (signed_nat (0::&#39;a word))) (&#955;r. &#8639;snat.assn 0 r)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#9633;) (ll_const (signed_nat (1::&#39;a word))) (&#955;r. &#8639;snat.assn 1 r)&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#8593;<span class="hidden">&#8681;</span><sub>d</sub>(numeral w &#8712; snats LENGTH(&#39;a))) (ll_const (signed_nat (numeral w::&#39;a::len2 word))) (&#955;r. &#8639;snat.assn (numeral w) r)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ll_const_def</span><span> </span><span>signed_nat_def</span><span> </span><span>snat.assn_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not0_implies_Suc</span><span> </span><span>snat_invar_alt</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LENGTH(&#39;a)&quot;</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>ll_const_signed_nat_aux2</span><span> </span><span>max_snat_def</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      
</span><span class="keyword2"><span class="keyword">end</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lt_exp2n_snat_estimate</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8801;LENGTH(&#39;a::len)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ASSUMPTION (n &gt; n&#39;)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&lt;2^n&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &lt; max_snat n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ASSUMPTION_def</span><span> </span><span>max_snat_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_leI</span><span> </span><span>leI</span><span> </span><span>le_less_trans</span><span> </span><span>nat_power_less_imp_less</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>order_less_irrefl</span><span> </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ll_max_snat &#8801; ll_max_sint&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ll_max_snat_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#9633;) ll_max_snat (&#955;r::&#39;l word. &#8639;snat.assn (max_snat LENGTH(&#39;l::len2) - 1) r)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_invar (word_of_int (max_sint LENGTH(&#39;l) - 1)::&#39;l word)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>len2E</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">=</span><span class="tfree">&#39;l</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_invar_alt</span><span> </span><span>unat_def</span><span> </span><span>len_neq_one_conv</span><span> </span><span>max_sint_def</span><span> </span><span>max_snat_def</span><span> </span><span>snat_def</span><span> </span><span>uint_word_of_int</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>int_mod_eq&#39;</span><span> </span><span>one_le_power</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ll_max_snat_def</span><span> </span><span>snat.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cnv_snat_to_uint</span><span> </span><span>uint_word_of_int</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>len_neq_one_conv</span><span> </span><span>max_sint_def</span><span> </span><span>max_snat_def</span><span> </span><span>snat_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nat_mod_distrib</span><span> </span><span>nat_mult_distrib</span><span> </span><span>nat_diff_distrib&#39;</span><span> </span><span>nat_power_eq</span><span> </span><span>less_imp_diff_less</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Casting&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Add other casts. 

  up/down * su/us/ss/uu

  and su_conv, us_conv
  
  Some casts might be expressable as up/downcast followed by conv!
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_snat_upcast TYPE(&#39;a::len2) x &#8801; ll_zext x TYPE(&#39;a word)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_unat_downcast TYPE(&#39;a::len) x &#8801; ll_trunc x TYPE(&#39;a word)&quot;</span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_snat_upcast TYPE(&#39;a::len2) x &#8801; ll_zext x TYPE(&#39;a word)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_snat_downcast TYPE(&#39;a::len) x &#8801; ll_trunc x TYPE(&#39;a word)&quot;</span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_unat_upcast TYPE(&#39;a::len) x &#8801; ll_zext x TYPE(&#39;a word)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_unat_downcast TYPE(&#39;a::len) x &#8801; ll_trunc x TYPE(&#39;a word)&quot;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unat_snat_conv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;l::len2 word &#8658; &#39;l word llM&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat_snat_conv x &#8801; return x&quot;</span></span></span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>snat_unat_conv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;l::len2 word &#8658; &#39;l word llM&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snat_unat_conv x &#8801; return x&quot;</span></span></span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_snat_upcast_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
      (&#8593;(is_up&#39; UCAST(&#39;small &#8594; &#39;big)) ** &#8639;unat.assn n (ni::&#39;small::len word)) 
      (unat_snat_upcast TYPE(&#39;big::len2) ni) 
      (&#955;r. &#8639;snat.assn n r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat.assn_def</span><span> </span><span>snat.assn_def</span><span> </span><span>unat_snat_upcast_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>unat_ucast_upcast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_unat_downcast_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
      (&#8593;(is_down&#39; UCAST(&#39;big &#8594; &#39;small)) ** &#8639;snat.assn n (ni::&#39;big::len2 word) ** &#8593;(n&lt;max_unat LENGTH(&#39;small))) 
      (snat_unat_downcast TYPE(&#39;small::len) ni) 
      (&#955;r. &#8639;unat.assn n r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat.assn_def</span><span> </span><span>snat.assn_def</span><span> </span><span>snat_unat_downcast_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>max_unat_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ucast_nat_def</span><span> </span><span>unat_of_nat_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_snat_upcast_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
      (&#8593;(is_up&#39; UCAST(&#39;small &#8594; &#39;big)) ** &#8639;snat.assn n (ni::&#39;small::len2 word)) 
      (snat_snat_upcast TYPE(&#39;big::len2) ni) 
      (&#955;r. &#8639;snat.assn n r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat.assn_def</span><span> </span><span>snat.assn_def</span><span> </span><span>snat_snat_upcast_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>unat_ucast_upcast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_snat_downcast_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
      (&#8593;(is_down&#39; UCAST(&#39;big &#8594; &#39;small)) ** &#8639;snat.assn n (ni::&#39;big::len2 word) ** &#8593;(n&lt;max_snat LENGTH(&#39;small))) 
      (snat_snat_downcast TYPE(&#39;small::len2) ni) 
      (&#955;r. &#8639;snat.assn n r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snat.assn_def</span><span> </span><span>snat_snat_downcast_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span> </span><span>max_snat_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>le_def</span><span> </span><span>msb_unat_big</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snat_in_bounds_aux</span><span> </span><span>ucast_nat_def</span><span> </span><span>unat_of_nat_len</span><span class="delimiter">)</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_unat_upcast_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
      (&#8593;(is_up&#39; UCAST(&#39;small &#8594; &#39;big)) ** &#8639;unat.assn n (ni::&#39;small::len word)) 
      (unat_unat_upcast TYPE(&#39;big::len) ni) 
      (&#955;r. &#8639;unat.assn n r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat.assn_def</span><span> </span><span>snat.assn_def</span><span> </span><span>unat_unat_upcast_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>unat_ucast_upcast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_unat_downcast_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple 
      (&#8593;(is_down&#39; UCAST(&#39;big &#8594; &#39;small)) ** &#8639;unat.assn n (ni::&#39;big::len word) ** &#8593;(n&lt;max_unat LENGTH(&#39;small))) 
      (unat_unat_downcast TYPE(&#39;small::len) ni) 
      (&#955;r. &#8639;unat.assn n r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat.assn_def</span><span> </span><span>unat.assn_def</span><span> </span><span>unat_unat_downcast_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_invar_def</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>max_unat_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ucast_nat_def</span><span> </span><span>unat_of_nat_eq</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unat_snat_conv_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#8639;unat.assn x (xi::&#39;l::len2 word) ** &#8593;(x&lt;max_snat LENGTH(&#39;l))) (unat_snat_conv xi) (&#955;r. &#8639;snat.assn x r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unat_snat_conv_def</span><span> </span><span>unat.assn_def</span><span> </span><span>snat.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_snat_def</span><span> </span><span>snat_invar_alt</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snat_unat_conv_rule</span><span class="delimiter">[</span><span>vcg_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;llvm_htriple (&#8639;snat.assn x (xi::&#39;l::len2 word)) (snat_unat_conv xi) (&#955;r. &#8639;unat.assn x r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snat_unat_conv_def</span><span> </span><span>unat.assn_def</span><span> </span><span>snat.assn_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_snat_def</span><span> </span><span>snat_invar_alt</span><span> </span><span>snat_eq_unat</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


