<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Uint64 (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Uint64</h1>

<span class="command">theory</span> <span class="name">Uint64</span><br/>
<span class="keyword">imports</span> <a href="../../AFP/Collections/Code_Target_Word_Base.html"><span class="name">Code_Target_Word_Base</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Uint64.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Unsigned words of 64 bits&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Uint64</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Code_Target_Word_Base</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  PolyML (in version 5.7) provides a Word64 structure only when run in 64-bit mode.
  Therefore, we by default provide an implementation of 64-bit words using \verb$IntInf.int$ and
  masking. The code target \texttt{SML\_word} replaces this implementation and maps the operations
  directly to the \verb$Word64$ structure provided by the Standard ML implementations.

  The \verb$Eval$ target used by @{command value} and @{method eval} dynamically tests at
  runtime for the version of PolyML and uses PolyML&#39;s Word64 structure if it detects a 64-bit 
  version which does not suffer from a division bug found in PolyML 5.6.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>prod.Quotient</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Type definition and primitive operations&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;UNIV :: 64 word set&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_uint64</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Use an abstract type for code generation to disable pattern matching on @{term Abs_uint64}.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Rep_uint64_inverse</span><span class="delimiter">[</span><span>code</span><span> </span><span>abstype</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Quotient_uint64</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{neg_numeral, modulo, comm_monoid_mult, comm_ring}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zero_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span>uint64</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 :: 64 word&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>one_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span>uint64</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>plus_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(+) :: 64 word &#8658; _&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>minus_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(-)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>uminus_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>uminus</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>times_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(*)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>divide_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(div)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>modulo_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(mod)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">::</span><span> </span><span>linorder</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>less_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&lt;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>less_eq_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8804;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>less_le_not_le</span><span> </span><span>linear</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>less_uint64.rep_eq</span><span> </span><span>less_eq_uint64.rep_eq</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">::</span><span> </span><span>bit_operations</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitNOT_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>bitNOT</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitAND_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>bitAND</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitOR_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>bitOR</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>bitXOR_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>bitXOR</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>test_bit_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; nat &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>test_bit</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>set_bit_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; nat &#8658; bool &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>set_bit</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>lsb_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>lsb</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>shiftl_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; nat &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>shiftl</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>shiftr_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; nat &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>shiftr</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>msb_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>msb</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">::</span><span> </span><span>bit_comprehension</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>set_bits_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat &#8658; bool) &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_bits&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>test_bit_uint64.rep_eq</span><span> </span><span>lsb_uint64.rep_eq</span><span> </span><span>msb_uint64.rep_eq</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">::</span><span> </span><span>equal</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>equal_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;equal_class.equal&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>equal_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>equal_uint64.rep_eq</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">::</span><span> </span><span>size</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>size_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;size&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>size_uint64.rep_eq</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>sshiftr_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; nat &#8658; uint64&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&gt;&gt;&gt;&quot;</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>sshiftr</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>uint64_of_int</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_of_int&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_of_nat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; uint64&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_of_nat = uint64_of_int &#8728; int&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>int_of_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; int&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>nat_of_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unat&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>integer_of_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; integer&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;integer_of_uint64 = integer_of_int o int_of_uint64&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bitval_integer_transfer</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(rel_fun (=) pcr_integer) of_bool of_bool&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>of_bool_def</span><span> </span><span>integer.pcr_cr_eq</span><span> </span><span>cr_integer_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bit.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Use pretty numerals from integer for pretty printing&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>integer.lifting</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;integer &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;word_of_int&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rep_uint64_numeral</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Rep_uint64 (numeral n) = numeral n&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>one_uint64_def</span><span> </span><span>Abs_uint64_inverse</span><span> </span><span>numeral.simps</span><span> </span><span>plus_uint64_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>numeral_uint64_transfer</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(rel_fun (=) cr_uint64) numeral numeral&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cr_uint64_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>numeral_uint64</span><span> </span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;numeral n = Uint64 (numeral n)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rep_uint64_neg_numeral</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Rep_uint64 (- numeral n) = - numeral n&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>uminus_uint64_def</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_uint64_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>neg_numeral_uint64</span><span> </span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;- numeral n = Uint64 (- numeral n)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cr_uint64_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Abs_uint64_numeral</span><span> </span><span class="delimiter">[</span><span>code_post</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Abs_uint64 (numeral n) = numeral n&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>one_uint64_def</span><span> </span><span>numeral.simps</span><span> </span><span>plus_uint64_def</span><span> </span><span>Abs_uint64_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Abs_uint64_0</span><span> </span><span class="delimiter">[</span><span>code_post</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Abs_uint64 0 = 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zero_uint64_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Abs_uint64_1</span><span> </span><span class="delimiter">[</span><span>code_post</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Abs_uint64 1 = 1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>one_uint64_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Code setup&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; For SML, we generate an implementation of unsigned 64-bit words using \verb$IntInf.int$.
  If @{ML &quot;LargeWord.wordSize &gt; 63&quot;} of the Isabelle/ML runtime environment holds, then we assume
  that there is also a &#8249;Word64&#8250; structure available and accordingly replace the implementation
  for the target \verb$Eval$.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(* Test that words can handle numbers between 0 and 63 *)
val _ = if 6 &lt;= Word.wordSize then () else raise (Fail (&quot;wordSize less than 6&quot;));

structure Uint64 : sig
  eqtype uint64;
  val zero : uint64;
  val one : uint64;
  val fromInt : IntInf.int -&gt; uint64;
  val toInt : uint64 -&gt; IntInf.int;
  val toLarge : uint64 -&gt; LargeWord.word;
  val fromLarge : LargeWord.word -&gt; uint64
  val plus : uint64 -&gt; uint64 -&gt; uint64;
  val minus : uint64 -&gt; uint64 -&gt; uint64;
  val times : uint64 -&gt; uint64 -&gt; uint64;
  val divide : uint64 -&gt; uint64 -&gt; uint64;
  val modulus : uint64 -&gt; uint64 -&gt; uint64;
  val negate : uint64 -&gt; uint64;
  val less_eq : uint64 -&gt; uint64 -&gt; bool;
  val less : uint64 -&gt; uint64 -&gt; bool;
  val notb : uint64 -&gt; uint64;
  val andb : uint64 -&gt; uint64 -&gt; uint64;
  val orb : uint64 -&gt; uint64 -&gt; uint64;
  val xorb : uint64 -&gt; uint64 -&gt; uint64;
  val shiftl : uint64 -&gt; IntInf.int -&gt; uint64;
  val shiftr : uint64 -&gt; IntInf.int -&gt; uint64;
  val shiftr_signed : uint64 -&gt; IntInf.int -&gt; uint64;
  val set_bit : uint64 -&gt; IntInf.int -&gt; bool -&gt; uint64;
  val test_bit : uint64 -&gt; IntInf.int -&gt; bool;
end = struct

type uint64 = IntInf.int;

val mask = 0xFFFFFFFFFFFFFFFF : IntInf.int;

val zero = 0 : IntInf.int;

val one = 1 : IntInf.int;

fun fromInt x = IntInf.andb(x, mask);

fun toInt x = x

fun toLarge x = LargeWord.fromLargeInt (IntInf.toLarge x);

fun fromLarge x = IntInf.fromLarge (LargeWord.toLargeInt x);

fun plus x y = IntInf.andb(IntInf.+(x, y), mask);

fun minus x y = IntInf.andb(IntInf.-(x, y), mask);

fun negate x = IntInf.andb(IntInf.~(x), mask);

fun times x y = IntInf.andb(IntInf.*(x, y), mask);

fun divide x y = IntInf.div(x, y);

fun modulus x y = IntInf.mod(x, y);

fun less_eq x y = IntInf.&lt;=(x, y);

fun less x y = IntInf.&lt;(x, y);

fun notb x = IntInf.andb(IntInf.notb(x), mask);

fun orb x y = IntInf.orb(x, y);

fun andb x y = IntInf.andb(x, y);

fun xorb x y = IntInf.xorb(x, y);

val maxWord = IntInf.pow (2, Word.wordSize);

fun shiftl x n = 
  if n &lt; maxWord then IntInf.andb(IntInf.&lt;&lt; (x, Word.fromLargeInt (IntInf.toLarge n)), mask)
  else 0;

fun shiftr x n =
  if n &lt; maxWord then IntInf.~&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))
  else 0;

val msb_mask = 0x8000000000000000 : IntInf.int;

fun shiftr_signed x i =
  if IntInf.andb(x, msb_mask) = 0 then shiftr x i
  else if i &gt;= 64 then 0xFFFFFFFFFFFFFFFF
  else let
    val x&#39; = shiftr x i
    val m&#39; = IntInf.andb(IntInf.&lt;&lt;(mask, Word.max(0w64 - Word.fromLargeInt (IntInf.toLarge i), 0w0)), mask)
  in IntInf.orb(x&#39;, m&#39;) end;

fun test_bit x n =
  if n &lt; maxWord then IntInf.andb (x, IntInf.&lt;&lt; (1, Word.fromLargeInt (IntInf.toLarge n))) &lt;&gt; 0
  else false;

fun set_bit x n b =
  if n &lt; 64 then
    if b then IntInf.orb (x, IntInf.&lt;&lt; (1, Word.fromLargeInt (IntInf.toLarge n)))
    else IntInf.andb (x, IntInf.notb (IntInf.&lt;&lt; (1, Word.fromLargeInt (IntInf.toLarge n))))
  else x;

end
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">code_reserved</span></span><span> </span><span>SML</span><span> </span><span>Uint64</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
let
  val polyml64 = LargeWord.wordSize &gt; 63;
  (* PolyML 5.6 has bugs in its Word64 implementation. We test for one such bug and refrain
     from using Word64 in that case. Testing is done with dynamic code evaluation such that
     the compiler does not choke on the Word64 structure, which need not be present in a 32bit
     environment. *)
  val error_msg = &quot;Buggy Word64 structure&quot;;
  val test_code = 
   &quot;val _ = if Word64.div (0w18446744073709551611 : Word64.word, 0w3) = 0w6148914691236517203 then ()\n&quot; ^
   &quot;else raise (Fail \&quot;&quot; ^ error_msg ^ &quot;\&quot;);&quot;;
  val f = Exn.interruptible_capture (fn () =&gt; ML_Compiler.eval ML_Compiler.flags Position.none (ML_Lex.tokenize test_code))
  val use_Word64 = polyml64 andalso
    (case f () of 
       Exn.Res _ =&gt; true
     | Exn.Exn (e as ERROR m) =&gt; if String.isSuffix error_msg m then false else Exn.reraise e
     | Exn.Exn e =&gt; Exn.reraise e)
    ;

  val newline = &quot;\n&quot;;
  val content = 
    &quot;structure Uint64 : sig&quot; ^ newline ^
    &quot;  eqtype uint64;&quot; ^ newline ^
    &quot;  val zero : uint64;&quot; ^ newline ^
    &quot;  val one : uint64;&quot; ^ newline ^
    &quot;  val fromInt : IntInf.int -&gt; uint64;&quot; ^ newline ^
    &quot;  val toInt : uint64 -&gt; IntInf.int;&quot; ^ newline ^
    &quot;  val toLarge : uint64 -&gt; LargeWord.word;&quot; ^ newline ^
    &quot;  val fromLarge : LargeWord.word -&gt; uint64&quot; ^ newline ^
    &quot;  val plus : uint64 -&gt; uint64 -&gt; uint64;&quot; ^ newline ^
    &quot;  val minus : uint64 -&gt; uint64 -&gt; uint64;&quot; ^ newline ^
    &quot;  val times : uint64 -&gt; uint64 -&gt; uint64;&quot; ^ newline ^
    &quot;  val divide : uint64 -&gt; uint64 -&gt; uint64;&quot; ^ newline ^
    &quot;  val modulus : uint64 -&gt; uint64 -&gt; uint64;&quot; ^ newline ^
    &quot;  val negate : uint64 -&gt; uint64;&quot; ^ newline ^
    &quot;  val less_eq : uint64 -&gt; uint64 -&gt; bool;&quot; ^ newline ^
    &quot;  val less : uint64 -&gt; uint64 -&gt; bool;&quot; ^ newline ^
    &quot;  val notb : uint64 -&gt; uint64;&quot; ^ newline ^
    &quot;  val andb : uint64 -&gt; uint64 -&gt; uint64;&quot; ^ newline ^
    &quot;  val orb : uint64 -&gt; uint64 -&gt; uint64;&quot; ^ newline ^
    &quot;  val xorb : uint64 -&gt; uint64 -&gt; uint64;&quot; ^ newline ^
    &quot;  val shiftl : uint64 -&gt; IntInf.int -&gt; uint64;&quot; ^ newline ^
    &quot;  val shiftr : uint64 -&gt; IntInf.int -&gt; uint64;&quot; ^ newline ^
    &quot;  val shiftr_signed : uint64 -&gt; IntInf.int -&gt; uint64;&quot; ^ newline ^
    &quot;  val set_bit : uint64 -&gt; IntInf.int -&gt; bool -&gt; uint64;&quot; ^ newline ^
    &quot;  val test_bit : uint64 -&gt; IntInf.int -&gt; bool;&quot; ^ newline ^
    &quot;end = struct&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;type uint64 = Word64.word;&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;val zero = (0wx0 : uint64);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;val one = (0wx1 : uint64);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun fromInt x = Word64.fromLargeInt (IntInf.toLarge x);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun toInt x = IntInf.fromLarge (Word64.toLargeInt x);&quot;  ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun fromLarge x = Word64.fromLarge x;&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun toLarge x = Word64.toLarge x;&quot;  ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun plus x y = Word64.+(x, y);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun minus x y = Word64.-(x, y);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun negate x = Word64.~(x);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun times x y = Word64.*(x, y);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun divide x y = Word64.div(x, y);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun modulus x y = Word64.mod(x, y);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun less_eq x y = Word64.&lt;=(x, y);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun less x y = Word64.&lt;(x, y);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun set_bit x n b =&quot; ^ newline ^
    &quot;  let val mask = Word64.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))&quot; ^ newline ^
    &quot;  in if b then Word64.orb (x, mask)&quot; ^ newline ^
    &quot;     else Word64.andb (x, Word64.notb mask)&quot; ^ newline ^
    &quot;  end&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun shiftl x n =&quot; ^ newline ^
    &quot;  Word64.&lt;&lt; (x, Word.fromLargeInt (IntInf.toLarge n))&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun shiftr x n =&quot; ^ newline ^
    &quot;  Word64.&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun shiftr_signed x n =&quot; ^ newline ^
    &quot;  Word64.~&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun test_bit x n =&quot; ^ newline ^
    &quot;  Word64.andb (x, Word64.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))) &lt;&gt; Word64.fromInt 0&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;val notb = Word64.notb&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun andb x y = Word64.andb(x, y);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun orb x y = Word64.orb(x, y);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;fun xorb x y = Word64.xorb(x, y);&quot; ^ newline ^
    &quot;&quot; ^ newline ^
    &quot;end (*struct Uint64*)&quot;
  val target_SML64 = &quot;SML_word&quot;;
in
  (if use_Word64 then Code_Target.set_printings (Code_Symbol.Module (&quot;Uint64&quot;, [(Code_Runtime.target, SOME (content, []))])) else I)
  #&gt; Code_Target.set_printings (Code_Symbol.Module (&quot;Uint64&quot;, [(target_SML64, SOME (content, []))]))
end
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span>Uint64</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span>
</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;module Uint64(Int64, Word64) where

  import Data.Int(Int64)
  import Data.Word(Word64)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">code_reserved</span></span><span> </span><span>Haskell</span><span> </span><span>Uint64</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  OCaml and Scala provide only signed 64bit numbers, so we use these and 
  implement sign-sensitive operations like comparisons manually.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;module Uint64 : sig
  val less : int64 -&gt; int64 -&gt; bool
  val less_eq : int64 -&gt; int64 -&gt; bool
  val set_bit : int64 -&gt; Z.t -&gt; bool -&gt; int64
  val shiftl : int64 -&gt; Z.t -&gt; int64
  val shiftr : int64 -&gt; Z.t -&gt; int64
  val shiftr_signed : int64 -&gt; Z.t -&gt; int64
  val test_bit : int64 -&gt; Z.t -&gt; bool
end = struct

(* negative numbers have their highest bit set, 
   so they are greater than positive ones *)
let less x y =
  if Int64.compare x Int64.zero &lt; 0 then
    Int64.compare y Int64.zero &lt; 0 &amp;&amp; Int64.compare x y &lt; 0
  else Int64.compare y Int64.zero &lt; 0 || Int64.compare x y &lt; 0;;

let less_eq x y =
  if Int64.compare x Int64.zero &lt; 0 then
    Int64.compare y Int64.zero &lt; 0 &amp;&amp; Int64.compare x y &lt;= 0
  else Int64.compare y Int64.zero &lt; 0 || Int64.compare x y &lt;= 0;;

let set_bit x n b =
  let mask = Int64.shift_left Int64.one (Z.to_int n)
  in if b then Int64.logor x mask
     else Int64.logand x (Int64.lognot mask);;

let shiftl x n = Int64.shift_left x (Z.to_int n);;

let shiftr x n = Int64.shift_right_logical x (Z.to_int n);;

let shiftr_signed x n = Int64.shift_right x (Z.to_int n);;

let test_bit x n =
  Int64.compare 
    (Int64.logand x (Int64.shift_left Int64.one (Z.to_int n)))
    Int64.zero
  &lt;&gt; 0;;

end;; (*struct Uint64*)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">code_reserved</span></span><span> </span><span>OCaml</span><span> </span><span>Uint64</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span>Uint64</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;object Uint64 {

def less(x: Long, y: Long) : Boolean =
  if (x &lt; 0) y &lt; 0 &amp;&amp; x &lt; y
  else y &lt; 0 || x &lt; y

def less_eq(x: Long, y: Long) : Boolean =
  if (x &lt; 0) y &lt; 0 &amp;&amp; x &lt;= y
  else y &lt; 0 || x &lt;= y

def set_bit(x: Long, n: BigInt, b: Boolean) : Long =
  if (b)
    x | (1L &lt;&lt; n.intValue)
  else
    x &amp; (1L &lt;&lt; n.intValue).unary_~

def shiftl(x: Long, n: BigInt) : Long = x &lt;&lt; n.intValue

def shiftr(x: Long, n: BigInt) : Long = x &gt;&gt;&gt; n.intValue

def shiftr_signed(x: Long, n: BigInt) : Long = x &gt;&gt; n.intValue

def test_bit(x: Long, n: BigInt) : Boolean =
  (x &amp; (1L &lt;&lt; n.intValue)) != 0

} /* object Uint64 */&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">code_reserved</span></span><span> </span><span>Scala</span><span> </span><span>Uint64</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  OCaml&#39;s conversion from Big\_int to int64 demands that the value fits int a signed 64-bit integer.
  The following justifies the implementation.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Uint64_signed</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;integer &#8658; uint64&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64_signed i = (if i &lt; -(0x8000000000000000) &#8744; i &#8805; 0x8000000000000000 then undefined Uint64 i else Uint64 i)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64 i = 
  (let i&#39; = i AND 0xFFFFFFFFFFFFFFFF
   in if i&#39; !! 63 then Uint64_signed (i&#39; - 0x10000000000000000) else Uint64_signed i&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span>integer.lifting</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Uint64_signed_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>rule</span><span> </span><span>word_of_int_via_signed</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bin_mask_numeral</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Uint64_signed_code</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Rep_uint64 (Uint64_signed i) = 
  (if i &lt; -(0x8000000000000000) &#8744; i &#8805; 0x8000000000000000 then Rep_uint64 (undefined Uint64 i) else word_of_int (int_of_integer_symbolic i))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Uint64_signed_def</span><span> </span><span>Uint64_def</span><span> </span><span>int_of_integer_symbolic_def</span><span> </span><span>word_of_integer_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_uint64_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Avoid @{term Abs_uint64} in generated code, use @{term Rep_uint64&#39;} instead. 
  The symbolic implementations for code\_simp use @{term Rep_uint64}.

  The new destructor @{term Rep_uint64&#39;} is executable.
  As the simplifier is given the [code abstract] equations literally, 
  we cannot implement @{term Rep_uint64} directly, because that makes code\_simp loop.

  If code generation raises Match, some equation probably contains @{term Rep_uint64} 
  ([code abstract] equations for @{typ uint64} may use @{term Rep_uint64} because
  these instances will be folded away.)

  To convert @{typ &quot;64 word&quot;} values into @{typ uint64}, use @{term &quot;Abs_uint64&#39;&quot;}.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Rep_uint64&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Rep_uint64&#39; = Rep_uint64&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rep_uint64&#39;_transfer</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;rel_fun cr_uint64 (=) (&#955;x. x) Rep_uint64&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Rep_uint64&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>uint64.rep_transfer</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rep_uint64&#39;_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Rep_uint64&#39; x = (BITS n. x !! n)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Abs_uint64&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;64 word &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;x :: 64 word. x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Abs_uint64&#39;_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Abs_uint64&#39; x = Uint64 (integer_of_int (uint x))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>integer.lifting</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>code</span><span> </span><span>drop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;term_of_class.term_of :: uint64 &#8658; _&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>term_of_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;TR &#8801; typerep.Typerep&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bit0 &#8801; STR &#39;&#39;Numeral_Type.bit0&#39;&#39;&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;term_of_class.term_of x = 
   Code_Evaluation.App (Code_Evaluation.Const (STR &#39;&#39;Uint64.uint64.Abs_uint64&#39;&#39;) (TR (STR &#39;&#39;fun&#39;&#39;) [TR (STR &#39;&#39;Word.word&#39;&#39;) [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR bit0 [TR (STR &#39;&#39;Numeral_Type.num1&#39;&#39;) []]]]]]]], TR (STR &#39;&#39;Uint64.uint64&#39;&#39;) []]))
       (term_of_class.term_of (Rep_uint64&#39; x))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>term_of_anything</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">type_constructor</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.Word64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Long&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>Uint64</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.fromInt&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Prelude.fromInteger _ :: Uint64.Word64)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell_Quickcheck</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Prelude.fromInteger (Prelude.toInteger _) :: Uint64.Word64)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_.longValue&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>Uint64_signed</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Z.to&#39;_int64&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 :: uint64&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.zero&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(0 :: Uint64.Word64)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.zero&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1 :: uint64&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.one&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(1 :: Uint64.Word64)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.one&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;plus :: uint64 &#8658; _ &quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.plus&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>6</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;+&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.add&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>7</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;+&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uminus :: uint64 &#8658; _&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.negate&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;negate&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.neg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;!(- _)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;minus :: uint64 &#8658; _&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.minus&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>6</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;-&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.sub&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>7</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;-&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;times :: uint64 &#8658; _ &#8658; _&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.times&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>7</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;*&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.mul&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>8</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;*&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL.equal :: uint64 &#8658; _ &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;!((_ : Uint64.uint64) = _)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span>4</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;==&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Int64.compare _ _ = 0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>5</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;==&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">class_instance</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">::</span><span> </span><span>equal</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span>-</span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;less_eq :: uint64 &#8658; _ &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.less&#39;_eq&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span>4</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&lt;=&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.less&#39;_eq&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.less&#39;_eq&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;less :: uint64 &#8658; _ &#8658; bool&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.less&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span>4</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&lt;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.less&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.less&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bitNOT :: uint64 &#8658; _&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.notb&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Data&#39;_Bits.complement&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.lognot&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_.unary&#39;_~&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bitAND :: uint64 &#8658; _&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.andb&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>7</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Data_Bits..&amp;.&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.logand&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>3</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&amp;&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bitOR :: uint64 &#8658; _&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.orb&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>5</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Data_Bits..|.&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.logor&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>1</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;|&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bitXOR :: uint64 &#8658; _&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.xorb&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Data&#39;_Bits.xor&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.logxor&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span>2</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;^&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_divmod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64 &#215; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_divmod x y = 
  (if y = 0 then (undefined ((div) :: uint64 &#8658; _) x (0 :: uint64), undefined ((mod) :: uint64 &#8658; _) x (0 :: uint64)) 
  else (x div y, x mod y))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_div</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_div x y = fst (uint64_divmod x y)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_mod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_mod x y = snd (uint64_divmod x y)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x div y = (if y = 0 then 0 else uint64_div x y)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_divmod_def</span><span> </span><span>uint64_div_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_div_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mod_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x mod y = (if y = 0 then x else uint64_mod x y)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_mod_def</span><span> </span><span>uint64_divmod_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_mod_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_sdiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64 &#8658; uint64&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_sdiv x y =
   (if y = 0 then undefined ((div) :: uint64 &#8658; _) x (0 :: uint64)
    else Abs_uint64 (Rep_uint64 x sdiv Rep_uint64 y))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>div0_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;div0_uint64 x = undefined ((div) :: uint64 &#8658; _) x (0 :: uint64)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>code</span><span> </span><span>abort</span><span class="delimiter">:</span><span> </span><span>div0_uint64</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mod0_uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; uint64&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mod0_uint64 x = undefined ((mod) :: uint64 &#8658; _) x (0 :: uint64)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>code</span><span> </span><span>abort</span><span class="delimiter">:</span><span> </span><span>mod0_uint64</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_divmod_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_divmod x y =
  (if 0x8000000000000000 &#8804; y then if x &lt; y then (0, x) else (1, x - y)
   else if y = 0 then (div0_uint64 x, mod0_uint64 x)
   else let q = (uint64_sdiv (x &gt;&gt; 1) y) &lt;&lt; 1;
            r = x - q * y
        in if r &#8805; y then (q + 1, r - y) else (q, r))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_divmod_def</span><span> </span><span>uint64_sdiv_def</span><span> </span><span>div0_uint64_def</span><span> </span><span>mod0_uint64_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>divmod_via_sdivmod</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_sdiv_code</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Rep_uint64 (uint64_sdiv x y) =
   (if y = 0 then Rep_uint64 (undefined ((div) :: uint64 &#8658; _) x (0 :: uint64))
    else Rep_uint64 x sdiv Rep_uint64 y)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_sdiv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_uint64_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Note that we only need a translation for signed division, but not for the remainder
  because @{thm uint64_divmod_code} computes both with division only.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>uint64_div</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.divide&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Prelude.div&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>uint64_mod</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.modulus&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Prelude.mod&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>uint64_divmod</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;divmod&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>uint64_sdiv</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Int64.div&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ &#39;/ _&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_test_bit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; integer &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_test_bit x n =
  (if n &lt; 0 &#8744; 63 &lt; n then undefined (test_bit :: uint64 &#8658; _) x n
   else x !! (nat_of_integer n))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>test_bit_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;test_bit x n &#10231; n &lt; 64 &#8743; uint64_test_bit x (integer_of_nat n)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span>integer.lifting</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_test_bit_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>auto</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>test_bit_size</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_test_bit_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_test_bit w n =
  (if n &lt; 0 &#8744; 63 &lt; n then undefined (test_bit :: uint64 &#8658; _) w n else Rep_uint64 w !! nat_of_integer n)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_test_bit_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>test_bit_uint64.rep_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>uint64_test_bit</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.test&#39;_bit&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Data&#39;_Bits.testBitBounded&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.test&#39;_bit&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.test&#39;_bit&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Eval</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">&quot;(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 64 then raise (Fail \&quot;argument to uint64&#39;_test&#39;_bit out of bounds\&quot;) else Uint64.test&#39;_bit x i)&quot;</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_set_bit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; integer &#8658; bool &#8658; uint64&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_set_bit x n b =
  (if n &lt; 0 &#8744; 63 &lt; n then undefined (set_bit :: uint64 &#8658; _) x n b
   else set_bit x (nat_of_integer n) b)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_bit_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;set_bit x n b = (if n &lt; 64 then uint64_set_bit x (integer_of_nat n) b else x)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span>integer.lifting</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_set_bit_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_less</span><span> </span><span>set_bit_beyond</span><span> </span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_set_bit_code</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Rep_uint64 (uint64_set_bit w n b) = 
  (if n &lt; 0 &#8744; 63 &lt; n then Rep_uint64 (undefined (set_bit :: uint64 &#8658; _) w n b)
   else set_bit (Rep_uint64 w) (nat_of_integer n) b)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_set_bit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>uint64_set_bit</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.set&#39;_bit&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Data&#39;_Bits.setBitBounded&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.set&#39;_bit&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.set&#39;_bit&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Eval</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">&quot;(fn x =&gt; fn i =&gt; fn b =&gt; if i &lt; 0 orelse i &gt;= 64 then raise (Fail \&quot;argument to uint64&#39;_set&#39;_bit out of bounds\&quot;) else Uint64.set&#39;_bit x i b)&quot;</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>uint64_set_bits</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat &#8658; bool) &#8658; uint64 &#8658; nat &#8658; uint64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>set_bits_aux</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_set_bits_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_set_bits f w n =
  (if n = 0 then w 
   else let n&#39; = n - 1 in uint64_set_bits f ((w &lt;&lt; 1) OR (if f n&#39; then 1 else 0)) n&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>n</span><span class="delimiter">)</span><span class="delimiter">(</span><span>cases</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_bits_uint64</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(BITS n. f n) = uint64_set_bits f 0 64&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>set_bits_conv_set_bits_aux</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lsb_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span>uint64</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lsb x = x !! 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_lsb_def</span><span> </span><span>word_test_bit_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_shiftl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; integer &#8658; uint64&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_shiftl x n = (if n &lt; 0 &#8744; 64 &#8804; n then undefined (shiftl :: uint64 &#8658; _) x n else x &lt;&lt; (nat_of_integer n))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shiftl_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &lt;&lt; n = (if n &lt; 64 then uint64_shiftl x (integer_of_nat n) else 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span>integer.lifting</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_shiftl_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_less</span><span> </span><span>shiftl_zero_size</span><span> </span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_shiftl_code</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Rep_uint64 (uint64_shiftl w n) =
  (if n &lt; 0 &#8744; 64 &#8804; n then Rep_uint64 (undefined (shiftl :: uint64 &#8658; _) w n) else Rep_uint64 w &lt;&lt; (nat_of_integer n))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_shiftl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>uint64_shiftl</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.shiftl&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Data&#39;_Bits.shiftlBounded&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.shiftl&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.shiftl&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Eval</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">&quot;(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 64 then raise (Fail \&quot;argument to uint64&#39;_shiftl out of bounds\&quot;) else Uint64.shiftl x i)&quot;</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_shiftr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; integer &#8658; uint64&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_shiftr x n = (if n &lt; 0 &#8744; 64 &#8804; n then undefined (shiftr :: uint64 &#8658; _) x n else x &gt;&gt; (nat_of_integer n))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shiftr_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &gt;&gt; n = (if n &lt; 64 then uint64_shiftr x (integer_of_nat n) else 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span>integer.lifting</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_shiftr_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_less</span><span> </span><span>shiftr_zero_size</span><span> </span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_shiftr_code</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Rep_uint64 (uint64_shiftr w n) =
  (if n &lt; 0 &#8744; 64 &#8804; n then Rep_uint64 (undefined (shiftr :: uint64 &#8658; _) w n) else Rep_uint64 w &gt;&gt; nat_of_integer n)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_shiftr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>uint64_shiftr</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.shiftr&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Data&#39;_Bits.shiftrBounded&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.shiftr&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.shiftr&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Eval</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">&quot;(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 64 then raise (Fail \&quot;argument to uint64&#39;_shiftr out of bounds\&quot;) else Uint64.shiftr x i)&quot;</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_sshiftr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; integer &#8658; uint64&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_sshiftr x n =
  (if n &lt; 0 &#8744; 64 &#8804; n then undefined sshiftr_uint64 x n else sshiftr_uint64 x (nat_of_integer n))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sshiftr_beyond</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a :: len word&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;size x &#8804; n &#10233; x &gt;&gt;&gt; n = (if x !! (size x - 1) then -1 else 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>word_eqI</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_sshiftr</span><span> </span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sshiftr_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &gt;&gt;&gt; n = 
  (if n &lt; 64 then uint64_sshiftr x (integer_of_nat n) else if x !! 63 then -1 else 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span>integer.lifting</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_sshiftr_def</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_less</span><span> </span><span>sshiftr_beyond</span><span> </span><span>word_size</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_sshiftr_code</span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Rep_uint64 (uint64_sshiftr w n) =
  (if n &lt; 0 &#8744; 64 &#8804; n then Rep_uint64 (undefined sshiftr_uint64 w n) else Rep_uint64 w &gt;&gt;&gt; (nat_of_integer n))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint64_sshiftr_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>uint64_sshiftr</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.shiftr&#39;_signed&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(Prelude.fromInteger (Prelude.toInteger (Data&#39;_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint64.Int64) _)) :: Uint64.Word64)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.shiftr&#39;_signed&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.shiftr&#39;_signed&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Eval</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">&quot;(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 64 then raise (Fail \&quot;argument to uint64&#39;_shiftr&#39;_signed out of bounds\&quot;) else Uint64.shiftr&#39;_signed x i)&quot;</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_msb_test_bit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;msb x &#10231; (x :: uint64) !! 63&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>msb_nth</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>msb_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;msb x &#10231; uint64_test_bit x 63&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>uint64_test_bit_def</span><span> </span><span>uint64_msb_test_bit</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_of_int_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_of_int i = Uint64 (integer_of_int i)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>integer.lifting</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>int_of_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;int_of_uint64 x = int_of_integer (integer_of_uint64 x)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>integer_of_uint64_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_of_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;nat_of_uint64 x = nat_of_integer (integer_of_uint64 x)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>integer_of_uint64_def</span><span> </span><span class="keyword1"><span class="command">including</span></span><span> </span><span>integer.lifting</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>unat_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>integer_of_uint64_signed</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64 &#8658; integer&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;integer_of_uint64_signed n = (if n !! 63 then undefined integer_of_uint64 n else integer_of_uint64 n)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>integer_of_uint64_signed_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;integer_of_uint64_signed n =
  (if n !! 63 then undefined integer_of_uint64 n else integer_of_int (uint (Rep_uint64&#39; n)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>integer_of_uint64_signed_def</span><span> </span><span>integer_of_uint64_def</span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>integer_of_uint64_code</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;integer_of_uint64 n =
  (if n !! 63 then integer_of_uint64_signed (n AND 0x7FFFFFFFFFFFFFFF) OR 0x8000000000000000 else integer_of_uint64_signed n)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>integer_of_uint64_def</span><span> </span><span>integer_of_uint64_signed_def</span><span> </span><span>o_def</span><span>
</span><span class="keyword1"><span class="command">including</span></span><span> </span><span>undefined_transfer</span><span> </span><span>integer.lifting</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>word_ao_nth</span><span> </span><span>uint_and_mask_or_full</span><span> </span><span>mask_numeral</span><span> </span><span>mask_Suc_0</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>uint_and_mask_or_full</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;integer_of_uint64&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Uint64.toInt&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Prelude.toInteger&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;integer_of_uint64_signed&quot;</span></span></span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>  </span><span class="delimiter">(</span><span>OCaml</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Z.of&#39;_int64&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="delimiter">(</span><span>Scala</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;BigInt&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Quickcheck setup&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>uint64_of_natural</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;natural &#8658; uint64&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;uint64_of_natural x &#8801; Uint64 (integer_of_natural x)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{random, exhaustive, full_exhaustive}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;random_uint64 &#8801; qc_random_cnv uint64_of_natural&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;exhaustive_uint64 &#8801; qc_exhaustive_cnv uint64_of_natural&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;full_exhaustive_uint64 &#8801; qc_full_exhaustive_cnv uint64_of_natural&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>uint64</span><span> </span><span class="delimiter">::</span><span> </span><span>narrowing</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>quickcheck_narrowing_samples</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;i. let x = Uint64 i in (x, 0xFFFFFFFFFFFFFFFF - x)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Typerep.Typerep (STR &#39;&#39;Uint64.uint64&#39;&#39;) []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;narrowing_uint64 d = qc_narrowing_drawn_from (narrowing_samples d) d&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>code</span><span> </span><span>drop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partial_term_of :: uint64 itself &#8658; _&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>partial_term_of_uint64</span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>partial_term_of_code</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>sshiftr_uint64</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&gt;&gt;&gt;&quot;</span></span></span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">5222ffd4 </td><td align="center">Fri 06 Dec 2019 02:43:15 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


