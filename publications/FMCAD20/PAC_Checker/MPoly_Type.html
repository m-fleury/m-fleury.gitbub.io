<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory MPoly_Type (repository version)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory MPoly_Type</h1>

<span class="command">theory</span> <span class="name">MPoly_Type</span><br/>
<span class="keyword">imports</span> <a href="Poly_Mapping.html"><span class="name">Poly_Mapping</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, ETH Zurich
   Author: Florian Haftmann, TU Muenchen
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;An abstract type for multivariate polynomials&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>MPoly_Type</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Library.Poly_Mapping&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Abstract type definition&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="delimiter">)</span><span> </span><span class="tfree">&#39;a</span><span> </span><span>mpoly</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;UNIV :: ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a::zero) set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">morphisms</span></span><span> </span><span>mapping_of</span><span> </span><span>MPoly</span><span>
</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>type_definition_mpoly</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* these theorems are automatically generated by setup_lifting... *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>mapping_of_inverse</span><span>   </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>MPoly_inverse</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>mapping_of_inject</span><span>    </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>MPoly_inject</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>mapping_of_induct</span><span>    </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>MPoly_induct</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>mapping_of_cases</span><span>     </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>MPoly_cases</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Additive structure&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>zero</span><span class="delimiter">)</span><span> </span><span>zero</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zero_mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a mpoly&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0 :: (nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>monoid_add</span><span class="delimiter">)</span><span> </span><span>monoid_add</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>plus_mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a mpoly &#8658; &#39;a mpoly &#8658; &#39;a mpoly&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Groups.plus :: ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a) &#8658; _&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_monoid_add</span><span class="delimiter">)</span><span> </span><span>comm_monoid_add</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>cancel_comm_monoid_add</span><span class="delimiter">)</span><span> </span><span>cancel_comm_monoid_add</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>minus_mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a mpoly &#8658; &#39;a mpoly &#8658; &#39;a mpoly&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Groups.minus :: ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a) &#8658; _&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>diff_diff_add</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ab_group_add</span><span class="delimiter">)</span><span> </span><span>ab_group_add</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>uminus_mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a mpoly &#8658; &#39;a mpoly&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Groups.uminus :: ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a) &#8658; _&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>add_uminus_conv_diff</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiplication by a coefficient&#8250;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ?do we need inc_power on abstract polynomials? *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>smult</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{times,zero} &#8658; &#39;a mpoly &#8658; &#39;a mpoly&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a. Poly_Mapping.map (Groups.times a) :: ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a) &#8658; _&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* left lemmas in subsection &#8249;Pseudo-division of polynomials&#8250;,
   because I couldn&#39;t disentangle them and the notion of monomials. *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiplicative structure&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>zero_neq_one</span><span class="delimiter">)</span><span> </span><span>zero_neq_one</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>one_mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a mpoly&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1 :: ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_0</span><span class="delimiter">)</span><span> </span><span>semiring_0</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>times_mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a mpoly &#8658; &#39;a mpoly &#8658; &#39;a mpoly&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Groups.times :: ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a) &#8658; _&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_semiring_0</span><span class="delimiter">)</span><span> </span><span>comm_semiring_0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_0_cancel</span><span class="delimiter">)</span><span> </span><span>semiring_0_cancel</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_semiring_0_cancel</span><span class="delimiter">)</span><span> </span><span>comm_semiring_0_cancel</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_1</span><span class="delimiter">)</span><span> </span><span>semiring_1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_semiring_1</span><span class="delimiter">)</span><span> </span><span>comm_semiring_1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_1_cancel</span><span class="delimiter">)</span><span> </span><span>semiring_1_cancel</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*instance mpoly :: (comm_semiring_1_cancel) comm_semiring_1_cancel
  .. FIXME unclear whether this holds *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ring</span><span class="delimiter">)</span><span> </span><span>ring</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_ring</span><span class="delimiter">)</span><span> </span><span>comm_ring</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ring_1</span><span class="delimiter">)</span><span> </span><span>ring_1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>comm_ring_1</span><span class="delimiter">)</span><span> </span><span>comm_ring_1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Monomials&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Terminology is not unique here, so we use the notions as follows:
  A &quot;monomial&quot; and a &quot;coefficient&quot; together give a &quot;term&quot;.
  These notions are significant in connection with &quot;leading&quot;,
  &quot;leading term&quot;, &quot;leading coefficient&quot; and &quot;leading monomial&quot;,
  which all rely on a monomial order.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>monom</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658; &#39;a::zero &#8658; &#39;a mpoly&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Poly_Mapping.single :: (nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658; _&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapping_of_monom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mapping_of (monom m a) = Poly_Mapping.single m a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>monom.rep_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monom_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;monom 0 0 = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monom_one</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;monom 0 1 = 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monom_add</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;monom m (a + b) = monom m a + monom m b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>single_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monom_uminus</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;monom m (- a) = - monom m a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>single_uminus</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monom_diff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;monom m (a - b) = monom m a - monom m b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>single_diff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monom_numeral</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;monom 0 (numeral n) = numeral n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>numeral.simps</span><span> </span><span>numeral_add</span><span> </span><span>monom_zero</span><span> </span><span>monom_one</span><span> </span><span>monom_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monom_of_nat</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;monom 0 (of_nat n) = of_nat n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monom_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_nat_monom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;of_nat = monom 0 &#8728; of_nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inj_monom</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;inj (monom m)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>injI</span><span class="delimiter">,</span><span> </span><span>transfer</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Poly_Mapping.single m a = Poly_Mapping.single m b&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>injD</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Poly_Mapping.single m&quot;</span></span></span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a = b&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_monom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;monom x a * monom y b = monom (x + y) (a * b)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer&#39;</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Poly_Mapping.mult_single</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>semiring_char_0</span><span class="delimiter">)</span><span> </span><span>semiring_char_0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>of_nat_monom</span><span> </span><span>inj_of_nat</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>inj_compose</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ring_char_0</span><span class="delimiter">)</span><span> </span><span>ring_char_0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>monom_of_int</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;monom 0 (of_int k) = of_int k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>monom_diff</span><span> </span><span>monom_uminus</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Constants and Indeterminates&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Embedding of indeterminates and constants in type-class polynomials,
  can be used as constructors.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Var<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a &#8658; (&#39;a &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;b::{one,zero}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Var<span class="hidden">&#8681;</span><sub>0</sub> n &#8801; Poly_Mapping.single (Poly_Mapping.single n 1) 1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Const<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b &#8658; (&#39;a &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;b::zero&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Const<span class="hidden">&#8681;</span><sub>0</sub> c &#8801; Poly_Mapping.single 0 c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Const<span class="hidden">&#8681;</span><sub>0</sub>_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Const<span class="hidden">&#8681;</span><sub>0</sub> 1 = 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Const<span class="hidden">&#8681;</span><sub>0</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Const<span class="hidden">&#8681;</span><sub>0</sub>_numeral</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Const<span class="hidden">&#8681;</span><sub>0</sub> (numeral x) = numeral x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_mapping_eqI</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Const<span class="hidden">&#8681;</span><sub>0</sub>_def</span><span> </span><span>lookup_numeral</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Const<span class="hidden">&#8681;</span><sub>0</sub>_minus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Const<span class="hidden">&#8681;</span><sub>0</sub> (- x) = - Const<span class="hidden">&#8681;</span><sub>0</sub> x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Const<span class="hidden">&#8681;</span><sub>0</sub>_def</span><span> </span><span>single_uminus</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Const<span class="hidden">&#8681;</span><sub>0</sub>_zero</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Const<span class="hidden">&#8681;</span><sub>0</sub> 0 = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>poly_mapping_eqI</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Const<span class="hidden">&#8681;</span><sub>0</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Var<span class="hidden">&#8681;</span><sub>0</sub>_power</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Var<span class="hidden">&#8681;</span><sub>0</sub> v ^ n = Poly_Mapping.single (Poly_Mapping.single v n) 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Var<span class="hidden">&#8681;</span><sub>0</sub>_def</span><span> </span><span>mult_single</span><span> </span><span>single_add</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Var</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; &#39;b::{one,zero} mpoly&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>Var<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>Const</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;&#39;b::zero &#8658; &#39;b mpoly&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>Const<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Integral domains&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ring_no_zero_divisors</span><span class="delimiter">)</span><span> </span><span>ring_no_zero_divisors</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>intro_classes</span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ring_1_no_zero_divisors</span><span class="delimiter">)</span><span> </span><span>ring_1_no_zero_divisors</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>mpoly</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>idom</span><span class="delimiter">)</span><span> </span><span>idom</span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Monom coefficient lookup&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>coeff</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::zero mpoly &#8658; (nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658; &#39;a&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;coeff p = Poly_Mapping.lookup (mapping_of p)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Insertion morphism&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>insertion_fun_natural</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat &#8658; &#39;a) &#8658; ((nat &#8658; nat) &#8658; &#39;a) &#8658; &#39;a::comm_semiring_1&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insertion_fun_natural f p = (&#8721;m. p m * (&#8719;v. f v ^ m v))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>insertion_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat &#8658; &#39;a) &#8658; ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658; &#39;a) &#8658; &#39;a::comm_semiring_1&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insertion_fun f p = (&#8721;m. p m * (&#8719;v. f v ^ Poly_Mapping.lookup m v))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N.b. have been unable to relate this to @{const insertion_fun_natural} using lifting!&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>insertion_aux</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat &#8658; &#39;a) &#8658; ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a) &#8658; &#39;a::comm_semiring_1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insertion_fun&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>insertion</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat &#8658; &#39;a) &#8658; &#39;a mpoly &#8658; &#39;a::comm_semiring_1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insertion_aux&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Poly_Mapping.lookup f = (&#955;_. 0) &#10231; f = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>transfer</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertion_trivial</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insertion (&#955;_. 0) p = coeff p 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insertion_aux (&#955;_. 0) f = Poly_Mapping.lookup f 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insertion_aux_def</span><span> </span><span>insertion_fun_def</span><span> </span><span>power_Sum_any</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zero_power_eq</span><span> </span><span>mult_when</span><span> </span><span>aux</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>coeff_def</span><span> </span><span>insertion_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertion_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insertion f 0 = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insertion_aux_def</span><span> </span><span>insertion_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertion_fun_add</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span>p</span><span> </span><span>q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insertion_fun f (Poly_Mapping.lookup (p + q)) =
    insertion_fun f (Poly_Mapping.lookup p) +
      insertion_fun f (Poly_Mapping.lookup q)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>insertion_fun_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sum_any.distrib</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>plus_poly_mapping.rep_eq</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_mult_not_eq_zero_rightI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_mult_not_eq_zero_rightI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertion_add</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insertion f (p + q) = insertion f p + insertion f q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insertion_aux_def</span><span> </span><span>insertion_fun_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertion_one</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insertion f 1 = 1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insertion_aux_def</span><span> </span><span>insertion_fun_def</span><span> </span><span>one_poly_mapping.rep_eq</span><span> </span><span>when_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertion_fun_mult</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span>p</span><span> </span><span>q</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insertion_fun f (Poly_Mapping.lookup (p * q)) =
    insertion_fun f (Poly_Mapping.lookup p) *
      insertion_fun f (Poly_Mapping.lookup q)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {v. Poly_Mapping.lookup m v &#8800; 0}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {v. f v ^ Poly_Mapping.lookup m v &#8800; 1}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rev_finite_subset</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g m = (&#8719;v. f v ^ Poly_Mapping.lookup m v)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a b. g (a + b) = g a * g b&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>plus_poly_mapping.rep_eq</span><span> </span><span>power_add</span><span> </span><span>Prod_any.distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bij</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij (&#955;(l, n, m). (m, l, n))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>bijI</span><span> </span><span>injI</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{l. Poly_Mapping.lookup p l &#8800; 0}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Q</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{n. Poly_Mapping.lookup q n &#8800; 0}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?PQ</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{l + n | l n. l &#8712; Poly_Mapping.keys p &#8743; n &#8712; Poly_Mapping.keys q}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite {l + n | l n. Poly_Mapping.lookup p l &#8800; 0 &#8743; Poly_Mapping.lookup q n &#8800; 0}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>finite_not_eq_zero_sumI</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin_PQ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite ?PQ&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_keys_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8721;m. Poly_Mapping.lookup (p * q) m * g m) =
    (&#8721;m. (&#8721;l. Poly_Mapping.lookup p l * (&#8721;n. Poly_Mapping.lookup q n when m = l + n)) * g m)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>times_poly_mapping.rep_eq</span><span> </span><span>prod_fun_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (&#8721;m. (&#8721;l. (&#8721;n. g m * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n) when m = l + n)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sum_any_left_distrib</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_mult_not_eq_zero_rightI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sum_any_right_distrib</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_mult_not_eq_zero_rightI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sum_any_left_distrib</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_mult_not_eq_zero_leftI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span> </span><span>mult_when</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (&#8721;m. (&#8721;(l, n). g m * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n) when m = l + n))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Sum_any.cartesian_product</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?P &#215; ?Q&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mult_not_zero</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (&#8721;(m, l, n). g m * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n) when m = l + n)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sum_any.cartesian_product</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?PQ &#215; (?P &#215; ?Q)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mult_not_zero</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fin_PQ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_keys_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (&#8721;(l, n, m). g m * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n) when m = l + n)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bij</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Sum_any.reindex_cong</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;(l, n, m). (m, l, n)&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (&#8721;(l, n). &#8721;m. g m * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n) when m = l + n)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sum_any.cartesian_product2</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(?P &#215; ?Q) &#215; ?PQ&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mult_not_zero</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fin_PQ</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_keys_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (&#8721;(l, n). (g l * g n) * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>*</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (&#8721;l. &#8721;n. (g l * g n) * (Poly_Mapping.lookup p l * Poly_Mapping.lookup q n))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Sum_any.cartesian_product</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?P &#215; ?Q&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mult_not_zero</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = (&#8721;l. &#8721;n. (Poly_Mapping.lookup p l * g l) * (Poly_Mapping.lookup q n * g n))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; =
    (&#8721;m. Poly_Mapping.lookup p m * g m) *
    (&#8721;m. Poly_Mapping.lookup q m * g m)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Sum_any_product</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_mult_not_eq_zero_rightI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insertion_fun_def</span><span> </span><span>g_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insertion_mult</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;insertion f (p * q) = insertion f p * insertion f q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insertion_aux_def</span><span> </span><span>insertion_fun_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Degree&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>degree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::zero mpoly &#8658; nat &#8658; nat&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;p v. Max (insert 0 ((&#955;m. Poly_Mapping.lookup m v) ` Poly_Mapping.keys p))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>total_degree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::zero mpoly &#8658; nat&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;p. Max (insert 0 ((&#955;m. sum (Poly_Mapping.lookup m) (Poly_Mapping.keys m)) ` Poly_Mapping.keys p))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>degree_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;degree 0 v = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>total_degree_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;total_degree 0 = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
value [code] &quot;total_degree (0 :: int mpoly)&quot; (***)
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>degree_one</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;degree 1 v = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>total_degree_one</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;total_degree 1 = 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pseudo-division of polynomials&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>smult_conv_mult</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smult s p = monom 0 s * p&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mult_map_scale_conv_mult</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>smult_monom</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ :: mult_zero&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smult c (monom x c&#39;) = monom x (c * c&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>smult_0</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ :: mult_zero mpoly&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smult 0 p = 0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_eq_zero_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mult_smult_left</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;smult s p * q = smult s (p * q)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>smult_conv_mult</span><span> </span><span>mult.assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>sdiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::euclidean_ring &#8658; &#39;a mpoly &#8658; &#39;a mpoly&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;a. Poly_Mapping.map (&#955;b. b div a) :: ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a) &#8658; _&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  \qt{Polynomial division} is only possible on univariate polynomials &#8249;K[x]&#8250;
  over a field &#8249;K&#8250;, all other kinds of polynomials only allow pseudo-division
  [1]p.40/41&quot;:

  &#8249;&#8704;x y :: &#39;a mpoly. y &#8800; 0 &#8658; &#8707;a q r. smult a x = q * y + r&#8250;

  The introduction of pseudo-division below generalises @{file &#8249;~~/src/HOL/Computational_Algebra/Polynomial.thy&#8250;}.
  [1] Winkler, Polynomial Algorithms, 1996.
  The generalisation raises issues addressed by Wenda Li and commented below.
  Florian replied to the issues conjecturing, that the abstract mpoly needs not
  be aware of the issues, in case these are only concerned with executability.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pseudo_divmod_rel</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::euclidean_ring =&gt; &#39;a mpoly =&gt; &#39;a mpoly =&gt; &#39;a mpoly =&gt; &#39;a mpoly =&gt; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pseudo_divmod_rel a x y q r &#10231;
    smult a x = q * y + r &#8743; (if y = 0 then q = 0 else r = 0 &#8744; degree r &lt; degree y)&quot;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the notion of degree resigns a main variable in multivariate polynomials;
   also, there are infinitely many tuples (a,q,r) such that a x = q y + r *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pdiv</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::euclidean_ring mpoly &#8658; &#39;a mpoly &#8658; (&#39;a &#215; &#39;a mpoly)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pdiv&quot;</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x pdiv y = (THE (a, q). &#8707;r. pseudo_divmod_rel a x y q r)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pmod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::euclidean_ring mpoly &#8658; &#39;a mpoly &#8658; &#39;a mpoly&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pmod&quot;</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x pmod y = (THE r. &#8707;a q. pseudo_divmod_rel a x y q r)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>pdivmod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::euclidean_ring mpoly &#8658; &#39;a mpoly &#8658; (&#39;a &#215; &#39;a mpoly) &#215; &#39;a mpoly&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pdivmod p q = (p pdiv q, p pmod q)&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* &quot;_code&quot; seems inappropriate, since &quot;THE&quot; in definitions pdiv and pmod is not unique,
   see comment to definition pseudo_divmod_rel; so this cannot be executable ... *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pdiv_code</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;p pdiv q = fst (pdivmod p q)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pdivmod_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pmod_code</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;p pmod q = snd (pdivmod p q)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pdivmod_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*TODO ERROR: Ambiguous input produces n parse trees ???...*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>div</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{euclidean_ring,field} mpoly &#8658; &#39;a mpoly &#8658; &#39;a mpoly&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;div&quot;</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x div y = (THE q&#39;. &#8707;a q r. (pseudo_divmod_rel a x y q r) &#8743; (q&#39; = smult (inverse a) q))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{euclidean_ring,field} mpoly &#8658; &#39;a mpoly &#8658; &#39;a mpoly&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mod&quot;</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x mod y = (THE r&#39;. &#8707;a q r. (pseudo_divmod_rel a x y q r) &#8743; (r&#39; = smult (inverse a) r))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>divmod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{euclidean_ring,field} mpoly &#8658; &#39;a mpoly &#8658; &#39;a mpoly &#215; &#39;a mpoly&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;divmod p q = (p div q, p mod q)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_poly_code</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;p div q = fst (divmod p q)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>divmod_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mod_poly_code</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;p mod q = snd (divmod p q)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>divmod_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Primitive poly, etc&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>coeffs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a :: zero mpoly &#8658; &#39;a set&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Poly_Mapping.range :: ((nat &#8658;<span class="hidden">&#8681;</span><sub>0</sub> nat) &#8658;<span class="hidden">&#8681;</span><sub>0</sub> &#39;a) &#8658; _&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_coeffs</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (coeffs p)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[1]p.82
  A &quot;primitive&#39;&quot; polynomial has coefficients with GCD equal to 1.
  A polynomial is factored into &quot;content&quot; and &quot;primitive part&quot;
  for many different purposes.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>primitive</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{euclidean_ring,semiring_Gcd} mpoly &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;primitive p &#10231; Gcd (coeffs p) = 1&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>content_primitive</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::{euclidean_ring,GCD.Gcd} mpoly &#8658; &#39;a &#215; &#39;a mpoly&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;content_primitive p = (
    let d = Gcd (coeffs p)
    in (d, sdiv d p))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;let p = M [1,2,3] (4::int) + M [2,0,4] 6 + M [2,0,5] 8
  in content_primitive p&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
