<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Ramsey (repository version)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Ramsey</h1>

<span class="command">theory</span> <span class="name">Ramsey</span><br/>
<span class="keyword">imports</span> <a href="../../AFP/Automatic_Refinement/Infinite_Set.html"><span class="name">Infinite_Set</span></a> <a href="FuncSet.html"><span class="name">FuncSet</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      HOL/Library/Ramsey.thy
    Author:     Tom Ridge. Full finite version by L C Paulson.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Ramsey&#39;s Theorem&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Ramsey</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Infinite_Set</span><span> </span><span>FuncSet</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Preliminary definitions&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The $n$-element subsets of a set $A$&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nsets</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#39;a set, nat] &#8658; &#39;a set set&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;([_]<span class="hidden">&#8663;</span><sup>_<span class="hidden">&#8662;</span></sup>)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>999</span><span class="delimiter">]</span><span> </span><span>999</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets A n &#8801; {N. N &#8838; A &#8743; finite N &#8743; card N = n}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8838; B &#10233; nsets A n &#8838; nsets B n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_2_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets A 2 = (&#8899;x&#8712;A. &#8899;y&#8712;A - {x}. {{x, y}})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>card_2_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_doubleton_2_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[{x, y}]<span class="hidden">&#8663;</span><sup>2<span class="hidden">&#8662;</span></sup> = (if x=y then {} else {{x, y}})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_2_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>doubleton_in_nsets_2</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{x,y} &#8712; [A]<span class="hidden">&#8663;</span><sup>2<span class="hidden">&#8662;</span></sup> &#10231; x &#8712; A &#8743; y &#8712; A &#8743; x &#8800; y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_2_eq</span><span> </span><span>Set.doubleton_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_3_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets A 3 = (&#8899;x&#8712;A. &#8899;y&#8712;A - {x}. &#8899;z&#8712;A - {x,y}. {{x,y,z}})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eval_nat_numeral</span><span> </span><span>nsets_def</span><span> </span><span>card_Suc_eq</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_4_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[A]<span class="hidden">&#8663;</span><sup>4<span class="hidden">&#8662;</span></sup> = (&#8899;u&#8712;A. &#8899;x&#8712;A - {u}. &#8899;y&#8712;A - {u,x}. &#8899;z&#8712;A - {u,x,y}. {{u,x,y,z}})&quot;</span></span></span><span>
</span><span>     </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ = ?rhs&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[A]<span class="hidden">&#8663;</span><sup>4<span class="hidden">&#8662;</span></sup> &#8838; ?rhs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>eval_nat_numeral</span><span> </span><span>card_Suc_eq</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?rhs &#8838; [A]<span class="hidden">&#8663;</span><sup>4<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>eval_nat_numeral</span><span> </span><span>card_Suc_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_iff</span><span> </span><span>singletonD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_disjoint_2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8745; Y = {} &#10233; [X &#8746; Y]<span class="hidden">&#8663;</span><sup>2<span class="hidden">&#8662;</span></sup> = [X]<span class="hidden">&#8663;</span><sup>2<span class="hidden">&#8662;</span></sup> &#8746; [Y]<span class="hidden">&#8663;</span><sup>2<span class="hidden">&#8662;</span></sup> &#8746; (&#8899;x&#8712;X. &#8899;y&#8712;Y. {{x,y}})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_2_eq</span><span> </span><span>Set.doubleton_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_nsets_2_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::linorder set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets A 2 = {{x,y} | x y. x &#8712; A &#8743; y &#8712; A &#8743; x&lt;y}&quot;</span></span></span><span>
</span><span>     </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ = ?rhs&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets A 2 &#8838; ?rhs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>numeral_nat</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>card_Suc_eq</span><span> </span><span>Set.doubleton_eq_iff</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?rhs &#8838; nsets A 2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>numeral_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>card_Suc_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_nsets_3_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::linorder set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets A 3 = {{x,y,z} | x y z. x &#8712; A &#8743; y &#8712; A &#8743; z &#8712; A &#8743; x&lt;y &#8743; y&lt;z}&quot;</span></span></span><span>
</span><span>     </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ = ?rhs&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets A 3 &#8838; ?rhs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>card_Suc_eq</span><span> </span><span>eval_nat_numeral</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_commute</span><span> </span><span>linorder_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?rhs &#8838; nsets A 3&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>card_Suc_eq</span><span> </span><span>eval_nat_numeral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>empty_iff</span><span> </span><span>insert_iff</span><span> </span><span>not_less_iff_gr_or_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_nsets_4_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::linorder set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[A]<span class="hidden">&#8663;</span><sup>4<span class="hidden">&#8662;</span></sup> = {U. &#8707;u x y z. U = {u,x,y,z} &#8743; u &#8712; A &#8743; x &#8712; A &#8743; y &#8712; A &#8743; z &#8712; A &#8743; u &lt; x &#8743; x &lt; y &#8743; y &lt; z}&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ = Collect ?RHS&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8712; [A]<span class="hidden">&#8663;</span><sup>4<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strict_sorted l&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;List.set l = U&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length l = 4&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8838; A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_set_strict_sorted</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?RHS U&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>numeral_nat</span><span> </span><span>length_Suc_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Collect ?RHS &#8838; [A]<span class="hidden">&#8663;</span><sup>4<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>eval_nat_numeral</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>card_insert_disjoint</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ordered_nsets_5_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a::linorder set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[A]<span class="hidden">&#8663;</span><sup>5<span class="hidden">&#8662;</span></sup> = {U. &#8707;u v x y z. U = {u,v,x,y,z} &#8743; u &#8712; A &#8743; v &#8712; A &#8743; x &#8712; A &#8743; y &#8712; A &#8743; z &#8712; A &#8743; u &lt; v &#8743; v &lt; x &#8743; x &lt; y &#8743; y &lt; z}&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;_ = Collect ?RHS&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>U</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8712; [A]<span class="hidden">&#8663;</span><sup>5<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strict_sorted l&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;List.set l = U&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length l = 5&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8838; A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_set_strict_sorted</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?RHS U&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>numeral_nat</span><span> </span><span>length_Suc_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Collect ?RHS &#8838; [A]<span class="hidden">&#8663;</span><sup>5<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>eval_nat_numeral</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>card_insert_disjoint</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>binomial_eq_nsets</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n choose k = card (nsets {0..&lt;n} k)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>binomial_def</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>subset_eq_atLeast0_lessThan_finite</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_eq_empty_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets A r = {} &#10231; finite A &#8743; card A &lt; r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nsets_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>iffI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>that</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{N. N &#8838; A &#8743; finite N &#8743; card N = r} = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>infinite_arbitrarily_large</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; r &#8804; card A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>set_eq_iff</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>obtain_subset_with_card_n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card A &lt; r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{N. N &#8838; A &#8743; finite N &#8743; card N = r} = {}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite A &#8743; card A &lt; r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>card_mono</span><span> </span><span>leD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_eq_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;finite A; card A &lt; r&#10215; &#10233; nsets A r = {}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_eq_empty_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_empty_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets {} r = (if r=0 then {{}} else {})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_singleton_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets {a} r = (if r=0 then {{}} else if r=1 then {{a}} else {})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>card_gt_0_iff</span><span> </span><span>subset_singleton_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_self</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets {..&lt;m} m = {{..&lt;m}}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nsets_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.left_neutral</span><span> </span><span>lessThan_atLeast0</span><span> </span><span>lessThan_iff</span><span> </span><span>subset_card_intvl_is_intvl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets A 0 = {{}}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets A (Suc 0) = (&#955;x. {x}) ` A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_eq_SucD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inj_on_nsets</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj_on f A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj_on (&#955;X. f ` X) ([A]<span class="hidden">&#8663;</span><sup>n<span class="hidden">&#8662;</span></sup>)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nsets_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>inj_on_inverseI</span><span> </span><span>inv_into_image_cancel</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bij_betw_nsets</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw f A B&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw (&#955;X. f ` X) ([A]<span class="hidden">&#8663;</span><sup>n<span class="hidden">&#8662;</span></sup>) ([B]<span class="hidden">&#8663;</span><sup>n<span class="hidden">&#8662;</span></sup>)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(`) f ` [A]<span class="hidden">&#8663;</span><sup>n<span class="hidden">&#8662;</span></sup> = [f ` A]<span class="hidden">&#8663;</span><sup>n<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>bij_betw_def</span><span> </span><span>image_iff</span><span> </span><span>card_image</span><span> </span><span>inj_on_subset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_image</span><span> </span><span>inj_on_finite</span><span> </span><span>order_refl</span><span> </span><span>subset_image_inj</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>bij_betw_def</span><span> </span><span>inj_on_nsets</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nset_image_obtains</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; [f`A]<span class="hidden">&#8663;</span><sup>k<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj_on f A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>Y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Y &#8712; [A]<span class="hidden">&#8663;</span><sup>k<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X = f ` Y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>subset_image_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_image</span><span> </span><span>finite_imageD</span><span> </span><span>inj_on_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_image_funcset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g &#8712; S &#8594; T&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj_on g S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;X. g ` X) &#8712; [S]<span class="hidden">&#8663;</span><sup>k<span class="hidden">&#8662;</span></sup> &#8594; [T]<span class="hidden">&#8663;</span><sup>k<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>card_image</span><span> </span><span>inj_on_subset</span><span> </span><span>subset_iff</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>image_subset_iff_funcset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsets_compose_image_funcset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f &#8712; [T]<span class="hidden">&#8663;</span><sup>k<span class="hidden">&#8662;</span></sup> &#8594; D&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g &#8712; S &#8594; T&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj_on g S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f &#8728; (&#955;X. g ` X) &#8712; [S]<span class="hidden">&#8663;</span><sup>k<span class="hidden">&#8662;</span></sup> &#8594; D&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;X. g ` X) &#8712; [S]<span class="hidden">&#8663;</span><sup>k<span class="hidden">&#8662;</span></sup> &#8594; [T]<span class="hidden">&#8663;</span><sup>k<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_image_funcset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Partition predicates&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>partn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set &#8658; nat &#8658; nat &#8658; &#39;b set &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn &#946; &#945; &#947; &#948; &#8801; &#8704;f &#8712; nsets &#946; &#947;  &#8594;  &#948;. &#8707;H &#8712; nsets &#946; &#945;. &#8707;&#958;&#8712;&#948;. f ` (nsets H &#947;) &#8838; {&#958;}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>partn_lst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set &#8658; nat list &#8658; nat &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst &#946; &#945; &#947; &#8801; &#8704;f &#8712; nsets &#946; &#947;  &#8594;  {..&lt;length &#945;}.
              &#8707;i &lt; length &#945;. &#8707;H &#8712; nsets &#946; (&#945;!i). f ` (nsets H &#947;) &#8838; {i}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>partn_lst_greater_resource</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>M</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;M} &#945; &#947;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M &#8804; N&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;N} &#945; &#947;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f &#8712; nsets {..&lt;N} &#947; &#8594; {..&lt;length &#945;}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f &#8712; nsets {..&lt;M} &#947; &#8594; {..&lt;length &#945;}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Pi_anti_mono</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8804; N&#8250;</span></span></span><span> </span><span>lessThan_subset_iff</span><span> </span><span>nsets_mono</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span>H</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; length &#945;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8712; nsets {..&lt;M} (&#945; ! i)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f ` nsets H &#947; &#8838; {i}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M</span><span> </span><span>partn_lst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8712; nsets {..&lt;N} (&#945; ! i)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8804; N&#8250;</span></span></span><span> </span><span>H</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>subset_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;i&lt;length &#945;. &#8707;H&#8712;nsets {..&lt;N} (&#945; ! i). f ` nsets H &#947; &#8838; {i}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>subi</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>partn_lst_fewer_colours</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>major</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst &#946; (n#&#945;) &#947;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8805; &#947;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst &#946; &#945; &#947;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f &#8712; [&#946;]<span class="hidden">&#8663;</span><sup>&#947;<span class="hidden">&#8662;</span></sup> &#8594; {..&lt;length &#945;}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span>H</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; Suc (length &#945;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8712; [&#946;]<span class="hidden">&#8663;</span><sup>((n # &#945;) ! i)<span class="hidden">&#8662;</span></sup>&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x&#8712;[H]<span class="hidden">&#8663;</span><sup>&#947;<span class="hidden">&#8662;</span></sup>. Suc (f x) = i&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8805; &#947;&#8250;</span></span></span><span> </span><span>major</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>partn_lst_def</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc o f&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_subset_iff</span><span> </span><span>nsets_eq_empty_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;i&lt;length &#945;. &#8707;H&#8712;nsets &#946; (&#945; ! i). f ` [H]<span class="hidden">&#8663;</span><sup>&#947;<span class="hidden">&#8662;</span></sup> &#8838; {i}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[H]<span class="hidden">&#8663;</span><sup>&#947;<span class="hidden">&#8662;</span></sup> = {}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>H</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8805; &#947;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_eq_empty_iff</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>H</span><span> </span><span>hom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>partn_lst_eq_partn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;n} [m,m] 2 = partn {..&lt;n} m 2 {..&lt;2::nat}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span> </span><span>partn_def</span><span> </span><span>numeral_2_eq_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_2_cases</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>lessThan_iff</span><span> </span><span>nth_Cons_0</span><span> </span><span>nth_Cons_Suc</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Finite versions of Ramsey&#39;s theorem&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  To distinguish the finite and infinite ones, lower and upper case
  names are used.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Trivial cases&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Vacuous, since we are dealing with 0-sets!&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ramsey0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;N::nat. partn_lst {..&lt;N} [q1,q2] 0&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span> </span><span>ex_in_conv</span><span> </span><span>less_Suc_eq</span><span> </span><span>nsets_eq_empty_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Just the pigeon hole principle, since we are dealing with 1-sets&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ramsey1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;N::nat. partn_lst {..&lt;N} [q0,q1] 1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;i&lt;Suc (Suc 0). &#8707;H&#8712;nsets {..&lt;Suc (q0 + q1)} ([q0, q1] ! i). f ` nsets H (Suc 0) &#8838; {i}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f &#8712; nsets {..&lt;Suc (q0 + q1)} (Suc 0) &#8594; {..&lt;Suc (Suc 0)}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8801; &#955;i. {q. q &#8804; q0+q1 &#8743; f {q} = i}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A 0 &#8746; A 1 = {..q0 + q1}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>A_def</span><span> </span><span>PiE_iff</span><span> </span><span>nsets_one</span><span> </span><span>lessThan_Suc_atMost</span><span> </span><span>le_Suc_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A 0 &#8745; A 1 = {}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>A_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q0 + q1 &#8804; card (A 0) + card (A 1)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_Un_le</span><span> </span><span>card_atMost</span><span> </span><span>eq_imp_le</span><span> </span><span>le_SucI</span><span> </span><span>le_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (A 0) &#8805; q0&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (A 1) &#8805; q1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; Suc (Suc 0)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (A i) &#8805; [q0, q1] ! i&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>lessI</span><span> </span><span>nth_Cons_0</span><span> </span><span>nth_Cons_Suc</span><span> </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B &#8838; A i&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card B = [q0, q1] ! i&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite B&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>obtain_subset_with_card_n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B &#8712; nsets {..&lt;Suc (q0 + q1)} ([q0, q1] ! i) &#8743; f ` nsets B (Suc 0) &#8838; {i}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>A_def</span><span> </span><span>nsets_def</span><span> </span><span>card_1_singleton_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; Suc (Suc 0)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Ramsey&#39;s theorem with two colours and arbitrary exponents (hypergraph version)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">proposition</span></span><span> </span><span>ramsey2_full</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;N::nat. partn_lst {..&lt;N} [q1,q2] r&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q1</span><span> </span><span>q2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ramsey0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>outer</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r = 0&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ramsey1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r &gt; 0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.prems</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span> </span><span class="delimiter">&#8801;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q1 + q2&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>q1</span><span> </span><span>q2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;1::nat} [q1, q2] (Suc r)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nsets_empty_iff</span><span> </span><span>subset_insert</span><span> </span><span>0</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span> </span><span>funcset_to_empty_iff</span><span> </span><span>nsets_eq_empty</span><span> </span><span>image_subset_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q1 = 0 &#8744; q2 = 0&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q1 &#8800; 0&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q2 &#8800; 0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt; Suc 0} [q1, q2] (Suc r)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>partn_lst_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;r &gt; 0&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_empty_iff</span><span> </span><span>nsets_singleton_iff</span><span> </span><span>lessThan_Suc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k = (q1 - 1) + q2&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k = q1 + (q2 - 1)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>p1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;p1} [q1-1,q2] (Suc r)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;p2} [q1,q2-1] (Suc r)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;p} [p1,p2] r&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>outer</span><span> </span><span>Suc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;i&lt;Suc (Suc 0). &#8707;H&#8712;nsets {..p} ([q1,q2] ! i). f ` nsets H (Suc r) &#8838; {i}&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f &#8712; nsets {..p} (Suc r) &#8594; {..&lt;Suc (Suc 0)}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>            </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g &#8801; &#955;R. f (insert p R)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f (insert p i) &#8712; {..&lt;Suc (Suc 0)}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &#8712; nsets {..&lt;p} r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>card_insert_if</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Pi_mem</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>f</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g &#8712; nsets {..&lt;p} r &#8594; {..&lt;Suc (Suc 0)}&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_def</span><span> </span><span>PiE_iff</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; Suc (Suc 0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g ` nsets U r &#8838; {i}&quot;</span></span></span><span>
</span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8712; nsets {..&lt;p} ([p1, p2] ! i)&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Usub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8838; {..&lt;p}&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>izero</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i = 0&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>ione</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i = Suc 0&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>izero</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8712; nsets {..&lt;p} p1&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw u {..&lt;p1} U&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_bij_betw_nat_finite</span><span> </span><span>lessThan_atLeast0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_nsets</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` X &#8712; nsets {..p} n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; nsets {..&lt;p1} n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span> </span><span>n</span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj_on u X&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span>that</span><span> </span><span>bij_betw_imp_inj_on</span><span> </span><span>inj_on_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Usub</span><span> </span><span>u</span><span> </span><span>that</span><span> </span><span>bij_betwE</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>card_image</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8801; &#955;R. f (u ` R)&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8712; nsets {..&lt;p1} (Suc r) &#8594; {..&lt;Suc (Suc 0)}&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span>u_nsets</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &lt;Suc (Suc 0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h ` nsets V (Suc r) &#8838; {j}&quot;</span></span></span><span>
</span><span>                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V &#8712; nsets {..&lt;p1} ([q1 - Suc 0, q2] ! j)&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Vsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V &#8838; {..&lt;p1}&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invinv_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` inv_into {..&lt;p1} u ` X = X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8838; u ` {..&lt;p1}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_inv_into_cancel</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?W</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert p (u ` V)&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>jzero</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j = 0&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>jone</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j = Suc 0&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>                </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>jzero</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V &#8712; nsets {..&lt;p1} (q1 - Suc 0)&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` V &#8712; nsets {..&lt;p} (q1 - Suc 0)&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_nsets</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q1 - Suc 0&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>nsets_mono</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Vsub</span><span class="delimiter">]</span><span> </span><span>Usub</span><span> </span><span>u</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_betw_def</span><span> </span><span>nsets_def</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?W &#8712; nsets {..p} q1&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nsets_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;q1 &#8800; 0&#8250;</span></span></span><span> </span><span>card_insert_if</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invu_nsets</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_into {..&lt;p1} u ` X &#8712; nsets V r&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; nsets (u ` V) r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span> </span><span>r</span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8838; u ` V &#8743; finite X &#8743; card X = r&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nsets_def</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (inv_into {..&lt;p1} u ` X) = card X&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Vsub</span><span> </span><span>bij_betw_def</span><span> </span><span>bij_betw_inv_into</span><span> </span><span>card_image</span><span> </span><span>image_mono</span><span> </span><span>inj_on_subset</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>u</span><span> </span><span>Vsub</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>bij_betw_def</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f X = i&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; nsets ?W (Suc r)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8712; X&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Xp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X - {p} &#8712; nsets (u ` V) r&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` V &#8838; U&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vsub</span><span> </span><span>bij_betwE</span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X - {p} &#8712; nsets U r&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>in_mono</span><span> </span><span>nsets_mono</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g (X - {p}) = i&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gi</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f X = i&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gi</span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;X - {p} &#8712; nsets U r&#8250;</span></span></span><span> </span><span>insert_Diff</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>g_def</span><span> </span><span>image_subset_iff</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f X = i&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;g (X - {p}) = i&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Xim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; nsets (u ` V) (Suc r)&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>subset_insert</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` inv_into {..&lt;p1} u ` X = X&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vsub</span><span> </span><span>bij_betw_imp_inj_on</span><span> </span><span>u</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>image_mono</span><span> </span><span>invinv_eq</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>izero</span><span> </span><span>jzero</span><span> </span><span>hj</span><span> </span><span>Xim</span><span> </span><span>invu_nsets</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_subset_iff</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert p (u ` V) &#8712; nsets {..p} q1&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>izero</span><span> </span><span>inq1</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>izero</span><span> </span><span>image_subsetI</span><span> </span><span>insertI1</span><span> </span><span>nth_Cons_0</span><span> </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>jone</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` V &#8712; nsets {..p} q2&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span>u_nsets</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f ` nsets (u ` V) (Suc r) &#8838; {j}&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hj</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>h_def</span><span> </span><span>image_subset_iff</span><span> </span><span>nsets_def</span><span> </span><span>subset_image_inj</span><span> </span><span>card_image</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>finite_imageD</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>jone</span><span> </span><span>not_less_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ione</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8712; nsets {..&lt;p} p2&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw u {..&lt;p2} U&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_bij_betw_nat_finite</span><span> </span><span>lessThan_atLeast0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_nsets</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` X &#8712; nsets {..p} n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; nsets {..&lt;p2} n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span> </span><span>n</span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj_on u X&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span>that</span><span> </span><span>bij_betw_imp_inj_on</span><span> </span><span>inj_on_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Usub</span><span> </span><span>u</span><span> </span><span>that</span><span> </span><span>bij_betwE</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>card_image</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8801; &#955;R. f (u ` R)&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8712; nsets {..&lt;p2} (Suc r) &#8594; {..&lt;Suc (Suc 0)}&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span>u_nsets</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &lt;Suc (Suc 0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h ` nsets V (Suc r) &#8838; {j}&quot;</span></span></span><span>
</span><span>                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V &#8712; nsets {..&lt;p2} ([q1, q2 - Suc 0] ! j)&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Vsub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V &#8838; {..&lt;p2}&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invinv_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` inv_into {..&lt;p2} u ` X = X&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8838; u ` {..&lt;p2}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_inv_into_cancel</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?W</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert p (u ` V)&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>jzero</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j = 0&quot;</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>jone</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j = Suc 0&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>                </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>jone</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V &#8712; nsets {..&lt;p2} (q2 - Suc 0)&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` V &#8712; nsets {..&lt;p} (q2 - Suc 0)&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u_nsets</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;q2 - Suc 0&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>nsets_mono</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Vsub</span><span class="delimiter">]</span><span> </span><span>Usub</span><span> </span><span>u</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bij_betw_def</span><span> </span><span>nsets_def</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?W &#8712; nsets {..p} q2&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nsets_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;q2 &#8800; 0&#8250;</span></span></span><span> </span><span>card_insert_if</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invu_nsets</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_into {..&lt;p2} u ` X &#8712; nsets V r&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; nsets (u ` V) r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span> </span><span>r</span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8838; u ` V &#8743; finite X &#8743; card X = r&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nsets_def</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (inv_into {..&lt;p2} u ` X) = card X&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Vsub</span><span> </span><span>bij_betw_def</span><span> </span><span>bij_betw_inv_into</span><span> </span><span>card_image</span><span> </span><span>image_mono</span><span> </span><span>inj_on_subset</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>u</span><span> </span><span>Vsub</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>bij_betw_def</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f X = i&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; nsets ?W (Suc r)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>                </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8712; X&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Xp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X - {p} &#8712; nsets (u ` V) r&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` V &#8838; U&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vsub</span><span> </span><span>bij_betwE</span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X - {p} &#8712; nsets U r&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>in_mono</span><span> </span><span>nsets_mono</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g (X - {p}) = i&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gi</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f X = i&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gi</span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;X - {p} &#8712; nsets U r&#8250;</span></span></span><span> </span><span>insert_Diff</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>g_def</span><span> </span><span>image_subset_iff</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f X = i&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;g (X - {p}) = i&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Xim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; nsets (u ` V) (Suc r)&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>X</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>subset_insert</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` inv_into {..&lt;p2} u ` X = X&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Vsub</span><span> </span><span>bij_betw_imp_inj_on</span><span> </span><span>u</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>image_mono</span><span> </span><span>invinv_eq</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ione</span><span> </span><span>jone</span><span> </span><span>hj</span><span> </span><span>Xim</span><span> </span><span>invu_nsets</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_subset_iff</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert p (u ` V) &#8712; nsets {..p} q2&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ione</span><span> </span><span>inq1</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ione</span><span> </span><span>image_subsetI</span><span> </span><span>insertI1</span><span> </span><span>lessI</span><span> </span><span>nth_Cons_0</span><span> </span><span>nth_Cons_Suc</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>jzero</span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` V &#8712; nsets {..p} q1&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span>u_nsets</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f ` nsets (u ` V) (Suc r) &#8838; {j}&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hj</span><span>
</span><span>                  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>h_def</span><span> </span><span>image_subset_iff</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Zero_not_Suc</span><span> </span><span>card_eq_0_iff</span><span> </span><span>card_image</span><span> </span><span>subset_image_inj</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>jzero</span><span> </span><span>not_less_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;Suc p} [q1,q2] (Suc r)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lessThan_Suc</span><span> </span><span>lessThan_Suc_atMost</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Full Ramsey&#39;s theorem with multiple colours and arbitrary exponents&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ramsey_full</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;N::nat. partn_lst {..&lt;N} qs r&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span> </span><span class="delimiter">&#8801;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length qs&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>qs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = [q]&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_0_conv</span><span> </span><span>length_Suc_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>q</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span> </span><span>funcset_to_empty_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q1</span><span> </span><span>q2</span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>qs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;qs = q1#q2#l&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>length_Suc_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;q} [q1,q2] r&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ramsey2_full</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span class="delimiter">::</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;p} (q#l) r&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;qs = q1 # q2 # l&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>keq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc (length l) = k&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>qs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;p} qs r&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f &#8712; nsets {..&lt;p} r &#8594; {..&lt;length qs}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g &#8801; &#955;X. if f X &lt; Suc (Suc 0) then 0 else f X - Suc 0&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g &#8712; nsets {..&lt;p} r &#8594; {..&lt;k}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span>Suc</span><span> </span><span>IH</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Pi_def</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; k&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g ` nsets U r &#8838; {i}&quot;</span></span></span><span>
</span><span>                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8712; nsets {..&lt;p} ((q#l) ! i)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span> </span><span>keq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;i&lt;length qs. &#8707;H&#8712;nsets {..&lt;p} (qs ! i). f ` nsets H r &#8838; {i}&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i = 0&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8712; nsets {..&lt;p} q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f01</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f ` nsets U r &#8838; {0, Suc 0}&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span>gi</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_subset_iff</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bij_betw u {..&lt;q} U&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_bij_betw_nat_finite</span><span> </span><span>lessThan_atLeast0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Usub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8838; {..&lt;p}&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U &#8712; nsets {..&lt;p} q&#8250;</span></span></span><span> </span><span>mem_Collect_eq</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>u_nsets</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` X &#8712; nsets {..&lt;p} n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; nsets {..&lt;q} n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span> </span><span>n</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj_on u X&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span>that</span><span> </span><span>bij_betw_imp_inj_on</span><span> </span><span>inj_on_subset</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Usub</span><span> </span><span>u</span><span> </span><span>that</span><span> </span><span>bij_betwE</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>card_image</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8801; &#955;X. f (u ` X)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f (u ` X) &lt; Suc (Suc 0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; nsets {..&lt;q} r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;u ` X &#8712; nsets U r&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>u</span><span> </span><span>u_nsets</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>bij_betwE</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f01</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8712; nsets {..&lt;q} r &#8594; {..&lt;Suc (Suc 0)}&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span>V</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; Suc (Suc 0)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>hj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h ` nsets V r &#8838; {j}&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;V &#8712; nsets {..&lt;q} ([q1,q2] ! j)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>bexI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; length qs&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nsets (u ` V) r &#8838; (&#955;x. (u ` x)) ` nsets V r&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsets_def</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_eq_0_iff</span><span> </span><span>card_image</span><span> </span><span>image_is_empty</span><span> </span><span>subset_image_inj</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f ` nsets (u ` V) r &#8838; h ` nsets V r&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>h_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f ` nsets (u ` V) r &#8838; {j}&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(u ` V) &#8712; nsets {..&lt;p} (qs ! j)&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V</span><span> </span><span>j</span><span> </span><span>less_2_cases</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>qs</span><span> </span><span>u_nsets</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>conjI</span><span> </span><span>bexI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc i &lt; length qs&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f ` nsets U r &#8838; {Suc i}&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span>gi</span><span> </span><span>False</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_def</span><span> </span><span>image_subset_iff</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_lessD</span><span> </span><span>Suc_pred</span><span> </span><span>g_def</span><span> </span><span>gi</span><span> </span><span>image_subset_iff</span><span> </span><span>not_less_eq</span><span> </span><span>singleton_iff</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8712; nsets {..&lt;p} (qs ! (Suc i))&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>U</span><span> </span><span>qs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Simple graph version&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This is the most basic version in terms of cliques and independent
  sets, i.e. the version for graphs and 2 colours.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clique V E &#10231; (&#8704;v&#8712;V. &#8704;w&#8712;V. v &#8800; w &#10230; {v, w} &#8712; E)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;indep V E &#10231; (&#8704;v&#8712;V. &#8704;w&#8712;V. v &#8800; w &#10230; {v, w} &#8713; E)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ramsey2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;r&#8805;1. &#8704;(V::&#39;a set) (E::&#39;a set set). finite V &#8743; card V &#8805; r &#10230;
    (&#8707;R &#8838; V. card R = m &#8743; clique R E &#8744; card R = n &#8743; indep R E)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N &#8805; Suc 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;partn_lst {..&lt;N} [m,n] 2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ramsey2_full</span><span> </span><span>nat_le_linear</span><span> </span><span>partn_lst_greater_resource</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;R&#8838;V. card R = m &#8743; clique R E &#8744; card R = n &#8743; indep R E&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite V&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;N &#8804; card V&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>V</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set set&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>u</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj_on v {..&lt;N}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v ` {..&lt;N} &#8838; V&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>card_le_inj</span><span> </span><span>card_lessThan</span><span> </span><span>finite_lessThan</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f &#8801; &#955;e. if v ` e &#8712; E then 0 else Suc 0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f &#8712; nsets {..&lt;N} 2 &#8594; {..&lt;Suc (Suc 0)}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>f_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; 2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>gi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f ` nsets U 2 &#8838; {i}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;U &#8712; nsets {..&lt;N} ([m,n] ! i)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N</span><span> </span><span>numeral_2_eq_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>partn_lst_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;v ` U &#8838; V&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span>u</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_subset_iff</span><span> </span><span>nsets_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (v ` U) = m &#8743; clique (v ` U) E &#8744; card (v ` U) = n &#8743; indep (v ` U) E&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>numeral_2_eq_2</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gi</span><span> </span><span>U</span><span> </span><span>u</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_subset_iff</span><span> </span><span>nsets_2_eq</span><span> </span><span>clique_def</span><span> </span><span>indep_def</span><span> </span><span>less_Suc_eq</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f_def</span><span> </span><span>nsets_def</span><span> </span><span>card_image</span><span> </span><span>inj_on_subset</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc 0 &#8804; N&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Preliminaries&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;``Axiom&#39;&#39; of Dependent Choice&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>choice</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; (&#39;a &#215; &#39;a) set &#8658; nat &#8658; &#39;a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="comment">&#8213; &#8249;An integer-indexed chain of choices&#8250;</span><span>
</span><span>    </span><span>choice_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;choice P r 0 = (SOME x. P x)&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>choice_Suc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;choice P r (Suc n) = (SOME y. P y &#8743; (choice P r n, y) &#8712; r)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>choice_n</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P x0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pstep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. P x &#10233; &#8707;y. P y &#8743; (x, y) &#8712; r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P (choice P r n)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>someI</span><span> </span><span>P0</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>someI2_ex</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Pstep</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dependent_choice</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trans r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P x0&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Pstep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. P x &#10233; &#8707;y. P y &#8743; (x, y) &#8712; r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; &#39;a&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;n. P (f n)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;n m. n &lt; m &#10233; (f n, f m) &#8712; r&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P (choice P r n)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>choice_n</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>P0</span><span> </span><span>Pstep</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; m&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Pstep</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>choice_n</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>P0</span><span> </span><span>Pstep</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(choice P r k, choice P r (Suc k)) &#8712; r&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>someI2_ex</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(choice P r n, choice P r m) &#8712; r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>less_Suc_induct</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &lt; m&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>transD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Partition functions&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>part_fn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat &#8658; &#39;a set &#8658; (&#39;a set &#8658; nat) &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;the function \&lt;^term&gt;&#8249;f&#8250; partitions the \&lt;^term&gt;&#8249;r&#8250;-subsets of the typically
      infinite set \&lt;^term&gt;&#8249;Y&#8250; into \&lt;^term&gt;&#8249;s&#8250; distinct categories.&#8250;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;part_fn r s Y f &#10231; (f &#8712; nsets Y r &#8594; {..&lt;s})&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;For induction, we decrease the value of \&lt;^term&gt;&#8249;r&#8250; in partitions.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_fn_Suc_imp_part_fn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;infinite Y; part_fn (Suc r) s Y f; y &#8712; Y&#10215; &#10233; part_fn r s (Y - {y}) (&#955;u. f (insert y u))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>part_fn_def</span><span> </span><span>nsets_def</span><span> </span><span>Pi_def</span><span> </span><span>subset_Diff_insert</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>part_fn_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;part_fn r s YY f &#10233; Y &#8838; YY &#10233; part_fn r s Y f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>part_fn_def</span><span> </span><span>nsets_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Ramsey&#39;s Theorem: Infinitary Version&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Ramsey_induction</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span>r</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>YY</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite YY&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;part_fn r s YY f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;Y&#39; t&#39;. Y&#39; &#8838; YY &#8743; infinite Y&#39; &#8743; t&#39; &lt; s &#8743; (&#8704;X. X &#8838; Y&#39; &#8743; finite X &#8743; card X = r &#10230; f X = t&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>r</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>YY</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>part_fn_def</span><span> </span><span>card_eq_0_iff</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc.prems</span><span> </span><span>infinite_imp_nonempty</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>yy</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>yy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;yy &#8712; YY&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ramr</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{((y, Y, t), (y&#39;, Y&#39;, t&#39;)). y&#39; &#8712; Y &#8743; Y&#39; &#8838; Y}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?propr</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;(y, Y, t).
                 y &#8712; YY &#8743; y &#8713; Y &#8743; Y &#8838; YY &#8743; infinite Y &#8743; t &lt; s
                 &#8743; (&#8704;X. X&#8838;Y &#8743; finite X &#8743; card X = r &#10230; (f &#8728; insert y) X = t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>infYY&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite (YY - {yy})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>partf&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;part_fn r s (YY - {yy}) (f &#8728; insert yy)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>part_fn_Suc_imp_part_fn</span><span> </span><span>yy</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>transr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trans ?ramr&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trans_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc.hyps</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>infYY&#39;</span><span> </span><span>partf&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Y0</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Y0 &#8838; YY - {yy}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite Y0&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t0 &lt; s&quot;</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8838; Y0 &#8743; finite X &#8743; card X = r &#10230; (f &#8728; insert yy) X = t0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>yy</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propr0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?propr(yy, Y0, t0)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>proprstep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;y. ?propr y &#8743; (x, y) &#8712; ?ramr&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?propr x&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>fields</span><span> </span><span>yx</span><span> </span><span>Yx</span><span> </span><span>tx</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>yx&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>yx&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;yx&#39; &#8712; Yx&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>infinite_imp_nonempty</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fields</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>infYx&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite (Yx - {yx&#39;})&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fields</span><span> </span><span>x</span><span> </span><span>yx&#39;</span><span> </span><span>Suc.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>partfx&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;part_fn r s (Yx - {yx&#39;}) (f &#8728; insert yx&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>o_def</span><span> </span><span>part_fn_Suc_imp_part_fn</span><span> </span><span>part_fn_subset</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>YY</span><span class="delimiter">=</span><span>YY</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Y</span><span class="delimiter">=</span><span>Yx</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc.hyps</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>infYx&#39;</span><span> </span><span>partfx&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Y&#39;</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t&#39;</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Y&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Y&#39; &#8838; Yx - {yx&#39;}&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite Y&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t&#39; &lt; s&quot;</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8838; Y&#39; &#8743; finite X &#8743; card X = r &#10230; (f &#8728; insert yx&#39;) X = t&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fields</span><span> </span><span>x</span><span> </span><span>Y&#39;</span><span> </span><span>yx&#39;</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?propr (yx&#39;, Y&#39;, t&#39;) &#8743; (x, (yx&#39;, Y&#39;, t&#39;)) &#8712; ?ramr&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dependent_choice</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>transr</span><span> </span><span>propr0</span><span> </span><span>proprstep</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>pg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?propr (g n)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &lt; m &#10233; (g n, g m) &#8712; ?ramr&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?gy</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst &#8728; g&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?gt</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd &#8728; snd &#8728; g&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rangeg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;k. range ?gt &#8838; {..&lt;k}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; range ?gt&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = ?gt n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pg</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; {..&lt;s}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g n&quot;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rangeg</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (range ?gt)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_nat_iff_bounded</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s&#39;</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39; = ?gt n&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>infeqs&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite {n. ?gt n = s&#39;}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inf_img_fin_domE</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>infinite_UNIV_nat</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pg</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>n&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>less&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;&lt;s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g n&#39;&quot;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inj_gy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inj ?gy&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>linorder_injI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span> </span><span>m&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m &lt; m&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rg</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span>pg</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?gy m &#8800; ?gy m&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g m&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g m&#39;&quot;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>pg</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?gy ` {n. ?gt n = s&#39;} &#8838; YY&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split_beta</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>infeqs&#39;</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite (?gy ` {n. ?gt n = s&#39;})&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>inj_gy</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subset_inj_on</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>finite_imageD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39; &lt; s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>less&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;X. X &#8838; ?gy ` {n. ?gt n = s&#39;} &#8743; finite X &#8743; card X = Suc r &#10230; f X = s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f X = s&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8838; ?gy ` {n. ?gt n = s&#39;}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cardX</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite X&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card X = Suc r&quot;</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>X</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>AA</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AA &#8838; {n. ?gt n = s&#39;}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Xeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X = ?gy`AA&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_image_iff</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cardX</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;AA &#8800; {}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>AAleast</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LEAST x. x &#8712; AA) &#8712; AA&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>LeastI_ex</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;g (LEAST x. x &#8712; AA)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>fields</span><span> </span><span>ya</span><span> </span><span>Ya</span><span> </span><span>ta</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>AAleast</span><span> </span><span>Xeq</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ya</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ya &#8712; X&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rev_image_eqI</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f X = f (insert ya (X - {ya}))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = ta&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X - {ya} &#8838; Ya&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; X - {ya}&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xeq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = ?gy a&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#39; &#8712; AA&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Xeq</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fields</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#39; &#8800; (LEAST x. x &#8712; AA)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Least_le</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;x. x &#8712; AA&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>a&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LEAST x. x &#8712; AA) &lt; a&#39;&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>                </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>xeq</span><span> </span><span>fields</span><span> </span><span>rg</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; Ya&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (X - {ya}) = r&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cardX</span><span> </span><span>ya</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pg</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LEAST x. x &#8712; AA&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>fields</span><span> </span><span>cardX</span><span> </span><span>*</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>insert_Diff_single</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>AA</span><span> </span><span>AAleast</span><span> </span><span>fields</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8230; = s&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>            </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Ramsey</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span>r</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;infinite Z;
      &#8704;X. X &#8838; Z &#8743; finite X &#8743; card X = r &#10230; f X &lt; s&#10215;
    &#10233; &#8707;Y t. Y &#8838; Z &#8743; infinite Y &#8743; t &lt; s
            &#8743; (&#8704;X. X &#8838; Y &#8743; finite X &#8743; card X = r &#10230; f X = t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Ramsey_induction</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>part_fn_def</span><span> </span><span>nsets_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Ramsey2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Z</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>infZ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite Z&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>part</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x&#8712;Z. &#8704;y&#8712;Z. x &#8800; y &#10230; f {x, y} &lt; s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;Y t. Y &#8838; Z &#8743; infinite Y &#8743; t &lt; s &#8743; (&#8704;x&#8712;Y. &#8704;y&#8712;Y. x&#8800;y &#10230; f {x, y} = t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>part</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>part2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;X. X &#8838; Z &#8743; finite X &#8743; card X = 2 &#10230; f X &lt; s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eval_nat_numeral</span><span> </span><span>card_Suc_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Y</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>*</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;Y &#8838; Z&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite Y&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &lt; s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;X. X &#8838; Y &#8743; finite X &#8743; card X = 2 &#10230; f X = t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>Ramsey</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>infZ</span><span> </span><span>part2</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x&#8712;Y. &#8704;y&#8712;Y. x &#8800; y &#10230; f {x, y} = t&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>*</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Disjunctive Well-Foundedness&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  An application of Ramsey&#39;s theorem to program termination. See
  @{cite &quot;Podelski-Rybalchenko&quot;}.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>disj_wf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#215; &#39;a) set &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disj_wf r &#10231; (&#8707;T. &#8707;n::nat. (&#8704;i&lt;n. wf (T i)) &#8743; r = (&#8899;i&lt;n. T i))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>transition_idx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat &#8658; &#39;a) &#8658; (nat &#8658; (&#39;a &#215; &#39;a) set) &#8658; nat set &#8658; nat&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;transition_idx s T A = (LEAST k. &#8707;i j. A = {i, j} &#8743; i &lt; j &#8743; (s j, s i) &#8712; T k)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>transition_idx_less</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; j&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s j, s i) &#8712; T k&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k &lt; n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;transition_idx s T {i, j} &lt; n&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;transition_idx s T {i, j} &#8804; k&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>transition_idx_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>Least_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>transition_idx_in</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; j&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s j, s i) &#8712; T k&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s j, s i) &#8712; T (transition_idx s T {i, j})&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>transition_idx_def</span><span> </span><span>doubleton_eq_iff</span><span> </span><span>conj_disj_distribR</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>LeastI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;To be equal to the union of some well-founded relations is equivalent
  to being the subset of such a union.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>disj_wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disj_wf r &#10231; (&#8707;T. &#8707;n::nat. (&#8704;i&lt;n. wf(T i)) &#8743; r &#8838; (&#8899;i&lt;n. T i))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;T n. &#10214;&#8704;i&lt;n. wf (T i); r &#8838; &#8899; (T ` {..&lt;n})&#10215;
           &#10233; (&#8704;i&lt;n. wf (T i &#8745; r)) &#8743; r = (&#8899;i&lt;n. T i &#8745; r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wf_Int1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>disj_wf_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;*&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>trans_disj_wf_implies_wf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trans r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;disj_wf r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf r&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>wf_iff_no_infinite_down_chain</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>notI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;s. &#8704;i. (s (Suc i), s i) &#8712; r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>sSuc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i. (s (Suc i), s i) &#8712; r&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;disj_wf r&#8250;</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>wfT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k&lt;n. wf(T k)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r = (&#8899;k&lt;n. T k)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>disj_wf_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_in_T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;k. (s j, s i) &#8712; T k &#8743; k&lt;n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; j&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; j&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s j, s i) &#8712; r&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>less_Suc_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sSuc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trans r&#8250;</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; j &#10233; transition_idx s T {i, j} &lt; n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_in_T</span><span> </span><span>transition_idx_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>trless</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &#8800; j &#10233; transition_idx s T {i, j} &lt; n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>doubleton_eq_iff</span><span> </span><span>less_linear</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;K k. K &#8838; UNIV &#8743; infinite K &#8743; k &lt; n &#8743;
      (&#8704;i&#8712;K. &#8704;j&#8712;K. i &#8800; j &#10230; transition_idx s T {i, j} = k)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Ramsey2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>trless</span><span> </span><span>infinite_UNIV_nat</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>infK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;infinite K&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k &lt; n&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>allk</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&#8712;K. &#8704;j&#8712;K. i &#8800; j &#10230; transition_idx s T {i, j} = k&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s (enumerate K (Suc m)), s (enumerate K m)) &#8712; T k&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?j</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;enumerate K (Suc m)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?i</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;enumerate K m&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ij</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?i &lt; ?j&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>enumerate_step</span><span> </span><span>infK</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?j &#8712; K&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?i &#8712; K&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>enumerate_in_set</span><span> </span><span>infK</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ij</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k = transition_idx s T {?i, ?j}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>allk</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>s_in_T</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>ij</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s ?j, s ?i) &#8712; T k&#39;&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;k&#39;&lt;n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s ?j, s ?i) &#8712; T k&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>k</span><span> </span><span>transition_idx_in</span><span> </span><span>ij</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; wf (T k)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>wf_iff_no_infinite_down_chain</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>wfT</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; n&#8250;</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
