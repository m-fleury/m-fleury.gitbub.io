<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory AbelCoset (repository version)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory AbelCoset</h1>

<span class="command">theory</span> <span class="name">AbelCoset</span><br/>
<span class="keyword">imports</span> <a href="Coset.html"><span class="name">Coset</span></a> <a href="Ring.html"><span class="name">Ring</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      HOL/Algebra/AbelCoset.thy
    Author:     Stephan Hohe, TU Muenchen
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>AbelCoset</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Coset</span><span> </span><span>Ring</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;More Lifting from Groups to Abelian Groups&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definitions&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Hiding &#8249;&lt;+&gt;&#8250; from \&lt;^theory&gt;&#8249;HOL.Sum_Type&#8250; until I come
  up with better syntax here&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>Sum_Type.Plus</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&lt;+&gt;&quot;</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>a_r_coset</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[_, &#39;a set, &#39;a] &#8658; &#39;a set&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;+&gt;&#305;&quot;</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a_r_coset G = r_coset (add_monoid G)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>a_l_coset</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[_, &#39;a, &#39;a set] &#8658; &#39;a set&quot;</span></span></span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&lt;+&#305;&quot;</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a_l_coset G = l_coset (add_monoid G)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>A_RCOSETS</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[_, &#39;a set] &#8658; (&#39;a set)set&quot;</span></span></span><span>   </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;a&#39;_rcosets&#305; _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A_RCOSETS G H = RCOSETS (add_monoid G) H&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>set_add</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[_, &#39;a set ,&#39;a set] &#8658; &#39;a set&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&lt;+&gt;&#305;&quot;</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_add G = set_mult (add_monoid G)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>A_SET_INV</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[_,&#39;a set] &#8658; &#39;a set&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;a&#39;_set&#39;_inv&#305; _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A_SET_INV G H = SET_INV (add_monoid G) H&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>a_r_congruent</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;a,&#39;b)ring_scheme, &#39;a set] &#8658; (&#39;a*&#39;a)set&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;racong&#305;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a_r_congruent G = r_congruent (add_monoid G)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>A_FactGroup</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;a,&#39;b) ring_scheme, &#39;a set] &#8658; (&#39;a set) monoid&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A&#39;_Mod&quot;</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="comment">&#8213; &#8249;Actually defined for groups rather than monoids&#8250;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A_FactGroup G H = FactGroup (add_monoid G) H&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>a_kernel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a, &#39;m) ring_scheme &#8658; (&#39;b, &#39;n) ring_scheme &#8658;  (&#39;a &#8658; &#39;b) &#8658; &#39;a set&quot;</span></span></span><span>
</span><span>    </span><span class="comment">&#8213; &#8249;the kernel of a homomorphism (additive)&#8250;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a_kernel G H h = kernel (add_monoid G) (add_monoid H) h&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>abelian_group_hom</span><span> </span><span class="delimiter">=</span><span> </span><span>G</span><span class="delimiter">?</span><span class="delimiter">:</span><span> </span><span>abelian_group</span><span> </span><span>G</span><span> </span><span class="delimiter">+</span><span> </span><span>H</span><span class="delimiter">?</span><span class="delimiter">:</span><span> </span><span>abelian_group</span><span> </span><span>H</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a_group_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;group_hom (add_monoid G) (add_monoid H) h&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>a_r_coset_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>a_r_coset_def</span><span> </span><span>r_coset_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_r_coset_def&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H +&gt; a &#8801; &#8899;h&#8712;H. {h &#8853; a}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>a_r_coset_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>a_l_coset_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>a_l_coset_def</span><span> </span><span>l_coset_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_l_coset_def&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &lt;+ H &#8801; &#8899;h&#8712;H. {a &#8853; h}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>a_l_coset_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>A_RCOSETS_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>A_RCOSETS_def</span><span> </span><span>RCOSETS_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_RCOSETS_def&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a_rcosets H &#8801; &#8899;a&#8712;carrier G. {H +&gt; a}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_RCOSETS_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>set_add_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>set_add_def</span><span> </span><span>set_mult_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_add_def&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &lt;+&gt; K &#8801; &#8899;h&#8712;H. &#8899;k&#8712;K. {h &#8853; k}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_add_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>A_SET_INV_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>A_SET_INV_def</span><span> </span><span>SET_INV_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_SET_INV_def&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a_set_inv H &#8801; &#8899;h&#8712;H. {&#8854; h}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_SET_INV_defs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>a_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Cosets&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>abelian_group</span><span> </span><span class="delimiter">&lt;</span><span>
</span><span>        </span><span>add</span><span class="delimiter">:</span><span> </span><span>group</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(add_monoid G)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">rewrites</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;carrier (add_monoid G) =   carrier G&quot;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;   mult (add_monoid G) =       add G&quot;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;    one (add_monoid G) =      zero G&quot;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;  m_inv (add_monoid G) =     a_inv G&quot;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finprod (add_monoid G) =    finsum G&quot;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;r_coset (add_monoid G) = a_r_coset G&quot;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l_coset (add_monoid G) = a_l_coset G&quot;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;a k. pow (add_monoid G) a k) = (&#955;a k. add_pow G k a)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a_group</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>m_inv_def</span><span> </span><span>a_inv_def</span><span> </span><span>finsum_def</span><span> </span><span>a_r_coset_def</span><span> </span><span>a_l_coset_def</span><span> </span><span>add_pow_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>abelian_group</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>add.coset_mult_assoc</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>a_repr_independence&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>add.repr_independence</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemmas a_coset_add_assoc = add.coset_mult_assoc
lemmas a_coset_add_zero [simp] = add.coset_mult_one
lemmas a_coset_add_inv1 = add.coset_mult_inv1
lemmas a_coset_add_inv2 = add.coset_mult_inv2
lemmas a_coset_join1 = add.coset_join1
lemmas a_coset_join2 = add.coset_join2
lemmas a_solve_equation = add.solve_equation
lemmas a_repr_independence = add.repr_independence
lemmas a_rcosI = add.rcosI
lemmas a_rcosetsI = add.rcosetsI
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_coset_add_assoc</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;[| M &#8838; carrier G; g &#8712; carrier G; h &#8712; carrier G |]
      ==&gt; (M +&gt; g) +&gt; h = M +&gt; (g &#8853; h)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.coset_mult_assoc</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>abelian_group.a_coset_add_assoc</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_coset_add_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;M &#8838; carrier G ==&gt; M +&gt; &#120812; = M&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.coset_mult_one</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_coset_add_inv1</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;[| M +&gt; (x &#8853; (&#8854; y)) = M;  x &#8712; carrier G ; y &#8712; carrier G;
         M &#8838; carrier G |] ==&gt; M +&gt; x = M +&gt; y&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.coset_mult_inv1</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span> </span><span>a_inv_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_coset_add_inv2</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;[| M +&gt; x = M +&gt; y;  x &#8712; carrier G;  y &#8712; carrier G;  M &#8838; carrier G |]
      ==&gt; M +&gt; (x &#8853; (&#8854; y)) = M&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.coset_mult_inv2</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span> </span><span>a_inv_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_coset_join1</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;[| H +&gt; x = H;  x &#8712; carrier G;  subgroup H (add_monoid G) |] ==&gt; x &#8712; H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.coset_join1</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_solve_equation</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;subgroup H (add_monoid G); x &#8712; H; y &#8712; H&#10215; &#10233; &#8707;h&#8712;H. y = h &#8853; x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.solve_equation</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_repr_independence</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; y &#8712; H +&gt; x; x &#8712; carrier G; subgroup H (add_monoid G) &#10215; &#10233;
     H +&gt; x = H +&gt; y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_repr_independence&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_r_coset_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_coset_join2</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;x &#8712; carrier G;  subgroup H (add_monoid G); x&#8712;H&#10215; &#10233; H +&gt; x = H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.coset_join2</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_monoid</span><span class="delimiter">)</span><span> </span><span>a_r_coset_subset_G</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;[| H &#8838; carrier G; x &#8712; carrier G |] ==&gt; H +&gt; x &#8838; carrier G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>monoid.r_coset_subset_G</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_monoid</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_rcosI</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;[| h &#8712; H; H &#8838; carrier G; x &#8712; carrier G|] ==&gt; h &#8853; x &#8712; H +&gt; x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.rcosI</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_rcosetsI</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8838; carrier G; x &#8712; carrier G&#10215; &#10233; H +&gt; x &#8712; a_rcosets H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.rcosetsI</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span> </span><span>A_RCOSETS_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Really needed?&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_transpose_inv</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;[| x &#8853; y = z;  x &#8712; carrier G;  y &#8712; carrier G;  z &#8712; carrier G |]
      ==&gt; (&#8854; x) &#8853; z = y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_neg1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Subgroups&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>additive_subgroup</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>H</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a_subgroup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subgroup H (add_monoid G)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>additive_subgroup</span><span class="delimiter">)</span><span> </span><span>is_additive_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;additive_subgroup H G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>additive_subgroup_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>additive_subgroupI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a_subgroup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subgroup H (add_monoid G)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;additive_subgroup H G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>additive_subgroup.intro</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a_subgroup</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>additive_subgroup</span><span class="delimiter">)</span><span> </span><span>a_subset</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8838; carrier G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>additive_subgroup</span><span class="delimiter">)</span><span> </span><span>a_closed</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;x &#8712; H; y &#8712; H&#10215; &#10233; x &#8853; y &#8712; H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.m_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>additive_subgroup</span><span class="delimiter">)</span><span> </span><span>zero_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#120812; &#8712; H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.one_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>additive_subgroup</span><span class="delimiter">)</span><span> </span><span>a_inv_closed</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; H &#10233; &#8854; x &#8712; H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.m_inv_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_inv_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Additive subgroups are normal&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Every subgroup of an &#8249;abelian_group&#8250; is normal&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>abelian_subgroup</span><span> </span><span class="delimiter">=</span><span> </span><span>additive_subgroup</span><span> </span><span class="delimiter">+</span><span> </span><span>abelian_group</span><span> </span><span>G</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a_normal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normal H (add_monoid G)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>is_abelian_subgroup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_subgroup H G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>abelian_subgroup_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>abelian_subgroupI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a_normal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normal H (add_monoid G)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a_comm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;!!x y. [| x &#8712; carrier G; y &#8712; carrier G |] ==&gt; x &#8853;<span class="hidden">&#8664;</span><sub>G<span class="hidden">&#8665;</span></sub> y = y &#8853;<span class="hidden">&#8664;</span><sub>G<span class="hidden">&#8665;</span></sub> x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_subgroup H G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>normal</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(add_monoid G)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a_normal</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_subgroup H G&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_comm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>abelian_subgroupI2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a_comm_group</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;comm_group (add_monoid G)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a_subgroup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subgroup H (add_monoid G)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_subgroup H G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>comm_group</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(add_monoid G)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a_comm_group</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>subgroup</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(add_monoid G)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a_subgroup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;xa&#8712;H. {xa &#8853; x}) = (&#8899;xa&#8712;H. {x &#8853; xa})&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8838; carrier G&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_subgroup</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>that</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;h&#8712;H. {h &#8853;<span class="hidden">&#8664;</span><sub>G<span class="hidden">&#8665;</span></sub> x}) = (&#8899;h&#8712;H. {x &#8853;<span class="hidden">&#8664;</span><sub>G<span class="hidden">&#8665;</span></sub> h})&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m_comm</span><span> </span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_subgroup H G&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>r_coset_def</span><span> </span><span>l_coset_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>abelian_subgroupI3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;additive_subgroup H G&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_group G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_subgroup H G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>abelian_subgroupI2</span><span> </span><span>abelian_group.a_comm_group</span><span> </span><span>additive_subgroup_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_coset_eq</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;x &#8712; carrier G. H +&gt; x = x &lt;+ H)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.coset_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span> </span><span>a_l_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_inv_op_closed1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;x &#8712; carrier G; h &#8712; H&#10215; &#10233; (&#8854; x) &#8853; h &#8853; x &#8712; H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.inv_op_closed1</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_inv_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_inv_op_closed2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;x &#8712; carrier G; h &#8712; H&#10215; &#10233; x &#8853; h &#8853; (&#8854; x) &#8712; H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.inv_op_closed2</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_inv_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_lcos_m_assoc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; M &#8838; carrier G; g &#8712; carrier G; h &#8712; carrier G &#10215; &#10233; g &lt;+ (h &lt;+ M) = (g &#8853; h) &lt;+ M&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.lcos_m_assoc</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_l_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_lcos_mult_one</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;M &#8838; carrier G ==&gt; &#120812; &lt;+ M = M&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.lcos_mult_one</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_l_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_l_coset_subset_G</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; H &#8838; carrier G; x &#8712; carrier G &#10215; &#10233; x &lt;+ H &#8838; carrier G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.l_coset_subset_G</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_l_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_l_coset_swap</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;y &#8712; x &lt;+ H;  x &#8712; carrier G;  subgroup H (add_monoid G)&#10215; &#10233; x &#8712; y &lt;+ H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.l_coset_swap</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_l_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_l_coset_carrier</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;[| y &#8712; x &lt;+ H;  x &#8712; carrier G;  subgroup H (add_monoid G) |] ==&gt; y &#8712; carrier G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.l_coset_carrier</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_l_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_l_repr_imp_subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8712; x &lt;+ H&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subgroup H (add_monoid G)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &lt;+ H &#8838; x &lt;+ H&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>a_l_coset_defs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>add.l_repr_independence</span><span> </span><span>assms</span><span> </span><span>set_eq_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_l_repr_independence</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8712; x &lt;+ H&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subgroup H (add_monoid G)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &lt;+ H = y &lt;+ H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.l_repr_independence</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_l_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sb</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>setadd_subset_G</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8838; carrier G; K &#8838; carrier G&#10215; &#10233; H &lt;+&gt; K &#8838; carrier G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.setmult_subset_G</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>set_add_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>subgroup_add_id</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;subgroup H (add_monoid G) &#10233; H &lt;+&gt; H = H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.subgroup_mult_id</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>set_add_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcos_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a_set_inv (H +&gt; x) = H +&gt; (&#8854; x)&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.rcos_inv</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>  </span><span>folded</span><span> </span><span>a_r_coset_def</span><span> </span><span>a_inv_def</span><span> </span><span>A_SET_INV_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_setmult_rcos_assoc</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8838; carrier G; K &#8838; carrier G; x &#8712; carrier G&#10215;
      &#10233; H &lt;+&gt; (K +&gt; x) = (H &lt;+&gt; K) +&gt; x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.setmult_rcos_assoc</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>set_add_def</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_rcos_assoc_lcos</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;H &#8838; carrier G; K &#8838; carrier G; x &#8712; carrier G&#10215;
      &#10233; (H +&gt; x) &lt;+&gt; K = H &lt;+&gt; (x &lt;+ K)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.rcos_assoc_lcos</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>     </span><span>folded</span><span> </span><span>set_add_def</span><span> </span><span>a_r_coset_def</span><span> </span><span>a_l_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcos_sum</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;x &#8712; carrier G; y &#8712; carrier G&#10215;
      &#10233; (H +&gt; x) &lt;+&gt; (H +&gt; y) = H +&gt; (x &#8853; y)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.rcos_sum</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>set_add_def</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>rcosets_add_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;M &#8712; a_rcosets H &#10233; H &lt;+&gt; M = M&quot;</span></span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;generalizes &#8249;subgroup_mult_id&#8250;&#8250;</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.rcosets_mult_eq</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>set_add_def</span><span> </span><span>A_RCOSETS_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Congruence Relation&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_equiv_rcong</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;equiv (carrier G) (racong H)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.equiv_rcong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_congruent_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_l_coset_eq_rcong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; carrier G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &lt;+ H = racong H `` {a}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.l_coset_eq_rcong</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_congruent_def</span><span> </span><span>a_l_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcos_equation</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;ha &#8853; a = h &#8853; b; a &#8712; carrier G;  b &#8712; carrier G;  
        h &#8712; H;  ha &#8712; H;  hb &#8712; H&#10215;
      &#10233; hb &#8853; a &#8712; (&#8899;h&#8712;H. {h &#8853; b})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.rcos_equation</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span> </span><span>a_subgroup</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_congruent_def</span><span> </span><span>a_l_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcos_disjoint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;pairwise disjnt (a_rcosets H)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.rcos_disjoint</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span> </span><span>a_subgroup</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_RCOSETS_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcos_self</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G &#10233; x &#8712; H +&gt; x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.rcos_self</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span> </span><span>_</span><span> </span><span>a_subgroup</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcosets_part_G</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8899;(a_rcosets H) = carrier G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.rcosets_part_G</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span> </span><span>a_subgroup</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_RCOSETS_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_cosets_finite</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;c &#8712; a_rcosets H;  H &#8838; carrier G;  finite (carrier G)&#10215; &#10233; finite c&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.cosets_finite</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_RCOSETS_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_card_cosets_equal</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;c &#8712; a_rcosets H;  H &#8838; carrier G; finite(carrier G)&#10215;
      &#10233; card c = card H&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A_RCOSETS_defs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>add.card_rcosets_equal</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>rcosets_subset_PowG</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;additive_subgroup H G  &#10233; a_rcosets H &#8838; Pow(carrier G)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.rcosets_subset_PowG</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_RCOSETS_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule</span><span> </span><span>additive_subgroup.a_subgroup</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>a_lagrange</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;finite(carrier G); additive_subgroup H G&#10215;
      &#10233; card(a_rcosets H) * card(H) = order(G)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group.lagrange</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_RCOSETS_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span> </span><span>order_def</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>order_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>fast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>additive_subgroup.a_subgroup</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Factorization&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>A_FactGroup_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>A_FactGroup_def</span><span> </span><span>FactGroup_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_FactGroup_def&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>G</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">structure</span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;G A_Mod H &#8801; &#10631;carrier = a_rcosets<span class="hidden">&#8664;</span><sub>G<span class="hidden">&#8665;</span></sub> H, mult = set_add G, one = H&#10632;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A_FactGroup_defs</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fold</span><span> </span><span>A_RCOSETS_def</span><span> </span><span>set_add_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_setmult_closed</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;K1 &#8712; a_rcosets H; K2 &#8712; a_rcosets H&#10215; &#10233; K1 &lt;+&gt; K2 &#8712; a_rcosets H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.setmult_closed</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_RCOSETS_def</span><span> </span><span>set_add_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_setinv_closed</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;K &#8712; a_rcosets H &#10233; a_set_inv K &#8712; a_rcosets H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.setinv_closed</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_RCOSETS_def</span><span> </span><span>A_SET_INV_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcosets_assoc</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;M1 &#8712; a_rcosets H; M2 &#8712; a_rcosets H; M3 &#8712; a_rcosets H&#10215;
      &#10233; M1 &lt;+&gt; M2 &lt;+&gt; M3 = M1 &lt;+&gt; (M2 &lt;+&gt; M3)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.rcosets_assoc</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_RCOSETS_def</span><span> </span><span>set_add_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_subgroup_in_rcosets</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;H &#8712; a_rcosets H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.subgroup_in_rcosets</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_RCOSETS_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcosets_inv_mult_group_eq</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;M &#8712; a_rcosets H &#10233; a_set_inv M &lt;+&gt; M = H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.rcosets_inv_mult_group_eq</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_RCOSETS_def</span><span> </span><span>A_SET_INV_def</span><span> </span><span>set_add_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_factorgroup_is_group</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;group (G A_Mod H)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.factorgroup_is_group</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_FactGroup_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Since the Factorization is based on an \emph{abelian} subgroup, is results in 
        a commutative group&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_factorgroup_is_comm_group</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;comm_group (G A_Mod H)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Group.comm_monoid_axioms (G A_Mod H)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>comm_monoid_axioms.intro</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>A_FactGroup_def</span><span> </span><span>FactGroup_def</span><span> </span><span>RCOSETS_def</span><span> </span><span>a_normal</span><span> </span><span>add.m_comm</span><span> </span><span>normal.rcos_sum</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>comm_group.intro</span><span> </span><span>comm_monoid.intro</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_factorgroup_is_group</span><span> </span><span>group.is_monoid</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_A_FactGroup</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8855;<span class="hidden">&#8664;</span><sub>(G A_Mod H)<span class="hidden">&#8665;</span></sub> X&#39; = X &lt;+&gt;<span class="hidden">&#8664;</span><sub>G<span class="hidden">&#8665;</span></sub> X&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>A_FactGroup_def</span><span> </span><span>set_add_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_inv_FactGroup</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; carrier (G A_Mod H) &#10233; inv<span class="hidden">&#8664;</span><sub>G A_Mod H<span class="hidden">&#8665;</span></sub> X = a_set_inv X&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.inv_FactGroup</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_FactGroup_def</span><span> </span><span>A_SET_INV_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The coset map is a homomorphism from \&lt;^term&gt;&#8249;G&#8250; to the quotient group
  \&lt;^term&gt;&#8249;G Mod H&#8250;&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_r_coset_hom_A_Mod</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;a. H +&gt; a) &#8712; hom (add_monoid G) (G A_Mod H)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>normal.r_coset_hom_Mod</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_normal</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>A_FactGroup_def</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The isomorphism theorems have been omitted from lifting, at
  least for now&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The First Isomorphism Theorem&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The quotient by the kernel of a homomorphism is isomorphic to the 
  range of that homomorphism.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>a_kernel_defs</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>a_kernel_def</span><span> </span><span>kernel_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>a_kernel_def&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;a_kernel R S h = {x &#8712; carrier R. h x = &#120812;<span class="hidden">&#8664;</span><sub>S<span class="hidden">&#8665;</span></sub>}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a_kernel_def</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>kernel_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Homomorphisms&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>abelian_group_homI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_group G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_group H&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a_group_hom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;group_hom (add_monoid G)
                                  (add_monoid H) h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_group_hom G H h&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span>abelian_group</span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span>abelian_group</span><span> </span><span>H</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>abelian_group_hom.intro</span><span> </span><span>abelian_group_hom_axioms.intro</span><span> 
</span><span>        </span><span>G.abelian_group_axioms</span><span> </span><span>H.abelian_group_axioms</span><span> </span><span>a_group_hom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>is_abelian_group_hom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_group_hom G H h&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>hom_add</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;[| x &#8712; carrier G; y &#8712; carrier G |]
        ==&gt; h (x &#8853;<span class="hidden">&#8664;</span><sub>G<span class="hidden">&#8665;</span></sub> y) = h x &#8853;<span class="hidden">&#8664;</span><sub>H<span class="hidden">&#8665;</span></sub> h y&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group_hom.hom_mult</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group_hom</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>hom_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G &#10233; h x &#8712; carrier H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group_hom.hom_closed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group_hom</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>zero_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;h &#120812; &#8712; carrier H&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>hom_zero</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;h &#120812; = &#120812;<span class="hidden">&#8664;</span><sub>H<span class="hidden">&#8665;</span></sub>&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group_hom.hom_one</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group_hom</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>a_inv_closed</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G ==&gt; h (&#8854;x) &#8712; carrier H&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>hom_a_inv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G ==&gt; h (&#8854;x) = &#8854;<span class="hidden">&#8664;</span><sub>H<span class="hidden">&#8665;</span></sub> (h x)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group_hom.hom_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group_hom</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_inv_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>additive_subgroup_a_kernel</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;additive_subgroup (a_kernel G H h) G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>additive_subgroup.intro</span><span> </span><span>a_group_hom</span><span> </span><span>a_kernel_def</span><span> </span><span>group_hom.subgroup_kernel</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The kernel of a homomorphism is an abelian subgroup&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>abelian_subgroup_a_kernel</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;abelian_subgroup (a_kernel G H h) G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>abelian_subgroupI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>G.abelian_group_axioms</span><span> </span><span>abelian_subgroup.a_normal</span><span> </span><span>abelian_subgroupI3</span><span> </span><span>additive_subgroup_a_kernel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>G.a_comm</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>A_FactGroup_nonempty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; carrier (G A_Mod a_kernel G H h)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8800; {}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group_hom.FactGroup_nonempty</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group_hom</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_kernel_def</span><span> </span><span>A_FactGroup_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>X</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>FactGroup_the_elem_mem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>X</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; carrier (G A_Mod (a_kernel G H h))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;the_elem (h`X) &#8712; carrier H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group_hom.FactGroup_the_elem_mem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group_hom</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_kernel_def</span><span> </span><span>A_FactGroup_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>X</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>A_FactGroup_hom</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;X. the_elem (h`X)) &#8712; hom (G A_Mod (a_kernel G H h))
          (add_monoid H)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group_hom.FactGroup_hom</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group_hom</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_kernel_def</span><span> </span><span>A_FactGroup_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>A_FactGroup_inj_on</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;inj_on (&#955;X. the_elem (h ` X)) (carrier (G A_Mod a_kernel G H h))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group_hom.FactGroup_inj_on</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group_hom</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_kernel_def</span><span> </span><span>A_FactGroup_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;If the homomorphism \&lt;^term&gt;&#8249;h&#8250; is onto \&lt;^term&gt;&#8249;H&#8250;, then so is the
homomorphism from the quotient group&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>A_FactGroup_onto</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h ` carrier G = carrier H&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;X. the_elem (h ` X)) ` carrier (G A_Mod a_kernel G H h) = carrier H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group_hom.FactGroup_onto</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group_hom</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_kernel_def</span><span> </span><span>A_FactGroup_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>h</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;If \&lt;^term&gt;&#8249;h&#8250; is a homomorphism from \&lt;^term&gt;&#8249;G&#8250; onto \&lt;^term&gt;&#8249;H&#8250;, then the
 quotient group \&lt;^term&gt;&#8249;G Mod (kernel G H h)&#8250; is isomorphic to \&lt;^term&gt;&#8249;H&#8250;.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>A_FactGroup_iso_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;h ` carrier G = carrier H
   &#10233; (&#955;X. the_elem (h`X)) &#8712; iso (G A_Mod (a_kernel G H h)) (add_monoid H)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>group_hom.FactGroup_iso_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_group_hom</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_kernel_def</span><span> </span><span>A_FactGroup_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>ring_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group_hom</span><span class="delimiter">)</span><span> </span><span>A_FactGroup_iso</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;h ` carrier G = carrier H
   &#10233;  (G A_Mod (a_kernel G H h)) &#8773;  (add_monoid H)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A_FactGroup_iso_set</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_iso_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Cosets&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Not eveything from \texttt{CosetExt.thy} is lifted here.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>additive_subgroup</span><span class="delimiter">)</span><span> </span><span>a_Hcarr</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>hH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8712; H&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8712; carrier G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.mem_carrier</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hH</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_elemrcos_carrier</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>acarr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a &#8712; carrier G&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#39; &#8712; H +&gt; a&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a&#39; &#8712; carrier G&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.elemrcos_carrier</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>acarr</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>a&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcos_const</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>hH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;h &#8712; H&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H +&gt; h = H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.rcos_const</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hH</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcos_module_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>xcarr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x&#39;cos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8712; H +&gt; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x&#39; &#8853; &#8854;x) &#8712; H&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.rcos_module_imp</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span> </span><span>a_inv_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>xcarr</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>x&#39;cos</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcos_module_rev</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8712; carrier G&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x&#39; &#8853; &#8854;x) &#8712; H&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8712; H +&gt; x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.rcos_module_rev</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span> </span><span>a_inv_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcos_module</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8712; carrier G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x&#39; &#8712; H +&gt; x) = (x&#39; &#8853; &#8854;x &#8712; H)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subgroup.rcos_module</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_subgroup</span><span> </span><span>a_group</span><span class="delimiter">,</span><span>
</span><span>    </span><span>folded</span><span> </span><span>a_r_coset_def</span><span> </span><span>a_inv_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>monoid_record_simps</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;variant&#8250;</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcos_module_minus</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ring G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>carr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; &#8712; carrier G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x&#39; &#8712; H +&gt; x) = (x&#39; &#8854; x &#8712; H)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>G</span><span class="delimiter">:</span><span> </span><span>ring</span><span> </span><span>G</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>carr</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x&#39; &#8712; H +&gt; x) = (x&#39; &#8853; &#8854;x &#8712; H)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a_rcos_module</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>carr</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x&#39; &#8712; H +&gt; x) = (x&#39; &#8854; x &#8712; H)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>minus_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_repr_independence&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8712; H +&gt; x&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; carrier G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H +&gt; x = H +&gt; y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_repr_independence</span><span> </span><span>a_subgroup</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_repr_independenceD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8712; carrier G&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;H +&gt; x = H +&gt; y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y &#8712; H +&gt; x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_rcos_self</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_subgroup</span><span class="delimiter">)</span><span> </span><span>a_rcosets_carrier</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;X &#8712; a_rcosets H &#10233; X &#8838; carrier G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_rcosets_part_G</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Addition of Subgroups&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_monoid</span><span class="delimiter">)</span><span> </span><span>set_add_closed</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &#8838; carrier G&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;B &#8838; carrier G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;A &lt;+&gt; B &#8838; carrier G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>add.set_mult_closed</span><span> </span><span>set_add_defs</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>abelian_group</span><span class="delimiter">)</span><span> </span><span>add_additive_subgroups</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>subH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;additive_subgroup H G&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;additive_subgroup K G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;additive_subgroup (H &lt;+&gt; K) G&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_add_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add.mult_subgroups</span><span> </span><span>additive_subgroup_def</span><span> </span><span>subH</span><span> </span><span>subK</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>additive_subgroup.intro</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
