<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Watched_Literals_List_Enumeration (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Watched_Literals_List_Enumeration</h1>

<span class="command">theory</span> <span class="name">Watched_Literals_List_Enumeration</span><br/>
<span class="keyword">imports</span> <a href="Watched_Literals_Algorithm_Enumeration.html"><span class="name">Watched_Literals_Algorithm_Enumeration</span></a> <a href="../Watched_Literals/Watched_Literals_List.html"><span class="name">Watched_Literals_List</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Watched_Literals_List_Enumeration</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Watched_Literals_Algorithm_Enumeration</span><span> </span><span>Watched_Literals.Watched_Literals_List</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>convert_lits_l_DECO_clause</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; convert_lits_l M N &#10233; DECO_clause S&#39; = DECO_clause S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>DECO_clause_def</span><span> </span><span>uminus_lit_of_image_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>
</span><span>    </span><span>mset_filter</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>convert_lits_l_filter_decided</span><span> </span><span>mset_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>mset_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>convert_lits_l_TWL_DECO_clause</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; convert_lits_l M N &#10233; TWL_DECO_clause S&#39; = TWL_DECO_clause S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TWL_DECO_clause_def</span><span> </span><span>uminus_lit_of_image_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>take_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>drop_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>mset_filter</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>convert_lits_l_filter_decided</span><span> </span><span>mset_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>mset_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st_l</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; twl_st_l b &#10233; DECO_clause (get_trail S&#39;) = DECO_clause (get_trail_l S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l_def</span><span> </span><span>convert_lits_l_DECO_clause</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>twl_st_l</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; twl_st_l b &#10233; TWL_DECO_clause (get_trail S&#39;) = TWL_DECO_clause (get_trail_l S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l_def</span><span> </span><span>convert_lits_l_DECO_clause</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DECO_clause_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause (A @ B) = DECO_clause A + DECO_clause B&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause (Decided K # A) = add_mset (-K) (DECO_clause A)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause (Propagated K C # A) = DECO_clause A&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8896;K. K &#8712; set A &#10233; &#172;is_decided K) &#10233; DECO_clause A = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>DECO_clause_def</span><span> </span><span>filter_mset_empty_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>find_decomp_target</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; &#39;v twl_st_l &#8658; (&#39;v twl_st_l &#215; &#39;v literal) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;find_decomp_target =  (&#955;i S.
    SPEC(&#955;(T, K). &#8707;M2 M1. equality_except_trail S T &#8743; get_trail_l T = M1 &#8743;
       (Decided K # M1, M2) &#8712; set (get_all_ann_decomposition (get_trail_l S)) &#8743;
          get_level (get_trail_l S) K = i))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>propagate_unit_and_add</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v twl_st &#8658; &#39;v twl_st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_unit_and_add K (M, N, U, D, NE, UE, WS, Q) =
      (Propagated (-K) {#-K#} # M, N, U, None, add_mset {#-K#} NE, UE, {#}, {#K#})&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>propagate_unit_and_add_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v twl_st_l &#8658; &#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_unit_and_add_l K (M, N, D, NE, UE, WS, Q) =
      (Propagated (-K) 0 # M, N, None, add_mset {#-K#} NE, UE, {#}, {#K#})&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>negate_mode_bj_unit_l_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_bj_unit_l_inv S &#10231;
     (&#8707;(S&#39;::&#39;v twl_st) b. (S, S&#39;) &#8712; twl_st_l b &#8743; twl_list_invs S &#8743; twl_stgy_invs S&#39; &#8743;
        twl_struct_invs S&#39; &#8743; get_conflict_l S = None)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>negate_mode_bj_unit_l</span><span>   </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#8658; &#39;v twl_st_l nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_bj_unit_l = (&#955;S. do {
    ASSERT(negate_mode_bj_unit_l_inv S);
    (S, K) &#8592; find_decomp_target 1 S;
    RETURN (propagate_unit_and_add_l K S)
  })&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>negate_mode_bj_unit_l</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (get_trail_l S) = 1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; twl_st_l b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>stgy_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l S = None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_bj_unit_l S &#8804; &#8659;{(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743;
        clauses_to_update_l S = {#}}
       (SPEC (negate_model_and_add_twl S&#39;))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;y&#8712;Collect (negate_model_and_add_twl S&#39;).
            (propagate_unit_and_add_l x2 x1, y)
            &#8712; {(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743; clauses_to_update_l S = {#}}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>        </span><span>count_dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (get_trail_l S) = 1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>S_S&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; twl_st_l b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>x_S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; {(T, K).
            &#8707;M2 M1.
                equality_except_trail S T &#8743;
                get_trail_l T = M1 &#8743;
                (Decided K # M1, M2)
                &#8712; set (get_all_ann_decomposition (get_trail_l S)) &#8743;
                get_level (get_trail_l S) K = 1}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (x1, x2)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#215; &#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x1</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?y0</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;(M, Oth). (drop (length M - length (get_trail_l x1)) (get_trail S&#39;), Oth)) S&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?y1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_unit_and_add x2 ?y0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>S_x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;equality_except_trail S x1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>tr_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_l x1 = M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided x2 # M1, M2) &#8712; set (get_all_ann_decomposition (get_trail_l S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>lev_x2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (get_trail_l S) x2 = 1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_S</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>decomp&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided x2 # drop (length (get_trail S&#39;) - length M1) (get_trail S&#39;), M2&#39;)
           &#8712; set (get_all_ann_decomposition (get_trail S&#39;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>conv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(get_trail_l S, get_trail S&#39;) &#8712; convert_lits_l (get_clauses_l S)
          (get_unit_clauses_l S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>conv_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M1, drop (length (get_trail S&#39;) - length M1) (get_trail S&#39;))
             &#8712; convert_lits_l (get_clauses_l S) (get_unit_clauses_l S)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>convert_lits_l_decomp_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail S&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_l S&#8250;</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_l S&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>S_S&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x2_DECO</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#-x2#} = DECO_clause (get_trail S&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span>count_dec</span><span> </span><span>S_S&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>  </span><span>twl_st_l</span><span> </span><span>filter_mset_empty_conv</span><span> </span><span>count_decided_0_iff</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1_drop</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (length (get_trail_l S) - length M1) (get_trail_l S) = M1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(propagate_unit_and_add_l x2 x1, ?y1)
        &#8712; {(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743;
        clauses_to_update_l S = {#}}&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>S_x1</span><span> </span><span>tr_M1</span><span> </span><span>decomp</span><span> </span><span>decomp&#39;</span><span> </span><span>lev_x2</span><span> </span><span>add_inv</span><span> </span><span>conv_M1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x1</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l_def</span><span> </span><span>twl_list_invs_def</span><span> </span><span>convert_lit.simps</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span>
</span><span>          </span><span>intro</span><span class="delimiter">:</span><span> </span><span>convert_lits_l_extend_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_model_and_add_twl S&#39; ?y1&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_S&#39;</span><span> </span><span>confl</span><span> </span><span>lev_x2</span><span> </span><span>count_dec</span><span> </span><span>tr_M1</span><span> </span><span>S_x1</span><span> </span><span>decomp</span><span> </span><span>decomp&#39;</span><span> </span><span>M1_drop</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x1</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l_def</span><span> </span><span>x2_DECO</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>convert_lits_l_DECO_clause</span><span>
</span><span>            </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>negate_model_and_add_twl.bj_unit</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="delimiter">]</span><span>
</span><span>            </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?y1</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>negate_mode_bj_unit_l_def</span><span> </span><span>find_decomp_target_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_rcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>negate_mode_bj_unit_l_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RETURN_RES_refine_iff</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>DECO_clause_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, &#39;a) ann_lits &#8658;  &#39;v clause_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause_l M = map (uminus o lit_of) (filter is_decided M)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>propagate_nonunit_and_add</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v literal multiset twl_clause &#8658;  &#39;v twl_st &#8658; &#39;v twl_st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_nonunit_and_add K C (M, N, U, D, NE, UE, WS, Q) = do {
      (Propagated (-K) (clause C) # M, add_mset C N, U, None,
       NE, UE, {#}, {#K#})
    }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>propagate_nonunit_and_add_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v clause_l &#8658; nat &#8658; &#39;v twl_st_l &#8658; &#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_nonunit_and_add_l K C i (M, N, D, NE, UE, WS, Q) = do {
      (Propagated (-K) i # M, fmupd i (C, True) N, None,
      NE, UE, {#}, {#K#})
    }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>negate_mode_bj_nonunit_l_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_bj_nonunit_l_inv S &#10231;
   (&#8707;S&#39;&#39; b. (S, S&#39;&#39;) &#8712; twl_st_l b &#8743; twl_list_invs S &#8743; count_decided (get_trail_l S) &gt; 1 &#8743;
      twl_struct_invs S&#39;&#39; &#8743;  twl_stgy_invs S&#39;&#39; &#8743; get_conflict_l S = None)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>negate_mode_bj_nonunit_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#8658; &#39;v twl_st_l nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_bj_nonunit_l = (&#955;S. do {
    ASSERT(negate_mode_bj_nonunit_l_inv S);
    let C = DECO_clause_l (get_trail_l S);
    (S, K) &#8592; find_decomp_target (count_decided (get_trail_l S)) S;
    i &#8592; get_fresh_index (get_clauses_l S);
    RETURN (propagate_nonunit_and_add_l K C i S)
  })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DECO_clause_l_DECO_clause</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset (DECO_clause_l M1) = DECO_clause M1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M1</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>DECO_clause_l_def</span><span> </span><span>DECO_clause_def</span><span> </span><span>convert_lits_l_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TWL_DECO_clause_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TWL_DECO_clause M1 =
    TWL_Clause (mset (watched_l (DECO_clause_l M1)))
          (mset (unwatched_l (DECO_clause_l M1)))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>TWL_DECO_clause_def</span><span> </span><span>convert_lits_l_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TWL_DECO_clause_def</span><span> </span><span>convert_lits_l_def</span><span> </span><span>filter_map</span><span> </span><span>take_map</span><span> </span><span>drop_map</span><span>
</span><span>    </span><span>DECO_clause_l_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_DECO_clause_l</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (DECO_clause_l M) = count_decided M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DECO_clause_l_def</span><span> </span><span>count_decided_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>negate_mode_bj_nonunit_l</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>count_dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (get_trail_l S) &gt; 1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; twl_st_l b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>stgy_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l S = None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_bj_nonunit_l S &#8804; &#8659;{(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743;
        clauses_to_update_l S = {#}}
       (SPEC (negate_model_and_add_twl S&#39;))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN (propagate_nonunit_and_add_l x2 (DECO_clause_l (get_trail_l S)) i x1)
        &#8804; &#8659; {(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743;
        clauses_to_update_l S = {#}}
          (SPEC (negate_model_and_add_twl S&#39;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>x_S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; {(T, K).
            &#8707;M2 M1.
              equality_except_trail S T &#8743;
              get_trail_l T = M1 &#8743;
              (Decided K # M1, M2) &#8712; set (get_all_ann_decomposition (get_trail_l S)) &#8743;
              get_level (get_trail_l S) K = count_decided (get_trail_l S)}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>i</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8712; {i. 0 &lt; i &#8743; i &#8713;# dom_m (get_clauses_l x1)}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#215; &#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>x1</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>D</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 = (M, N, U, D, NE, UE, Q)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S_x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;equality_except_trail S x1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>tr_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_l x1 = M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided x2 # M1, M2) &#8712; set (get_all_ann_decomposition (get_trail_l S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>lev_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (get_trail_l S) x2 = count_decided (get_trail_l S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_S</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?y0</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;(M, Oth). (drop (length M - length (get_trail_l x1)) (get_trail S&#39;), Oth)) S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?y1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate_nonunit_and_add x2 (TWL_DECO_clause (get_trail S&#39;)) ?y0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>M3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_l S = M3 @ M2 @ Decided x2 # M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict S&#39; = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>trail_S&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(get_trail_l S, get_trail S&#39;) &#8712; convert_lits_l (get_clauses_l S) (get_unit_clauses_l S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (get_trail_l S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M3 = 0&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M2 = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter is_decided M3 = []&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter is_decided M2 = []&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>M3</span><span> </span><span>count_decided_0_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>decomp&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided x2 # drop (length (get_trail S&#39;) - length M1) (get_trail S&#39;), M2&#39;)
          &#8712; set (get_all_ann_decomposition (get_trail S&#39;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>conv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(get_trail_l S, get_trail S&#39;) &#8712; convert_lits_l (get_clauses_l S)
        (get_unit_clauses_l S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>conv_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M1, drop (length (get_trail S&#39;) - length M1) (get_trail S&#39;))
            &#8712; convert_lits_l (get_clauses_l S) (get_unit_clauses_l S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>convert_lits_l_decomp_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail S&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_l S&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_l S&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>SS&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1_drop</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (length (get_trail_l S) - length M1) (get_trail_l S) = M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- x2 &#8712; set (watched_l (DECO_clause_l (get_trail_l S)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_x1</span><span> </span><span>tr_M1</span><span> </span><span>SS&#39;</span><span> </span><span>i</span><span> </span><span>decomp</span><span> </span><span>add_inv</span><span> </span><span>lev_K</span><span> </span><span>M3</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>DECO_clause_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause_l (get_trail_l S) ! 0 = -x2&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>M3</span><span> </span><span>DECO_clause_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L i &#8713; set M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_inv</span><span> </span><span>i</span><span> </span><span>S_x1</span><span> </span><span>M3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_list_invs_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>x1</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(propagate_nonunit_and_add_l x2 (DECO_clause_l (get_trail_l S)) i x1, ?y1) &#8712;
        {(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743; clauses_to_update_l S = {#}}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_x1</span><span> </span><span>tr_M1</span><span> </span><span>SS&#39;</span><span> </span><span>i</span><span> </span><span>add_inv</span><span> </span><span>decomp</span><span> </span><span>conv_M1</span><span> </span><span>M1_drop</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>x1</span><span> </span><span>twl_st_l_def</span><span> </span><span>twl_list_invs_def</span><span> </span><span>init_clss_l_mapsto_upd_notin</span><span>
</span><span>          </span><span>TWL_DECO_clause_alt_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>learned_clss_l_mapsto_upd_notin_irrelev</span><span>
</span><span>          </span><span>convert_lit.simps</span><span>
</span><span>          </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>convert_lits_l_extend_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>N</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D + NE&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?y1 &#8712; Collect (negate_model_and_add_twl S&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_x1</span><span> </span><span>tr_M1</span><span> </span><span>i</span><span> </span><span>add_inv</span><span> </span><span>decomp</span><span> </span><span>confl</span><span> </span><span>confl&#39;</span><span> </span><span>count_dec</span><span> </span><span>lev_K</span><span> </span><span>decomp&#39;</span><span> </span><span>S_x1</span><span> </span><span>SS&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>x1</span><span>  </span><span>twl_st_l_def</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>negate_model_and_add_twl.bj_nonunit</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>M2&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;y&#8712;Collect (negate_model_and_add_twl S&#39;).
        (propagate_nonunit_and_add_l x2 (DECO_clause_l (get_trail_l S)) i x1, y)
      &#8712; {(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743;
        clauses_to_update_l S = {#}}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?y1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x1</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RETURN_RES_refine_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_bj_nonunit_l_inv S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>negate_mode_bj_nonunit_l_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>negate_mode_bj_nonunit_l_def</span><span> </span><span>find_decomp_target_def</span><span> </span><span>get_fresh_index_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>restart_nonunit_and_add</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal multiset twl_clause &#8658;  &#39;v twl_st &#8658; &#39;v twl_st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;restart_nonunit_and_add C (M, N, U, D, NE, UE, WS, Q) = do {
      (M, add_mset C N, U, None, NE, UE, {#}, {#})
    }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>restart_nonunit_and_add_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause_l &#8658; nat &#8658; &#39;v twl_st_l &#8658; &#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;restart_nonunit_and_add_l C i (M, N, D, NE, UE, WS, Q) = do {
      (M, fmupd i (C, True) N, None, NE, UE, {#}, {#})
    }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>negate_mode_restart_nonunit_l_inv</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_restart_nonunit_l_inv S &#10231;
  (&#8707;S&#39; b. (S, S&#39;) &#8712; twl_st_l b &#8743; twl_struct_invs S&#39; &#8743; twl_list_invs S &#8743; twl_stgy_invs S&#39; &#8743;
     count_decided (get_trail_l S) &gt; 1 &#8743; get_conflict_l S = None)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>negate_mode_restart_nonunit_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#8658; &#39;v twl_st_l nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_restart_nonunit_l = (&#955;S. do {
    ASSERT(negate_mode_restart_nonunit_l_inv S);
    let C = DECO_clause_l (get_trail_l S);
    i &#8592; SPEC(&#955;i. i &lt; count_decided (get_trail_l S));
    (S, K) &#8592; find_decomp_target i S;
    i &#8592; get_fresh_index (get_clauses_l S);
    RETURN (restart_nonunit_and_add_l C i S)
  })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>negate_mode_restart_nonunit_l</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>count_dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (get_trail_l S) &gt; 1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; twl_st_l b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>stgy_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l S = None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_restart_nonunit_l S &#8804; &#8659;{(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743;
        clauses_to_update_l S = {#}}
       (SPEC (negate_model_and_add_twl S&#39;))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN (restart_nonunit_and_add_l (DECO_clause_l (get_trail_l S)) i x1)
        &#8804; &#8659; {(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743;
        clauses_to_update_l S = {#}}
          (SPEC (negate_model_and_add_twl S&#39;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>j</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8712; {i. i &lt; count_decided (get_trail_l S)}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x_S</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; {(T, K).
            &#8707;M2 M1.
              equality_except_trail S T &#8743;
              get_trail_l T = M1 &#8743;
              (Decided K # M1, M2) &#8712; set (get_all_ann_decomposition (get_trail_l S)) &#8743;
              get_level (get_trail_l S) K = j}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (x1, x2)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>i</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8712; {i. 0 &lt; i &#8743; i &#8713;# dom_m (get_clauses_l x1)}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#215; &#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>x1</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>D</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x1 = (M, N, U, D, NE, UE, Q)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S_x1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;equality_except_trail S x1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>tr_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_l x1 = M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided x2 # M1, M2) &#8712; set (get_all_ann_decomposition (get_trail_l S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>lev_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (get_trail_l S) x2 = j&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x_S</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?y0</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;(M, Oth). (drop (length (get_trail S&#39;) - length M1) (get_trail S&#39;), Oth)) S&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?y1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;restart_nonunit_and_add (TWL_DECO_clause (get_trail S&#39;)) ?y0&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>M3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_l S = M3 @ M2 @ Decided x2 # M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_x1</span><span> </span><span>SS&#39;</span><span> </span><span>decomp</span><span> </span><span>tr_M1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict S&#39; = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>trail_S&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(get_trail_l S, get_trail S&#39;) &#8712; convert_lits_l (get_clauses_l S) (get_unit_clauses_l S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (get_trail_l S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>decomp&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided x2 # drop (length (get_trail S&#39;) - length M1) (get_trail S&#39;), M2&#39;)
          &#8712; set (get_all_ann_decomposition (get_trail S&#39;))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>conv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(get_trail_l S, get_trail S&#39;) &#8712; convert_lits_l (get_clauses_l S)
        (get_unit_clauses_l S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>conv_M1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M1, drop (length (get_trail S&#39;) - length M1) (get_trail S&#39;))
            &#8712; convert_lits_l (get_clauses_l S) (get_unit_clauses_l S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>convert_lits_l_decomp_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail S&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_l S&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_l S&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>SS&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1_drop</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (length (get_trail_l S) - length M1) (get_trail_l S) = M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L i &#8713; set M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add_inv</span><span> </span><span>i</span><span> </span><span>S_x1</span><span> </span><span>M3</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_list_invs_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>x1</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(restart_nonunit_and_add_l (DECO_clause_l (get_trail_l S)) i x1, ?y1) &#8712;
        {(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743;
        clauses_to_update_l S = {#}}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_x1</span><span> </span><span>tr_M1</span><span> </span><span>SS&#39;</span><span> </span><span>i</span><span> </span><span>add_inv</span><span> </span><span>decomp</span><span> </span><span>conv_M1</span><span> </span><span>decomp&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>x1</span><span> </span><span>twl_st_l_def</span><span> </span><span>twl_list_invs_def</span><span> </span><span>init_clss_l_mapsto_upd_notin</span><span>
</span><span>          </span><span>TWL_DECO_clause_alt_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>learned_clss_l_mapsto_upd_notin_irrelev</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span>
</span><span>          </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>convert_lits_l_extend_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>N</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D+NE&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (get_trail_l S) x2 &lt; count_decided (get_trail_l S)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev_K</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?y1 &#8712; Collect (negate_model_and_add_twl S&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_x1</span><span> </span><span>tr_M1</span><span> </span><span>i</span><span> </span><span>add_inv</span><span> </span><span>decomp&#39;</span><span> </span><span>confl</span><span> </span><span>confl&#39;</span><span> </span><span>count_dec</span><span> </span><span>lev_K</span><span> </span><span>SS&#39;</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>S&#39;</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>x1</span><span>  </span><span>twl_st_l_def</span><span>
</span><span>          </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>negate_model_and_add_twl.restart_nonunit</span><span class="delimiter">[</span><span>of</span><span> </span><span>x2</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;y&#8712;Collect (negate_model_and_add_twl S&#39;).
        (restart_nonunit_and_add_l (DECO_clause_l (get_trail_l S)) i x1, y)
      &#8712; {(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743;
        clauses_to_update_l S = {#}}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="var">?y1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x1</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RETURN_RES_refine_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>negate_mode_restart_nonunit_l_def</span><span> </span><span>find_decomp_target_def</span><span> </span><span>get_fresh_index_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>negate_mode_restart_nonunit_l_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>unify_trace_failure</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>negate_mode_l_inv</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_l_inv S &#10231;
     (&#8707;S&#39; b. (S, S&#39;) &#8712; twl_st_l b &#8743; twl_struct_invs S&#39; &#8743; twl_list_invs S &#8743; twl_stgy_invs S&#39; &#8743;
       get_conflict_l S = None &#8743; count_decided (get_trail_l S) &#8800; 0)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>negate_mode_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#8658; &#39;v twl_st_l nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_l S = do {
    ASSERT(negate_mode_l_inv S);
    if count_decided (get_trail_l S) = 1
    then negate_mode_bj_unit_l S
    else do {
      b &#8592; SPEC(&#955;_. True);
      if b then negate_mode_bj_nonunit_l S else negate_mode_restart_nonunit_l S
    }
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>negate_mode_l</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; twl_st_l b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>stgy_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l S = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (get_trail_l S) &#8800; 0&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_mode_l S &#8804; &#8659;{(S, S&#39;&#39;). (S, S&#39;&#39;) &#8712; twl_st_l None &#8743; twl_list_invs S &#8743;
        clauses_to_update_l S = {#}}
       (SPEC (negate_model_and_add_twl S&#39;))&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>negate_mode_l_def</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>negate_mode_restart_nonunit_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>SS&#39;</span><span class="delimiter">]</span><span> </span><span>negate_mode_bj_unit_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>SS&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span>negate_mode_bj_nonunit_l</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>SS&#39;</span><span class="delimiter">]</span><span> </span><span>lhs_step_If</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>negate_mode_l_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal set &#8658; bool&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdcl_twl_enum_inv_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_enum_inv_l S &#10231;
    (&#8707;S&#39;. (S, S&#39;) &#8712; twl_st_l None &#8743; cdcl_twl_enum_inv S&#39;) &#8743;
       twl_list_invs S&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdcl_twl_enum_l</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l &#8658; bool nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_enum_l S = do {
     S &#8592; cdcl_twl_stgy_prog_l S;
     S &#8592; WHILE<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8663;</span><sup>cdcl_twl_enum_inv_l<span class="hidden">&#8662;</span></sup>
       (&#955;S. get_conflict_l S = None &#8743; count_decided(get_trail_l S) &gt; 0 &#8743;
            &#172;P (lits_of_l (get_trail_l S)))
       (&#955;S. do {
             S &#8592; negate_mode_l S;
             cdcl_twl_stgy_prog_l S
           })
       S;
     if get_conflict_l S = None
     then RETURN (if count_decided(get_trail_l S) = 0 then P (lits_of_l (get_trail_l S)) else True)
     else RETURN (False)
    }&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>negate_model_and_add_twl_resultD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_model_and_add_twl S T &#10233;
    clauses_to_update T = {#} &#8743; get_conflict T = None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>negate_model_and_add_twl.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_enum_l</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st_l&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, S&#39;) &#8712; twl_st_l None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>stgy_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l S = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (get_trail_l S) &#8800; 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l S = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_enum_l S &#8804; &#8659; bool_rel
       (cdcl_twl_enum P S&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_enum_l_def</span><span> </span><span>cdcl_twl_enum_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>cdcl_twl_stgy_prog_l_spec_final&#39;</span><span> </span><span>negate_mode_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_l_pre_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>S&#39;</span><span> </span><span>U</span><span> </span><span>U&#39;</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_enum_inv_l_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>U&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_enum_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span> </span><span>cdcl_twl_enum_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>S&#39;</span><span> </span><span>T</span><span> </span><span>T&#39;</span><span> </span><span>U</span><span> </span><span>U&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl_twl_stgy_prog_l_spec_final&#39;</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>order.trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span> </span><span>twl_st_l</span><span> </span><span>cdcl_twl_stgy_prog_l_pre_def</span><span> </span><span>cdcl_twl_enum_inv_def</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>negate_model_and_add_twl_twl_struct_invs</span><span>
</span><span>        </span><span>negate_model_and_add_twl_twl_stgy_invs</span><span> </span><span>conc_fun_R_mono</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>negate_model_and_add_twl_resultD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2018 </td><td align="center">26d8aaa66074 </td><td align="center">24d4e5b9 </td><td align="center">Tue 06 Nov 2018 04:20:56 PM CET </td></tr></table></p></footer></div>

<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:14:54 AM CEST </td></tr></table></p></footer></div>

<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:25:56 AM CEST </td></tr></table></p></footer></div>

<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 10:00:01 AM CEST </td></tr></table></p></footer></div>

</html>








