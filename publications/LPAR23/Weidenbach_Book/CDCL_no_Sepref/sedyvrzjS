<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory DPLL_W (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory DPLL_W</h1>

<span class="command">theory</span> <span class="name">DPLL_W</span><br/>
<span class="keyword">imports</span> <a href="Partial_Annotated_Herbrand_Interpretation.html"><span class="name">Partial_Annotated_Herbrand_Interpretation</span></a> <a href="Wellfounded_More.html"><span class="name">Wellfounded_More</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>DPLL_W</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Entailment_Definition.Partial_Herbrand_Interpretation</span><span>
</span><span>  </span><span>Entailment_Definition.Partial_Annotated_Herbrand_Interpretation</span><span>
</span><span>  </span><span>Weidenbach_Book_Base.Wellfounded_More</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Weidenbach&#39;s DPLL&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Rules&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lit</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a, unit) ann_lit&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a, unit) ann_lits&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;v</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;v dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#215; &#39;v clauses&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;v dpll<span class="hidden">&#8681;</span><sub>W</sub>_state &#8658; &#39;v dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;trail &#8801; fst&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>clauses</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;v dpll<span class="hidden">&#8681;</span><sub>W</sub>_state &#8658; &#39;v clauses&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;clauses &#8801; snd&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;v dpll<span class="hidden">&#8681;</span><sub>W</sub>_state &#8658; &#39;v dpll<span class="hidden">&#8681;</span><sub>W</sub>_state &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>propagate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;add_mset L C &#8712;# clauses S &#10233; trail S &#8872;as CNot C &#10233; undefined_lit (trail S) L
  &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub> S (Propagated L () # trail S, clauses S)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>decided</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;undefined_lit (trail S) L &#10233; atm_of L &#8712; atms_of_mm (clauses S)
  &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub> S (Decided L # trail S, clauses S)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>backtrack</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;backtrack_split (trail S) = (M&#39;, L # M) &#10233; is_decided L &#10233; D &#8712;# clauses S
  &#10233; trail S &#8872;as CNot D &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub> S (Propagated (- (lit_of L)) () # M, clauses S)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Invariants&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_distinct_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>decided</span><span> </span><span>L</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>defined_lit_map</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>C</span><span> </span><span>L</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>defined_lit_map</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack</span><span> </span><span>S</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>extracted</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extracted</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_appendD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_consistent_interp_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (lits_of_l (trail S))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (lits_of_l (trail S&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack</span><span> </span><span>S</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>extracted</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>decided</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_dup</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_dup&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>backtrack_split_list_eq</span><span> </span><span>distinct.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>distinct_append</span><span> </span><span>extracted</span><span>
</span><span>      </span><span>list.simps</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>map_append</span><span> </span><span>no_dup</span><span> </span><span>snd_conv</span><span> </span><span>no_dup_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;insert (lit_of L) (lits_of_l M) &#8838; lits_of_l (trail S)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extracted</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (insert (lit_of L) (lits_of_l M))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>consistent_interp_subset</span><span> </span><span>cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;undefined_lit M (lit_of L)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extracted</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lit_of L &#8713; lits_of_l M&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>consistent_add_undefined_lit_consistent</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_vars_in_snd_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` (lits_of_l (trail S)) &#8838; atms_of_mm (clauses S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` (lits_of_l (trail S&#39;)) &#8838; atms_of_mm (clauses S&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack</span><span> </span><span>S</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of (lit_of L) &#8712; atms_of_mm (clauses S)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S) &#8838; atms_of_mm (clauses S)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;xb. xb &#8712; set M &#10233; atm_of (lit_of xb) &#8712; atms_of_mm (clauses S)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>backtrack.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lits_of_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_plus_implies_atm_of_on_atms_of_ms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atms_of_ms_lit_of_atms_of</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atms_of_ms (unmark ` c) = atm_of ` lit_of ` c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atms_of_ms_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>image_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\cwref{dpll:sound:model}{theorem 2.8.2 page 73}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_propagate_is_conclusion</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S) (get_all_ann_decomposition (trail S))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S) &#8838; atms_of_mm (clauses S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S&#39;) (get_all_ann_decomposition (trail S&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>decided</span><span> </span><span>L</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_decomposition_implies_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>L</span><span> </span><span>C</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>inS</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cnot</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>atms_incl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?I</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set (map unmark (trail S)) &#8746; set_mset (clauses S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?I &#8872;p add_mset L C&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inS</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?I &#8872;ps CNot C&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_annots_true_clss_cls</span><span> </span><span>cnot</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?I &#8872;p {#L#}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_clss_cls_plus_CNot</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?I</span><span> </span><span>L</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span>inS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_all_ann_decomposition (trail S) = []&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_all_ann_decomposition (trail S) &#8800; []&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a b. (a, b) &#8712; set (tl (get_all_ann_decomposition (trail S)))
      &#10233; (unmark_l a &#8746; set_mset (clauses S)) &#8872;ps unmark_l b&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_decomposition_implies_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list.set_sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a c. hd (get_all_ann_decomposition (trail S)) = (a, c)
      &#10233; (unmark_l a &#8746; set_mset (clauses S)) &#8872;ps (unmark_l c)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>IH</span><span> </span><span>all_decomposition_implies_cons_pair</span><span> </span><span>all_decomposition_implies_single</span><span>
</span><span>        </span><span>list.collapse</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a c. hd (get_all_ann_decomposition (trail S)) = (a, c)
      &#10233; (unmark_l a &#8746; set_mset (clauses S)) &#8872;p {#L#}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>c</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hd (get_all_ann_decomposition (trail S)) = (a, c)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S = c @ a&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_all_ann_decomposition_decomp</span><span> </span><span>h</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set (map unmark a) &#8746; set_mset (clauses S)
          &#8746; unmark_l c &#8872;ps CNot C&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?I &#8872;ps CNot C&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span> </span><span>Un_left_commute</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atms_of_ms (CNot C) &#8838; atms_of_ms (set (map unmark a) &#8746; set_mset (clauses S))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;atms_of_ms (unmark_l c) &#8838; atms_of_ms (set (map unmark a)
            &#8746; set_mset (clauses S))&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atms_incl</span><span> </span><span>cnot</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atms_of_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>true_annots_CNot_all_atms_defined</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inS</span><span> </span><span>atms_of_atms_of_ms_mono</span><span> </span><span>atms_incl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>h&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unmark_l a &#8746; set_mset (clauses S) &#8872;ps CNot C&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_clss_clss_left_right</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>I</span><span class="delimiter">]</span><span> </span><span>h</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;2&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unmark_l a &#8746; set_mset (clauses S) &#8872;p {#L#}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inS</span><span> </span><span>true_clss_cls_plus_CNot</span><span> </span><span>true_clss_clss_in_imp_true_clss_cls</span><span> </span><span>union_trus_clss_clss</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hd (get_all_ann_decomposition (trail S))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_decomposition_implies_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack</span><span> </span><span>S</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>extracted</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>decided</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cnot</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cons</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>atms_incl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S = M&#39; @ L # M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extracted</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;l &#8712; set M&#39;. &#172;is_decided l&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extracted</span><span> </span><span>backtrack_split_fst_not_decided</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_all_ann_decomposition (trail S) &#8800; []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S) ((L # M, M&#39;)
           # tl (get_all_ann_decomposition (trail S)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>IH</span><span> </span><span>extracted</span><span> </span><span>get_all_ann_decomposition_backtrack_split</span><span> </span><span>list.exhaust_sel</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unmark_l (L # M) &#8746; set_mset (clauses S) &#8872;ps(&#955;a.{#lit_of a#}) ` set M&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unmark_l (L # M) &#8746; unmark_l M&#39; &#8872;ps CNot D&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>S</span><span> </span><span>Un_commute</span><span> </span><span>cons</span><span> </span><span>image_Un</span><span> </span><span>set_append</span><span>
</span><span>        </span><span>true_annots_true_clss_clss</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unmark_l (L # M) &#8746; set_mset (clauses S) &#8746; unmark_l M&#39;
        &#8872;ps CNot D&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Un_assoc</span><span> </span><span>Un_left_commute</span><span> </span><span>true_clss_clss_union_l_r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set (map unmark (L # M)) &#8746; set_mset (clauses S) &#8872;ps CNot D&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_clss_clss_left_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set (map unmark (L # M)) &#8746; set_mset (clauses S) &#8872;p {#}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>D</span><span> </span><span>Un_def</span><span> </span><span>mem_Collect_eq</span><span>
</span><span>        </span><span>true_clss_clss_contradiction_true_clss_cls_false</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unmark_l M &#8746; set_mset (clauses S) &#8872;p {#-lit_of L#}&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_clss_clss_false_left_right</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span>all_decomposition_implies_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>P</span><span> </span><span>level</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; set (get_all_ann_decomposition
        (fst (Propagated (- lit_of L) P # M, clauses S)))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Propagated (- lit_of L) P # M&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?hd</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hd (get_all_ann_decomposition ?M&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?tl</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tl (get_all_ann_decomposition ?M&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = ?hd &#8744; x &#8712; set ?tl&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_all_ann_decomposition ?M&#39;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>           </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; set ?tl&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Decided (lit_of L) = L&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decided</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x &#8712; set (get_all_ann_decomposition (M&#39; @ L # M))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x&#39;</span><span> </span><span>get_all_ann_decomposition_except_last_choice_equal</span><span class="delimiter">[</span><span>of</span><span> </span><span>M&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lit_of L&quot;</span></span></span><span> </span><span>P</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>          </span><span>L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>M&#39;</span><span> </span><span>list.set_sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tl_Nil</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;case x of (Ls, seen) &#8658; unmark_l Ls &#8746; set_mset (clauses S)
          &#8872;ps unmark_l seen&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decided</span><span> </span><span>IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S</span><span> </span><span>all_decomposition_implies_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = ?hd&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tl (get_all_ann_decomposition (M&#39; @ L # M)) &#8800; []&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;ms. length (get_all_ann_decomposition (M&#39; @ ms))
              = length (get_all_ann_decomposition ms)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>M&#39;</span><span> </span><span>get_all_ann_decomposition_remove_undecided_length</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc (length (get_all_ann_decomposition M)) &#8800; Suc 0&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L # M&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>decided</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_ann_decomposition
               (M&#39; @ L # M)&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M0&#39;</span><span> </span><span>M0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span>L0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hd (tl (get_all_ann_decomposition (M&#39; @ L # M))) = (M0, M0&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;hd (tl (get_all_ann_decomposition (M&#39; @ L # M)))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x = (M0, Propagated (-lit_of L) P # M0&#39;)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x&#39;</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_all_ann_decomposition_last_choice</span><span> </span><span>tl</span><span> </span><span>M&#39;</span><span> </span><span>L0</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>is_decided_ex_Decided</span><span> </span><span>lit_of.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>local.decided</span><span> </span><span>old.unit.exhaust</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l_get_all_ann_decomposition</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;get_all_ann_decomposition (trail S) = (L # M, M&#39;) # (M0, M0&#39;) #
            l_get_all_ann_decomposition&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_all_ann_decomposition_backtrack_split</span><span> </span><span>extracted</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>L0</span><span> </span><span>S</span><span>
</span><span>            </span><span>hd_Cons_tl</span><span> </span><span>n</span><span> </span><span>tl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M = M0&#39; @ M0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_all_ann_decomposition_hd_hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IL&#39;</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;unmark_l M0 &#8746; set_mset (clauses S)
          &#8746; unmark_l M0&#39; &#8872;ps {{#- lit_of L#}}&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span> </span><span>Un_left_commute</span><span> </span><span>image_Un</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unmark_l M0 &#8746; set_mset (clauses S)
          &#8872;ps unmark_l M0&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>x&#39;&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_decomposition_implies_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>L0</span><span> </span><span>S</span><span>
</span><span>            </span><span>list.set_sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.set_sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>old.prod.case</span><span> </span><span>tl</span><span> </span><span>tl_Nil</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;case x of (Ls, seen) &#8658; unmark_l Ls &#8746; set_mset (clauses S)
          &#8872;ps unmark_l seen&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_clss_clss_left_right</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>x&#39;&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;case x of (Ls, seen) &#8658;
        unmark_l Ls &#8746; set_mset (snd (?M&#39;, clauses S))
          &#8872;ps unmark_l seen&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snd_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\cwref{dpll:sound:propLits:valuation}{theorem 2.8.3 page 73}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_propagate_is_conclusion_of_decided</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S) (get_all_ann_decomposition (trail S))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S) &#8838; atms_of_mm (clauses S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_mset (clauses S&#39;) &#8746; {{#lit_of L#} |L. is_decided L &#8743; L &#8712; set (trail S&#39;)}
    &#8872;ps unmark ` &#8899;(set ` snd ` set (get_all_ann_decomposition (trail S&#39;)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_decomposition_implies_trail_is_implied</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_propagate_is_conclusion</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\cwref{dpll:sound:propLits:unsat}{theorem 2.8.4 page 73}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>only_propagated_vars_unsat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>decided</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x &#8712; set M. &#172; is_decided x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>DN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;D &#8712; N&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M &#8872;as CNot D&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies N (get_all_ann_decomposition M)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>atm_incl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l M &#8838; atms_of_ms N&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsatisfiable N&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; unsatisfiable N&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;I &#8872;s N&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp I&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;total_over_m I N&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>satisfiable_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>I_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;I &#8872; D&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DN</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_clss_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{{#lit_of L#} |L. is_decided L &#8743; L &#8712; set M} = {}&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decided</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atms_of_ms (N &#8746; unmark_l M) = atms_of_ms N&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_incl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atms_of_ms_def</span><span> </span><span>lits_of_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;total_over_m I (N &#8746; unmark ` (set M))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>total_over_m_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;I &#8872;s unmark ` (set M)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_decomposition_implies_propagated_lits_are_implied</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inv</span><span class="delimiter">]</span><span> </span><span>cons</span><span> </span><span>I</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_clss_clss_def</span><span> </span><span>l0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;I &#8872;s unmark_l M&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;K &#8712;# D&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;-K &#8712; lits_of_l M&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>allE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>D</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>true_annots_def</span><span> </span><span>Ball_def</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{#-K#}&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;-K &#8712; I&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IM</span><span> </span><span>true_clss_singleton_lit_of_implies_incl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; I &#8872; D&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_cls_def</span><span> </span><span>consistent_interp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>I_D</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_same_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clauses S = clauses S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rtranclp dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S) (get_all_ann_decomposition (trail S))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>atm_incl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S) &#8838; atms_of_mm (clauses S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (lits_of_l (trail S))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S&#39;) (get_all_ann_decomposition (trail S&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S&#39;)  &#8838; atms_of_mm (clauses S&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clauses S = clauses S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (lits_of_l (trail S&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S) (get_all_ann_decomposition (trail S))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S) &#8838; atms_of_mm (clauses S)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;clauses S = clauses S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (lits_of_l (trail S))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>S&#39;</span><span> </span><span>S&#39;&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>Star</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">,</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S) (get_all_ann_decomposition (trail S))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>atm_incl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S)  &#8838; atms_of_mm (clauses S)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (lits_of_l (trail S))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S&#39;)
    (get_all_ann_decomposition (trail S&#39;))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>atm_incl&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S&#39;) &#8838; atms_of_mm (clauses S&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clauses S = clauses S&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (lits_of_l (trail S&#39;))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clauses S = clauses S&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_same_clauses</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">]</span><span> </span><span>snd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S&#39;&#39;) (get_all_ann_decomposition (trail S&#39;&#39;))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_propagate_is_conclusion</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">]</span><span> </span><span>decomp</span><span> </span><span>atm_incl&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S&#39;&#39;) &#8838; atms_of_mm (clauses S&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_vars_in_snd_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">]</span><span>  </span><span>atm_incl</span><span> </span><span>atm_incl&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S&#39;&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_distinct_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">]</span><span> </span><span>no_dup&#39;</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (lits_of_l (trail S&#39;&#39;))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cons&#39;</span><span> </span><span>no_dup&#39;</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_consistent_interp_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S &#8801;
  (all_decomposition_implies_m (clauses S) (get_all_ann_decomposition (trail S))
  &#8743; atm_of ` lits_of_l (trail S)  &#8838; atms_of_mm (clauses S)
  &#8743; consistent_interp (lits_of_l (trail S))
  &#8743; no_dup (trail S))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_dest</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;all_decomposition_implies_m (clauses S) (get_all_ann_decomposition (trail S))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S)  &#8838; atms_of_mm (clauses S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (lits_of_l (trail S)) &#8743; no_dup (trail S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_def</span><span> </span><span>lits_of_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rtranclp dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_def</span><span> </span><span>lits_of_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_inv_starting_from_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rtranclp dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S = []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_decomposition_implies_def</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_can_do_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (set M)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` (set M) &#8838; atms_of_mm N&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rtranclp dpll<span class="hidden">&#8681;</span><sub>W</sub> ([], N) (map Decided M, N)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>L</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;undefined_lit (map Decided M) L&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>defined_lit_def</span><span> </span><span>consistent_interp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of L &#8712; atms_of_mm N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub> (map Decided M, N) (map Decided (L # M), N)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.decided</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (set M)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct M&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` set M &#8838; atms_of_mm N&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_interp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;conclusive_dpll<span class="hidden">&#8681;</span><sub>W</sub>_state (S:: &#39;v dpll<span class="hidden">&#8681;</span><sub>W</sub>_state) &#10231;
  (trail S &#8872;asm clauses S &#8744; ((&#8704;L &#8712; set (trail S). &#172;is_decided L)
  &#8743; (&#8707;C &#8712;# clauses S. trail S &#8872;as CNot C)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\cwref{prop:prop:dpllcomplete}{theorem 2.8.6 page 74}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_strong_completeness</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set M &#8872;sm N&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp (set M)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` (set M) &#8838; atms_of_mm N&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ([], N) (map Decided M, N)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;conclusive_dpll<span class="hidden">&#8681;</span><sub>W</sub>_state (map Decided M, N)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rtranclp dpll<span class="hidden">&#8681;</span><sub>W</sub> ([], N) (map Decided M, N)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_can_do_step</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map Decided M &#8872;asm N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>true_annots_decided_true_cls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;conclusive_dpll<span class="hidden">&#8681;</span><sub>W</sub>_state (map Decided M, N)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conclusive_dpll<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\cwref{prop:prop:dpllsound}{theorem 2.8.5 page 73}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_sound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;rtranclp dpll<span class="hidden">&#8681;</span><sub>W</sub> ([], N) (M, N)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;S. &#172;dpll<span class="hidden">&#8681;</span><sub>W</sub> (M, N) S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M &#8872;asm N &#10231; satisfiable (set_mset N)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A &#10231; ?B&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M&#39;</span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lits_of_l M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?A</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?M&#39; &#8872;sm N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp ?M&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_inv_starting_from_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?B</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?B</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; ?A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;L. undefined_lit M L &#8743; atm_of L &#8712; atms_of_mm N) &#8744; (&#8707;D&#8712;#N. M &#8872;as CNot D)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a clause&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;D &#8712;# N&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; M &#8872;a D&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_def</span><span> </span><span>Ball_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;L. undefined_lit M L &#8743; atm_of L &#8712; atms_of D) &#8744; M &#8872;as CNot D&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_def</span><span> </span><span>Ball_def</span><span> </span><span>CNot_def</span><span> </span><span>true_annot_def</span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_of_lit_in_atms_of</span><span> </span><span>true_annot_iff_decided_or_true_lit</span><span> </span><span>true_cls_def</span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>mem_Collect_eq</span><span> </span><span>union_single_eq_member</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Bex_def</span><span> </span><span>D</span><span> </span><span>atms_of_atms_of_ms_mono</span><span> </span><span>rev_subsetD</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;L. undefined_lit M L &#8743; atm_of L &#8712; atms_of_mm N&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>decided</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;D&#8712;#N. M &#8872;as CNot D&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>DN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;D &#8712;# N&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>MD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M &#8872;as CNot D&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;l &#8712; set M. &#172; is_decided l&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv ([], N)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_decomposition_implies_def</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsatisfiable (set_mset N)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>only_propagated_vars_unsat</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span>D</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_mset N&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>DN</span><span> </span><span>MD</span><span>
</span><span>            </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?B&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;l &#8712; set M. is_decided l&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(M, N)&quot;</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>D</span><span> </span><span class="delimiter">]</span><span> </span><span>DN</span><span> </span><span>MD</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>              </span><span>backtrack_split_some_is_decided_then_snd_has_hd</span><span class="delimiter">[</span><span>OF</span><span> </span><span>l</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>backtrack_split_snd_hd_decided</span><span> </span><span>fst_conv</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Termination&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes M n =
  map (&#955;l. if is_decided l then 2 else (1::nat)) (rev M) @ replicate (n - length M) 3&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length M &#8804; n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes M n) = n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinctcard_atm_of_lit_of_eq_length</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (atm_of ` lits_of_l S) = length S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_image</span><span> </span><span>lits_of_def</span><span> </span><span>no_dup_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cons_lexn_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x # xs, y # ys) &#8712; lexn R n &#10231; (length (x # xs) = n &#8743; length (y # ys) = n &#8743;
         ((x,y) &#8712; R &#8744; (x = y &#8743; (xs, ys) &#8712; lexn R (n - 1))))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lexn_conv</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">;</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xys</span><span> </span><span>xa</span><span> </span><span>ya</span><span> </span><span>xs&#39;</span><span> </span><span>ys&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xys</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lexn_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lexn_conv</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>append_Cons</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>append_Cons</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>append_same_lexn</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>prepend_same_lexn</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>Cons_lexn_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>lexn.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_card_decrease</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>dpll</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (trail S&#39;) &#8804; card vars&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length (trail S) &#8804; card vars&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S&#39;) (card vars), dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S) (card vars)) &#8712; lexn less_than (card vars)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>C</span><span> </span><span>L</span><span> </span><span>S</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card vars - length (trail S) = Suc (card vars - Suc (length (trail S)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail (Propagated C () # trail S, clauses S)) (card vars),
         dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S) (card vars)) &#8712; lexn less_than (card vars)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>decided</span><span> </span><span>S</span><span> </span><span>L</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card vars - length (trail S) = Suc (card vars - Suc (length (trail S)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decided.prems</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_diff_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail (Decided L # trail S, clauses S)) (card vars),
         dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S) (card vars)) &#8712; lexn less_than (card vars)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack</span><span> </span><span>S</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S = M&#39; @ L # M&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail (Propagated (- lit_of L) () # M, clauses S)) (card vars),
         dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S) (card vars)) &#8712; lexn less_than (card vars)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\cwref{prop:prop:dpllterminating}{theorem 2.8.7 page 74}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_card_decrease&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>dpll</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>atm_incl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S) &#8838; atms_of_mm (clauses S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S&#39;) (card (atms_of_mm (clauses S&#39;))),
          dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S) (card (atms_of_mm (clauses S)))) &#8712; lex less_than&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (atms_of_mm (clauses S))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atms_of_ms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (trail S) &#8804; card (atms_of_mm (clauses S))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinctcard_atm_of_lit_of_eq_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>no_dup</span><span class="delimiter">]</span><span> </span><span>atm_incl</span><span> </span><span>card_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_dup&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_distinct_inv</span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clauses S&#39; = clauses S&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_same_clauses</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>atm_incl&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (trail S&#39;) &#8838; atms_of_mm (clauses S&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm_incl</span><span> </span><span>dpll</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_vars_in_snd_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dpll</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (atms_of_mm (clauses S&#39;))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atms_of_ms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (trail S&#39;) &#8804; card (atms_of_mm (clauses S))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinctcard_atm_of_lit_of_eq_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>no_dup&#39;</span><span class="delimiter">]</span><span> </span><span>atm_incl&#39;</span><span> </span><span>card_mono</span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S&#39;) (card (atms_of_mm (clauses S))),
      dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S) (card (atms_of_mm (clauses S))))
    &#8712; lexn less_than (card (atms_of_mm (clauses S)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_card_decrease</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atms_of_mm (clauses S)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S&#39;) (card (atms_of_mm (clauses S))),
          dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S) (card (atms_of_mm (clauses S)))) &#8712; lex less_than&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lex_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S&#39;) (card (atms_of_mm (clauses S&#39;))),
         dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S) (card (atms_of_mm (clauses S)))) &#8712; lex less_than&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_same_clauses</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_lexn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf (lexn {(a, b). (a::nat) &lt; b} (card (atms_of_mm (clauses S))))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{(a, b). a &lt; b} = measure id&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_lexn</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf {(S&#39;, S). dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S &#8743; dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_wf_if_measure&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_lex_less</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;S. dpll<span class="hidden">&#8681;</span><sub>W</sub>_mes (trail S) (card (atms_of_mm (clauses S)))&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_card_decrease&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_tranclp_star_commute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;{(S&#39;, S). dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S &#8743; dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;}<span class="hidden">&#8679;</span><sup>+</sup> = {(S&#39;, S). dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S &#8743; tranclp dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;}&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A = ?B&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>S</span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(S, S&#39;) &#8712; ?A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(S, S&#39;) &#8712; ?B&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>trancl.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A &#8838; ?B&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>S</span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(S, S&#39;) &#8712; ?B&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S&#39; S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(S, S&#39;) &#8712; ?A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tranclp.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>r_into_trancl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>r_into_trancl&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>trancl_into_trancl</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span> </span><span>S&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(S&#39;, S) &#8712; {a. case a of (S&#39;, S) &#8658; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S &#8743; dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;}<span class="hidden">&#8679;</span><sup>+</sup>&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tranclp_into_rtranclp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trancl_into_trancl.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span>trancl_into_trancl.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(S&#39;&#39;, S&#39;) &#8712; {(pa, p). dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv p &#8743; dpll<span class="hidden">&#8681;</span><sub>W</sub> p pa}<span class="hidden">&#8679;</span><sup>+</sup>&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S&#39;&#8250;</span></span></span><span> </span><span>trancl_into_trancl.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, S) &#8712; {a. case a of (S&#39;, S) &#8658; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S &#8743; dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;}<span class="hidden">&#8679;</span><sup>+</sup>&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?B &#8838; ?A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_dpll<span class="hidden">&#8681;</span><sub>W</sub>_tranclp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf {(S&#39;, S). dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S &#8743; dpll<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S S&#39;}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_tranclp_star_commute</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wf_dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span>wf_trancl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_dpll<span class="hidden">&#8681;</span><sub>W</sub>_plus</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf {(S&#39;, ([], N))| S&#39;. dpll<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> ([], N) S&#39;}&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf ?P&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_dpll<span class="hidden">&#8681;</span><sub>W</sub>_tranclp</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?P</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Final States&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Proposition 2.8.1: final states are the normal forms of @{term dpll<span class="hidden">&#8681;</span><sub>W</sub>}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_no_more_step_is_a_conclusive_state</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;S&#39;. &#172;dpll<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;conclusive_dpll<span class="hidden">&#8681;</span><sub>W</sub>_state S&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>vars</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s &#8712; atms_of_mm (clauses S). s &#8712; atm_of ` lits_of_l (trail S)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; (&#8704;s&#8712;atms_of_mm (clauses S). s &#8712; atm_of ` lits_of_l (trail S))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>L_in_atms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;L &#8712; atms_of_mm (clauses S)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>L_notin_trail</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;L &#8713; atm_of ` lits_of_l (trail S)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>L&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of L&#39; = L&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>literal.sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;undefined_lit (trail S) L&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>L_notin_trail</span><span> </span><span>atm_of_uminus</span><span> </span><span>imageI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.decided</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>L_in_atms</span><span> </span><span>L&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>not_final</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; ?thesis&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; trail S &#8872;asm clauses S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;L&#8712;set (trail S). is_decided L) &#8744; (&#8704;C&#8712;#clauses S. &#172;trail S &#8872;as CNot C)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conclusive_dpll<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;L&#8712;set (trail S). is_decided L&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span>M&#39;</span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;backtrack_split (trail S) = (M&#39;, L # M)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_split_some_is_decided_then_snd_has_hd</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;D &#8712;# clauses S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; trail S &#8872;a D&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; trail S &#8872;asm clauses S&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;atms_of_ms {D}. s &#8712; atm_of ` lits_of_l (trail S)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atms_of_ms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S &#8872;as CNot D&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_variables_defined_not_imply_cnot</span><span class="delimiter">[</span><span>of</span><span> </span><span>D</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; trail S &#8872;a D&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_decided L&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>backtrack_split_snd_hd_decided</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.backtrack</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# clauses S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot D&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>tr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;C&#8712;#clauses S. &#172;trail S &#8872;as CNot C&quot;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C_in_cls</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;C &#8712;# clauses S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trC</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; trail S &#8872;a C&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; trail S &#8872;asm clauses S&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;atms_of_ms {C}. s &#8712; atm_of ` lits_of_l (trail S)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# clauses S&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atms_of_ms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail S &#8872;as CNot C&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>C_in_cls</span><span> </span><span>tr</span><span> </span><span>trC</span><span> </span><span>all_variables_defined_not_imply_cnot</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tr</span><span> </span><span>C_in_cls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_conclusive_state_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dpll<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ([], N) (M, N)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;conclusive_dpll<span class="hidden">&#8681;</span><sub>W</sub>_state (M, N)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M &#8872;asm N &#10231; satisfiable (set_mset N)&quot;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?A &#10231; ?B&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M&#39;</span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lits_of_l M&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?A</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?M&#39; &#8872;sm N&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;consistent_interp ?M&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_inv_starting_from_0</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?B</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?B</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?A</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; ?A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_mark</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;L&#8712;set M. &#172; is_decided L&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;C &#8712;# N. M &#8872;as CNot C&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conclusive_dpll<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>DN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;D &#8712;# N&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>MD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;M &#8872;as CNot D&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_mark</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unsatisfiable (set_mset N)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>only_propagated_vars_unsat</span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?B&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2018 </td><td align="center">26d8aaa66074 </td><td align="center">24d4e5b9 </td><td align="center">Tue 06 Nov 2018 04:20:56 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


