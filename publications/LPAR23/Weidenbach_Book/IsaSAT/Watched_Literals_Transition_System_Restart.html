<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Watched_Literals_Transition_System_Restart (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Watched_Literals_Transition_System_Restart</h1>

<span class="command">theory</span> <span class="name">Watched_Literals_Transition_System_Restart</span><br/>
<span class="keyword">imports</span> <a href="../Watched_Literals/Watched_Literals_Transition_System.html"><span class="name">Watched_Literals_Transition_System</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Watched_Literals_Transition_System_Restart</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Watched_Literals.Watched_Literals_Transition_System</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Unlike the basic CDCL, it does not make any sense to fully restart the trail:
  the part propagated at level 0 (only the part due to unit clauses) has to be kept.
  Therefore, we allow fast restarts (i.e. a restart where part of the trail is reused).

  There are two cases:
    &#9642; either the trail is strictly decreasing;
    &#9642; or it is kept and the number of clauses is strictly decreasing.

  This ensures that &#8727;&#8249;something&#8250; changes to prove termination.

  In practice, there are two types of restarts that are done:
    &#9642; First, a restart can be done to enforce that the SAT solver goes more into the direction
      expected by the decision heuristics.
    &#9642; Second, a full restart can be done to simplify inprocessing and garbage collection of the memory:
      instead of properly updating the trail, we restart the search. This is not necessary (i.e.,
      glucose and minisat do not do it), but it simplifies the proofs by allowing to move clauses
      without taking care of updating references in the trail. Moreover, as this happens ``rarely&#39;&#39;
      (around once every few thousand conflicts), it should not matter too much.

  Restarts are the ``local search&#39;&#39; part of all modern SAT solvers.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>cdcl_twl_restart</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v twl_st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>restart_trail</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart (M, N, U, None, NE, UE, {#}, Q)
        (M&#39;, N&#39;, U&#39;, None, NE + clauses NE&#39;, UE + clauses UE&#39;, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided K # M&#39;, M2) &#8712; set (get_all_ann_decomposition M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; + UE&#39; &#8838;# U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N = N&#39; + NE&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;E&#8712;#NE&#39;+UE&#39;. &#8707;L&#8712;#clause E. L &#8712; lits_of_l M&#39; &#8743; get_level M&#39; L = 0&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L E. Propagated L E &#8712; set M&#39; &#10230; E &#8712;# clause `# (N + U&#39;) + NE + UE + clauses UE&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>restart_clauses</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart (M, N, U, None, NE, UE, {#}, Q)
      (M, N&#39;, U&#39;, None, NE + clauses NE&#39;, UE + clauses UE&#39;, {#}, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; + UE&#39; &#8838;# U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N = N&#39; + NE&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;E&#8712;#NE&#39;+UE&#39;. &#8707;L&#8712;#clause E. L &#8712; lits_of_l M &#8743; get_level M L = 0&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L E. Propagated L E &#8712; set M &#10230; E &#8712;# clause `# (N + U&#39;) + NE + UE + clauses UE&#39;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>cdcl_twl_restartE</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart S T&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart S V&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;T. cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) T &#8743; cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T (state<span class="hidden">&#8681;</span><sub>W</sub>_of V) &#8743;
      cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of V)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_restart.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>restart_trail</span><span> </span><span>K</span><span> </span><span>M&#39;</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>U&#39;</span><span> </span><span>UE&#39;</span><span> </span><span>U</span><span> </span><span>N</span><span> </span><span>N&#39;</span><span> </span><span>NE&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>learned</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>has_true</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kept</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stgy_invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, None, NE, UE, {#}, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], clause `# N + NE, clause `# U&#39; + UE + clauses UE&#39;, None)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, N, U&#39;, None, NE, UE + clauses UE&#39;, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>restart</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) ?T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart.simps</span><span> </span><span>state_def</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">:</span><span> </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ + _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>clause</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_mset_union</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_invs</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_propa</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>drop_M_M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (length M - length M&#39;) M = M&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ?T
      (drop (length M - length M&#39;) M, clause `# N + NE, clause `# U&#39; + UE + clauses UE&#39;, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>after_fast_restart_replay</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# N + NE&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# U+UE&#8250;</span></span></span><span> </span><span>_</span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# U&#39; + UE +clauses UE&#39;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stgy_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_stgy_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller_propa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kept</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>drop_M_M&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ + _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>clause</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_mset_union</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ?T (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?V)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>drop_M_M&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?V)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restart</span><span> </span><span>st</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_rf.intros</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart.intros</span><span>
</span><span>          </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restart</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>N</span><span> </span><span>state<span class="hidden">&#8681;</span><sub>W</sub>_of.simps</span><span> </span><span>image_mset_union</span><span> </span><span>add.assoc</span><span>
</span><span>      </span><span>add.commute</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses NE&#39;&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>restart_clauses</span><span> </span><span>U&#39;</span><span> </span><span>UE&#39;</span><span> </span><span>U</span><span> </span><span>N</span><span> </span><span>N&#39;</span><span> </span><span>NE&#39;</span><span> </span><span>M</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>learned</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>has_true</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kept</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stgy_invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, None, NE, UE, {#}, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], clause `# N + NE, clause `# U&#39; + UE + clauses UE&#39;, None)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U&#39;, None, NE, UE + clauses UE&#39;, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>restart</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) ?T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart.simps</span><span> </span><span>state_def</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ + _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>clause</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_mset_union</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_invs</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, None, NE, UE, {#}, Q))&#8250;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_propa</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa (state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, None, NE, UE, {#}, Q))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ?T
      (drop (length M - length M) M, clause `# N + NE, clause `# U&#39; + UE+ clauses UE&#39;, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>after_fast_restart_replay</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# N + NE&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# U+UE&#8250;</span></span></span><span> </span><span>_</span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# U&#39; + UE + clauses UE&#39;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stgy_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_stgy_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller_propa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kept</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ + _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>clause</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_mset_union</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ?T (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?V)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?V)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restart</span><span> </span><span>st</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_rf.intros</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart.intros</span><span>
</span><span>          </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restart</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>N</span><span> </span><span>state<span class="hidden">&#8681;</span><sub>W</sub>_of.simps</span><span> </span><span>image_mset_union</span><span> </span><span>add.assoc</span><span>
</span><span>      </span><span>add.commute</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses NE&#39;&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart S V&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;T. cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) T &#8743; cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T (state<span class="hidden">&#8681;</span><sub>W</sub>_of V)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_restart.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>restart_trail</span><span> </span><span>K</span><span> </span><span>M&#39;</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>U&#39;</span><span> </span><span>UE&#39;</span><span> </span><span>U</span><span> </span><span>N</span><span> </span><span>N&#39;</span><span> </span><span>NE&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>learned</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>has_true</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kept</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, None, NE, UE, {#}, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], clause `# N + NE, clause `# U&#39; + UE + clauses UE&#39;, None)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, N, U&#39;, None, NE, UE + clauses UE&#39;, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>restart</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) ?T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart.simps</span><span> </span><span>state_def</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>        </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ + _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>clause</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_mset_union</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_invs</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, None, NE, UE, {#}, Q))&#8250;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_propa</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa (state<span class="hidden">&#8681;</span><sub>W</sub>_of (M, N, U, None, NE, UE, {#}, Q))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>drop_M_M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (length M - length M&#39;) M = M&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ?T
      (drop (length M - length M&#39;) M, clause `# N + NE, clause `# U&#39; + UE+ clauses UE&#39;, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>after_fast_restart_replay_no_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# N + NE&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# U+UE&#8250;</span></span></span><span> </span><span>_</span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# U&#39; + UE + clauses UE&#39;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kept</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>drop_M_M&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ + _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>clause</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_mset_union</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ?T (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?V)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>drop_M_M&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restart</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>restart_clauses</span><span> </span><span>U&#39;</span><span> </span><span>UE&#39;</span><span> </span><span>U</span><span> </span><span>N</span><span> </span><span>N&#39;</span><span> </span><span>NE&#39;</span><span> </span><span>M</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>learned</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>has_true</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kept</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, None, NE, UE, {#}, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], clause `# N + NE, clause `# U&#39; + UE + clauses UE&#39;, None)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?V</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U&#39;, None, NE, UE + clauses UE&#39;, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>restart</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) ?T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart.simps</span><span> </span><span>state_def</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>        </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ + _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>clause</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_mset_union</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_invs</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_propa</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ?T
      (drop (length M - length M) M, clause `# N + NE, clause `# U&#39; + UE+ clauses UE&#39;, None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>after_fast_restart_replay_no_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# N + NE&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# U+UE&#8250;</span></span></span><span> </span><span>_</span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# U&#39; + UE+ clauses UE&#39;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>kept</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ + _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>clause</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_mset_union</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ?T (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?V)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>restart</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_restart_twl_struct_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_restart.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>restart_trail</span><span> </span><span>K</span><span> </span><span>M&#39;</span><span> </span><span>M2</span><span> </span><span>M</span><span> </span><span>U&#39;</span><span> </span><span>UE&#39;</span><span> </span><span>U</span><span> </span><span>N</span><span> </span><span>N&#39;</span><span> </span><span>NE&#39;</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>learned&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>has_true</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kept</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inv</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, None, NE, UE, {#}, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, N&#39;, U&#39;, None, NE+ clauses NE&#39;, UE + clauses UE&#39;, {#}, {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; &#8838;# U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mset_le_decr_left1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>twl_st_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv
      (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa
      (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_queued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict ?S &#8800; None &#10230;
     clauses_to_update ?S = {#} &#8743;
     literals_to_update ?S = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>to_upd</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>past</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarify</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>ex</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8704;C&#8712;#N + U. twl_lazy_update M&#39; C &#8743;
           watched_literals_false_of_max_level M&#39; C &#8743;
           twl_exception_inv (M&#39;, N, U, None, NE, UE, {#}, {#}) C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>conf_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued (M&#39;, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>propa_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued (M&#39;, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>clss_to_upd</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv (M&#39;, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>excp_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv (M&#39;, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_exception_inv.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>twl_st_inv&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv (M&#39;, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex</span><span> </span><span>learned</span><span> </span><span>twl_st_inv</span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_st_exception_inv.simps</span><span> </span><span>twl_st_inv.simps</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>       </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided K # M&#39;&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M3&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M3&#39; = M3 @ M2&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M3&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3&#39; @ Decided K # M&#39;&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>entailed_clss_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv ?S&#39;&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailed_clss_inv.simps</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE + clauses NE&#39; + (UE + clauses UE&#39;)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; lits_of_l M &#8743; get_level M L = 0 &#10233;L &#8712; lits_of_l M&#39; &#8743; get_level M&#39; L = 0&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M3&#39; L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>M3&#39;</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>get_level_cons_if</span><span>
</span><span>           </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>       </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M&#39; L = 0&#8250;</span></span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; lits_of_l M&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# C&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span>has_true</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; lits_of_l M&#39;&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit M3&#39; L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M3&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span>
</span><span>           </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M&#39; L = 0&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit M3&#39; L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>lev_L</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M3&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span>
</span><span>           </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_lits_of_l_defined_litD</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;L. L &#8712;# C &#8743;
             (None = None &#8744; 0 &lt; count_decided M&#39; &#10230;
              get_level M&#39; L = 0 &#8743; L &#8712; lits_of_l M&#39;)&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N &#8838;# N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>NN&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#39; &#8838;# N&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>past_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs ?S&#39;&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>K&#39;</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>H</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; = M2 @ Decided K&#39; # M1&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M1, N&#39;, U&#39;, None, NE+clauses NE&#39;, UE+clauses UE&#39;, {#}, {#})&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = (M3&#39; @ Decided K # M2) @ Decided K&#39; # M1&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>M3&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>       </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C&#8712;#N + U.
           twl_lazy_update M1 C &#8743;
           watched_literals_false_of_max_level M1 C &#8743;
           twl_exception_inv ?U C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued ?U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>4</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?U&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C&#8712;#N&#39; + U&#39;.
          twl_lazy_update M1 C &#8743;
          watched_literals_false_of_max_level M1 C &#8743;
          twl_exception_inv ?U&#39; C&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>learned</span><span> </span><span>twl_st_exception_inv_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>M1</span><span> </span><span>None</span><span> </span><span>NE</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;UE&#8250;</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#}&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#}&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;NE+clauses NE&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;UE+clauses UE&#39;&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>N</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?U&#39;&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cands_enqueued_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued ?U&#39;&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa_cands_enqueued_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>3</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?U&#39;&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>4</span><span> </span><span>learned</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>filter_mset_empty_conv</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clss_to_upd</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?S&#39;&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clss_to_upd</span><span> </span><span>learned</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>filter_mset_empty_conv</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub> &#8804; cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span>res</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>res&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T&#39; (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S&#39;)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_twl_restart.restart_trail</span><span class="delimiter">[</span><span>OF</span><span> </span><span>restart_trail</span><span class="delimiter">(</span><span>1</span><span>-</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>inv</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)
       (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S&#39;)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span class="delimiter">]</span><span>
</span><span>       </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart.intros</span><span>
</span><span>         </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_rf.intros</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>struct_inv</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv&#39;</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of (M&#39;, N&#39;, U&#39;, None, NE+ clauses NE&#39;, UE+ clauses UE&#39;, {#}, {#}))&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>smaller&#39;</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa (state<span class="hidden">&#8681;</span><sub>W</sub>_of (M&#39;, N&#39;, U&#39;, None, NE+ clauses NE&#39;, UE+ clauses UE&#39;, {#}, {#}))&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller</span><span> </span><span>mset_subset_eqD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned&#39;</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa_def</span><span> </span><span>M3&#39;</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>         </span><span>clauses_def</span><span> </span><span>ac_simps</span><span> </span><span>N</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO Proof *)</span></span></span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_eq_appendI</span><span> </span><span>append_assoc</span><span> </span><span>image_eqI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_eq_appendI</span><span> </span><span>append_assoc</span><span> </span><span>image_eqI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_inv_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>twl_st_inv&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>struct_inv&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>smaller&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_exception_inv_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>excp_inv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup_q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cands_enqueued_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>conf_cands</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa_cands_enqueued_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>propa_cands</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>entailed_clss_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>clss_to_upd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>past_invs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>restart_clauses</span><span> </span><span>U&#39;</span><span> </span><span>UE&#39;</span><span> </span><span>U</span><span> </span><span>N</span><span> </span><span>N&#39;</span><span> </span><span>NE&#39;</span><span> </span><span>M</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>learned&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>has_true</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kept</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N, U, None, NE, UE, {#}, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, N&#39;, U&#39;, None, NE+clauses NE&#39;, UE + clauses UE&#39;, {#}, Q)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; &#8838;# U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mset_le_decr_left1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>twl_st_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>valid</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv
      (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa
      (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>excp_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_exception_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup_q</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_duplicate_queued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_queued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>propa_cands</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict ?S &#8800; None &#10230;
     clauses_to_update ?S = {#} &#8743;
     literals_to_update ?S = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>unit</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>to_upd</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>past</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarify</span><span class="delimiter">+</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U&#39; &#8838;# U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>       </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail.simps</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>valid&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;valid_enqueued ?T&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>valid</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>entailed_clss_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;entailed_clss_inv ?T&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>entailed_clss_inv.simps</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# NE + clauses NE&#39; + (UE + clauses UE&#39;)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>       </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = 0&#8250;</span></span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; lits_of_l M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# C&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit</span><span> </span><span>has_true</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;L. L &#8712;# C &#8743;
             (None = None &#8744; 0 &lt; count_decided M &#10230;
              get_level M L = 0 &#8743; L &#8712; lits_of_l M)&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>NN&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#39; &#8838;# N&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>N</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>past_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;past_invs (M, N&#39;, U&#39;, None, NE+clauses NE&#39;, UE + clauses UE&#39;, {#}, Q)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>past</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>K&#39;</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>H</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M2 @ Decided K&#39; # M1&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M1, N, U, None, NE, UE, {#}, {#})&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?U&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M1, N&#39;, U&#39;, None, NE+clauses NE&#39;, UE + clauses UE&#39;, {#}, {#})&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>       </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C&#8712;#N + U.
           twl_lazy_update M1 C &#8743;
           watched_literals_false_of_max_level M1 C &#8743;
           twl_exception_inv ?U C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued ?U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>4</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?U&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>past</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>past_invs.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C&#8712;#N&#39; + U&#39;.
          twl_lazy_update M1 C &#8743;
          watched_literals_false_of_max_level M1 C &#8743;
          twl_exception_inv ?U&#39; C&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>learned</span><span> </span><span>twl_st_exception_inv_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>M1</span><span> </span><span>None</span><span> </span><span>NE</span><span> </span><span>UE</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#}&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#}&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>N</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;confl_cands_enqueued ?U&#39;&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cands_enqueued_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_cands_enqueued ?U&#39;&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa_cands_enqueued_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>3</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?U&#39;&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>4</span><span> </span><span>learned</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>filter_mset_empty_conv</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub> &#8804; cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clss_to_upd</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_inv ?T&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>to_upd</span><span> </span><span>learned</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>filter_mset_empty_conv</span><span> </span><span>N</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span>res</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.restart (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S) T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>res&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T&#39; (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_twl_restart.restart_clauses</span><span class="delimiter">[</span><span>OF</span><span> </span><span>restart_clauses</span><span class="delimiter">(</span><span>1</span><span>-</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>invs</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?S)
       (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span class="delimiter">]</span><span>
</span><span>       </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart.intros</span><span>
</span><span>         </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_rf.intros</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>struct_inv</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_inv&#39;</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>smaller&#39;</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa (state<span class="hidden">&#8681;</span><sub>W</sub>_of ?T)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller</span><span> </span><span>mset_subset_eqD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned&#39;</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>         </span><span>clauses_def</span><span> </span><span>N</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_inv_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>twl_st_inv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>struct_inv&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>smaller&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl_st_exception_inv_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>excp_inv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup_q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_cands_enqueued_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>confl_cands</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa_cands_enqueued_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>learned</span><span> </span><span>NN&#39;</span><span> </span><span>propa_cands</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>entailed_clss_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>clss_to_upd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>past_invs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_restart_twl_struct_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_restart_twl_struct_invs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_restart_twl_stgy_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_restart.induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_stgy_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant_def</span><span>
</span><span>    </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict_non_zero_unless_level_0_def</span><span>
</span><span>      </span><span>conflicting.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_confl_def</span><span> </span><span>clauses_def</span><span> </span><span>trail.simps</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_restart_twl_stgy_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_restart_twl_stgy_invs</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>twl_restart_ops</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>cdcl_twl_stgy_restart</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#215; nat &#8658; &#39;v twl_st &#215; nat &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>restart_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (S, n) (U, Suc n)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (get_learned_clss T) &gt; f n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart T U&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>restart_full</span><span class="delimiter">:</span><span>
</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (S, n) (T, n)&#8250;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full1 cdcl_twl_stgy S T&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_init_clss</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_init_clss (fst S) = get_all_init_clss (fst T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;induction rule: cdcl_twl_stgy_restart.induct&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>full1_def</span><span> </span><span>cdcl_twl_restart.simps</span><span>
</span><span>     </span><span>dest</span><span class="delimiter">:</span><span> </span><span>rtranclp_cdcl_twl_stgy_all_learned_diff_learned</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>tranclp_into_rtranclp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_init_clss</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_init_clss (fst S) = get_all_init_clss (fst T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;induction rule: rtranclp_induct&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>full1_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart_init_clss</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>full1_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp_cdcl_twl_stgy_twl_struct_invs</span><span> </span><span>tranclp_into_rtranclp</span><span>
</span><span>      </span><span>cdcl_twl_restart_twl_struct_invs</span><span> </span><span>rtranclp_cdcl_twl_stgy_twl_stgy_invs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_twl_stgy_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs (fst S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs (fst T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>full1_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>tranclp_into_rtranclp</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_restart_twl_stgy_invs</span><span> </span><span>rtranclp_cdcl_twl_stgy_twl_stgy_invs</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_cdcl_twl_stgy_restart_cdcl_twl_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_twl_stgy_restart S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_twl_stgy (fst S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy (fst S) T&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>cdcl_twl_stgy_twl_struct_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full (&#955;S T. twl_struct_invs S &#8743; cdcl_twl_stgy S T) T U&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_exists_normal_form_full</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_cdcl_twl_stgy</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl_twl_stgy T U&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;S T. twl_struct_invs S &#8743; cdcl_twl_stgy S T)<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step (&#955;U V. twl_struct_invs U &#8743; cdcl_twl_stgy U V) U&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T U&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_twl_stgy U&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ns</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs T&#8250;</span></span></span><span> </span><span>calculation</span><span> </span><span>rtranclp_cdcl_twl_stgy_twl_struct_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full1 cdcl_twl_stgy (fst S) U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>full_fullI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ns</span><span> </span><span>cdcl_twl_stgy_restart.intros</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst S&#8250;</span></span></span><span> </span><span>U</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>substract_left_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(a :: nat) + b &lt; c ==&gt; a &lt;= c - b&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>conflict_driven_clause_learning<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">)</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_new_learned_in_all_simple_clss</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> R S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>invR</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv R&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (learned_clss S) &#8838; simple_clss (atms_of_mm (init_clss S))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# learned_clss S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span> </span><span>invR</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_strange_atm S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of C &#8838; atms_of_mm (init_clss S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_strange_atm_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span>distinct_mset_set_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; tautology C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invS</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712; simple_clss (atms_of_mm (init_clss S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>simple_clss_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>learned_clss_get_all_learned_clss</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) = get_all_learned_clss S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>learned_clss.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_new_learned_in_all_simple_clss</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> R S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>invR</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst R)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (clauses (get_learned_clss (fst S))) &#8838;
     simple_clss (atms_of_mm (get_all_init_clss (fst S)))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# clauses (get_learned_clss (fst S))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invR</span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_twl_struct_invs</span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of C &#8838; atms_of_mm (get_all_init_clss (fst S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span>distinct_mset_set_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; tautology C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invS</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712; simple_clss (atms_of_mm (get_all_init_clss (fst S)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>simple_clss_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_new</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (get_all_learned_clss (fst S) - A)&#8250;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (get_all_learned_clss (fst T) - A)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induction</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>restart_step</span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span>n</span><span> </span><span>U</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>st</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>res</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_learned_clss U &#8838;# get_all_learned_clss T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_restart.simps</span><span>
</span><span>     </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ + _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>clause</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_mset_union</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_learned_clss U - A &#8838;#
          learned_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) - A&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mset_le_subtract</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>U</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>learned_clss.simps</span><span> </span><span>ac_simps</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>distinct_mset_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_learned_clss U - get_all_learned_clss S&#8250;</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) - learned_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of S)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>invs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (learned_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) - A)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset_clauses_new_abs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>fst_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>fst_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fst_conv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>distinct_mset_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>restart_full</span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>st</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>invs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dist</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>invs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (learned_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of T) - A)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset_clauses_new_abs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>fst_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>fst_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>S</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>learned_clss.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_new_abs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (get_all_learned_clss (fst S) - A)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (get_all_learned_clss (fst T) - A)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart_new</span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>twl_restart</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>wf_cdcl_twl_stgy_restart</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S :: &#39;v twl_st &#215; nat). twl_struct_invs (fst S) &#8743; cdcl_twl_stgy_restart S T}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; &#39;v twl_st &#215; nat&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>g</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;i. cdcl_twl_stgy_restart (g i) (g (Suc i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;i. twl_struct_invs (fst (g i))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_iff_no_infinite_down_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_twl_stgy (fst (g i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_restart.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>full1_def</span><span> </span><span>tranclp_unfold_begin</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd_g</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (g i) = i + snd (g 0)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc i&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart.simps</span><span> </span><span>full1_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd_g_0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;i. i &gt; 0 &#10233; snd (g i) = i + snd (g 0)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unbounded_f_g</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unbounded (&#955;i. f (snd (g i)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bounded_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add.commute</span><span> </span><span>f</span><span> </span><span>less_or_eq_imp_le</span><span> </span><span>snd_g</span><span>
</span><span>        </span><span>not_bounded_nat_exists_larger</span><span> </span><span>not_le</span><span> </span><span>le_iff_add</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;h. cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (fst (g i)) (h) &#8743;
         size (get_all_learned_clss (h)) &gt; f (snd (g i)) &#8743;
         cdcl_twl_restart (h) (fst (g (i+1)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc i&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_restart.simps</span><span> </span><span>full1_def</span><span> </span><span>Suc_eq_plus1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; &#39;v twl_st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>cdcl_twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (fst (g i)) (h i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>size_h_g</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (get_all_learned_clss (h i)) &gt; f (snd (g i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>res</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_restart (h i) (fst (g (i+1)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>f_g_k</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f (snd (g k)) &gt;
       card (simple_clss (atms_of_mm (init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h 0))))) +
           size (get_all_learned_clss (fst (g 0)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_bounded_nat_exists_larger</span><span class="delimiter">[</span><span>OF</span><span> </span><span>unbounded_f_g</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cdcl_twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (fst (g i)) (h i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>W_g_h</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst (g i))) (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_twl</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tranclp_g</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (g 0) (g i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_all_g</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (get_all_learned_clss (fst (g i)) - get_all_learned_clss (fst (g 0)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_new_abs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>tranclp_g</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_h</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (get_all_learned_clss (h i) - get_all_learned_clss (fst (g 0)))&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (?U i)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>learned_clss_get_all_learned_clss</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset_clauses_new_abs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>W_g_h</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist_all_g</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>distinct_mset_minus</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>learned_clss_get_all_learned_clss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_diff</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (c + (Ca + C) - ai) &#10233;
       distinct_mset (c - ai)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>c</span><span> </span><span>Ca</span><span> </span><span>C</span><span> </span><span>ai</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_right&#39;</span><span> </span><span>cancel_ab_semigroup_add_class.diff_right_commute</span><span>
</span><span>        </span><span>distinct_mset_minus</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_learned_clss (fst (g (Suc i))) &#8838;# get_all_learned_clss (h i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_restart.simps</span><span>
</span><span>      </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ + _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>clause</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_mset_union</span><span class="delimiter">]</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>mset_le_decr_left1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h_g</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h i)) = init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst (g i)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_more_init_clss</span><span class="delimiter">[</span><span>OF</span><span> </span><span>W_g_h</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h_g_Suc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h i)) = init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst (g (Suc i))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_restart.simps</span><span> </span><span>init_clss.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>init_g_0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst (g i))) = init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst (g 0)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>j</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h_g</span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span class="delimiter">]</span><span> </span><span>h_g_Suc</span><span class="delimiter">[</span><span>of</span><span> </span><span>j</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h i)) = init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst (g 0)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h_g</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>incl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (get_all_learned_clss (h i)) &#8838;
         simple_clss (atms_of_mm (init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h i))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>learned_clss_get_all_learned_clss</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>unify_trace_failure</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_new_learned_in_all_simple_clss</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst (g i))&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_twl</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>incl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (get_all_learned_clss (h i)) &#8838;
         simple_clss (atms_of_mm (init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h i))))&#8250;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (?V i) &#8838; _&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>incl</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;h i&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>incl_init</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (?U i) &#8838; simple_clss (atms_of_mm (init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h i))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>incl</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>size_U_atms</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (?U i) &#8804; card (simple_clss (atms_of_mm (init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h i)))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_mset_size_eq_card</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dist_h</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>incl_init</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (?V i) - size (get_all_learned_clss (fst (g 0))) &#8804;
      card (simple_clss (atms_of_mm (init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h i)))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>diff_size_le_size_Diff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>size_U_atms</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (?V i) &#8804;
      card (simple_clss (atms_of_mm (init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h i))))) +
       size (get_all_learned_clss (fst (g 0)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card (simple_clss (atms_of_mm (init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of (h k))))) +
         size (get_all_learned_clss (fst (g 0))) &gt; f (k + snd (g 0))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span>size_h_g</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snd_g</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span>f_g_k</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>snd_g</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>K</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart &#8801; (&#955;(S, n). (state<span class="hidden">&#8681;</span><sub>W</sub>_of S, n))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>twl_restart_ops</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; twl_struct_invs S &#10233;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of S, n) (state<span class="hidden">&#8681;</span><sub>W</sub>_of T, n)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span>
</span><span>     </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart S T &#10233; twl_struct_invs (fst S) &#10233;  twl_stgy_invs (fst S) &#10233;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span>n</span><span> </span><span>U</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy.intros</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart(T, n)&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(_, Suc n)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of U&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc n&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>       </span><span>cdcl_twl_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span> </span><span>U</span><span class="delimiter">]</span><span>
</span><span>       </span><span>rtranclp_cdcl_twl_stgy_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>       </span><span>rtranclp_cdcl_twl_stgy_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>tranclp_into_rtranclp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>r_into_rtranclp</span><span> </span><span>rtranclp_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>       </span><span>rtranclp_cdcl_twl_stgy_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>       </span><span>rtranclp_cdcl_twl_stgy_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>tranclp_into_rtranclp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>full1_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_twl_stgy_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs (fst S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs (fst T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart_twl_stgy_invs</span><span>
</span><span>        </span><span>rtranclp_cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; twl_struct_invs (fst S) &#10233;  twl_stgy_invs (fst S) &#10233;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>U</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>       </span><span>rtranclp_cdcl_twl_stgy_restart_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>       </span><span>cdcl_twl_stgy_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span> </span><span>U</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>tranclp_into_rtranclp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>twl_restart_ops</span><span class="delimiter">)</span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_with_leftovers S U &#10231;
     (&#8707;T. cdcl_twl_stgy_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S (T, snd U) &#8743; cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T (fst U))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_cdcl_twl_stgy_cdcl_twl_stgy_restart</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (T, m) (V, Suc m) &#10233;
       cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; cdcl_twl_stgy_restart (S, m) (V, Suc m)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>cdcl_twl_stgy_restart.simps</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart.intros</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>rtranclp_tranclp_tranclp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_cdcl_twl_stgy_cdcl_twl_stgy_restart2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (T, m) (V, m) &#10233;
       cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; cdcl_twl_stgy_restart (S, m) (V, m)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>cdcl_twl_stgy_restart.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart.intros</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>rtranclp_tranclp_tranclp</span><span> </span><span>rtranclp_full1I</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_with_leftovers1 S U &#10231;
     cdcl_twl_stgy_restart S U &#8744;
     (cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (fst S) (fst U) &#8743; snd S = snd U)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>twl_restart</span><span class="delimiter">)</span><span> </span><span>wf_cdcl_twl_stgy_restart_with_leftovers1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T :: &#39;v twl_st &#215; nat, S).
        twl_struct_invs (fst S) &#8743; cdcl_twl_stgy_restart_with_leftovers1 S T}&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?S&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; &#39;v twl_st &#215; nat&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>g</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;i. cdcl_twl_stgy_restart_with_leftovers1 (g i) (g (Suc i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;i. twl_struct_invs (fst (g i))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_iff_no_infinite_down_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;no_step cdcl_twl_stgy (fst (g i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers1_def</span><span>
</span><span>        </span><span>cdcl_twl_stgy_restart.simps</span><span> </span><span>full1_def</span><span> </span><span>tranclp_unfold_begin</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>h</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;h &#8801; rec_nat (g 0) (&#955;i Si. g (SOME k. cdcl_twl_stgy_restart Si (g k)))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;h 0 = g 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (fst (g i)) (fst (g (Suc (i + k)))) &#8743;
         cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (fst (g (i + k))) (fst (g (Suc (i + k)))) &#8743;
         snd (g (Suc (i + k))) = snd (g i)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; j&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;k. k &#8804; j &#10233; &#172;cdcl_twl_stgy_restart (g i) (g (Suc i + k))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>j</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>j</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;k. k &lt; j &#10233;
         cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (fst (g i)) (fst (g (Suc (i + k)))) &#8743;
         cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (fst (g (i + k))) (fst (g (Suc (i + k)))) &#8743;
         snd (g (Suc (i + k))) = snd (g i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; Suc j&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;k. k &#8804; Suc j &#10233; &#172; cdcl_twl_stgy_restart (g i) (g (Suc i + k))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k = j&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; Suc j&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>        </span><span class="delimiter">(</span><span>res</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (g ( (i+k))) (g ((Suc (i+k))))&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="delimiter">(</span><span>stgy</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (fst (g ((i+k)))) (fst (g ((Suc (i+k)))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (g (Suc (i + k))) = snd (g (i + k))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i+k&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers1_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>stgy</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k - 1&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; j&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>res</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Sucg</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (snd (g ((i + k)))) = snd (g (Suc ((i + k))))&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res</span><span>
</span><span>            </span><span>ns</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc ((i + k))&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart.simps</span><span> </span><span>full1_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (g i) (g (Suc (i + k)))&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k - 1&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>            </span><span>res</span><span> </span><span>cdcl_twl_stgy_restart_cdcl_twl_stgy_cdcl_twl_stgy_restart</span><span class="delimiter">[</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (g ((i + k)))&#8250;</span></span></span><span>
</span><span>              </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (g ((i + k)))&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (g (Suc ((i + k))))&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (g i)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Sucg</span><span> </span><span>prod.collapse</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; j&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl_twl_stgy_restart_cdcl_twl_stgy_cdcl_twl_stgy_restart</span><span>
</span><span>              </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>tranclp_into_rtranclp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; Suc j&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Ex_cdcl_twl_stgy_restart</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;k &gt; i. cdcl_twl_stgy_restart (g i) (g k)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;k. k &gt; i &#10233; &#172;cdcl_twl_stgy_restart (g i) (g k)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>g&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;g&#39; = (&#955;k. fst (g (k + i)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (fst (g i)) (fst (g (Suc (i + k)))) &#8743;
         cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (fst (g (i + k))) (fst (g (Suc (i + k)))) &#8743;
         snd (g (Suc (i + k))) = snd (g i)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k+1&#8250;</span></span></span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc i+_&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(g&#39; (Suc k), g&#39; k) &#8712; {(T, S). twl_struct_invs S &#8743; cdcl_twl_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span>inv</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>g&#39;_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tranclp_wf_cdcl_twl_stgy</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_iff_no_infinite_down_chain</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h_Suc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;h (Suc i) = g (SOME j. cdcl_twl_stgy_restart (h i) (g j))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h_g</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;j. h i = g j&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>i&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;h i = g i&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8801; SOME j. cdcl_twl_stgy_restart (h i) (g j)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>k</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &gt; i&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>i_k</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (g i&#39;) (g k)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ex_cdcl_twl_stgy_restart</span><span class="delimiter">[</span><span>of</span><span> </span><span>i&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (h i) (g j)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>j_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>someI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;S. cdcl_twl_stgy_restart (h i) (g S)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span> </span><span>i_k</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (h i) (h (Suc i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>       </span><span>h_g_i</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;h i = g i&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>h_g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;j &#8801; SOME j. cdcl_twl_stgy_restart (h i) (g j)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>k</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &gt; i&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>i_k</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (g i&#39;) (g k)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ex_cdcl_twl_stgy_restart</span><span class="delimiter">[</span><span>of</span><span> </span><span>i&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart (h i) (g j)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>j_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>someI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span> </span><span>i_k</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_g_i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>h_Suc</span><span> </span><span>j_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;i. twl_struct_invs (fst (h i))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span>h_g</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_cdcl_twl_stgy_restart</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_iff_no_infinite_down_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>twl_restart</span><span class="delimiter">)</span><span> </span><span>wf_cdcl_twl_stgy_restart_measure</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ({((brkT, T, n), brkS, S, m).
         twl_struct_invs S &#8743; cdcl_twl_stgy_restart_with_leftovers1 (S, m) (T, n)} &#8746;
        {((brkT, T), brkS, S). S = T &#8743; brkT &#8743; &#172; brkS})&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf (?TWL &#8746; ?BOOL)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_union_compatible</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?TWL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_snd_wf_pair</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_cdcl_twl_stgy_restart_with_leftovers1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?TWL O ?BOOL &#8838; ?TWL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?BOOL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_iff_no_infinite_down_chain</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; bool &#215; &#39;b&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;i. (f (Suc i), f i) &#8712; {((brkT, T), brkS, S). S = T &#8743; brkT &#8743; &#172; brkS}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f (Suc 0), f 0) &#8712; {((brkT, T), brkS, S). S = T &#8743; brkT &#8743; &#172; brkS}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f (Suc 1), f 1) &#8712; {((brkT, T), brkS, S). S = T &#8743; brkT &#8743; &#172; brkS}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>twl_restart</span><span class="delimiter">)</span><span> </span><span>wf_cdcl_twl_stgy_restart_measure_early</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ({((ebrk, brkT, T, n), ebrk, brkS, S, m).
         twl_struct_invs S &#8743; cdcl_twl_stgy_restart_with_leftovers1 (S, m) (T, n)} &#8746;
        {((ebrkT, brkT, T), (ebrkS, brkS, S)). S = T &#8743; (ebrkT &#8744; brkT) &#8743; (&#172;brkS &#8743; &#172;ebrkS)})&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf (?TWL &#8746; ?BOOL)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_union_compatible</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?TWL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_snd_wf_pair</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_snd_wf_pair</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_cdcl_twl_stgy_restart_with_leftovers1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?TWL O ?BOOL &#8838; ?TWL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?BOOL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_iff_no_infinite_down_chain</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; bool &#215; bool &#215; _&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;i. (f (Suc i), f i) &#8712; ?BOOL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f (Suc 0), f 0) &#8712; ?BOOL&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(f (Suc 1), f 1) &#8712; ?BOOL&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_with_leftovers S T &#10233; twl_struct_invs (fst S) &#10233;  twl_stgy_invs (fst S) &#10233;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>S&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst T&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd T&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers_twl_struct_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_with_leftovers S T &#10233; twl_struct_invs (fst S) &#10233;
    twl_struct_invs (fst T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(fst T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>S&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst T&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd T&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_with_leftovers_twl_struct_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_with_leftovers<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; twl_struct_invs (fst S) &#10233;
    twl_struct_invs (fst T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>U</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span> </span><span>U</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers_twl_stgy_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_with_leftovers S T &#10233; twl_struct_invs (fst S) &#10233;
    twl_stgy_invs (fst S) &#10233; twl_stgy_invs (fst T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(fst T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(fst T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>S&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst T&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd T&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S&#39;, snd T)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_with_leftovers_twl_stgy_invs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_with_leftovers<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; twl_struct_invs (fst S) &#10233;
    twl_stgy_invs (fst S) &#10233; twl_stgy_invs (fst T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>U</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span> </span><span>U</span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_twl_stgy_restart_with_leftovers_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_with_leftovers_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_with_leftovers<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; twl_struct_invs (fst S) &#10233; twl_stgy_invs (fst S) &#10233;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart S) (state<span class="hidden">&#8681;</span><sub>W</sub>_of_restart T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>U</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_stgy_restart_with_leftovers_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span> </span><span>U</span><span class="delimiter">]</span><span>
</span><span>    </span><span>rtranclp_cdcl_twl_stgy_restart_with_leftovers_twl_struct_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>rtranclp_cdcl_twl_stgy_restart_with_leftovers_twl_stgy_invs</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2018 </td><td align="center">26d8aaa66074 </td><td align="center">24d4e5b9 </td><td align="center">Tue 06 Nov 2018 04:20:56 PM CET </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:14:54 AM CEST </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:25:56 AM CEST </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>






