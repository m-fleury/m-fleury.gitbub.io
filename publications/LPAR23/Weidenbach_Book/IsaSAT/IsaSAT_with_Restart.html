<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory IsaSAT_with_Restart (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory IsaSAT_with_Restart</h1>

<span class="command">theory</span> <span class="name">IsaSAT_with_Restart</span><br/>
<span class="keyword">imports</span> <a href="IsaSAT_Restart.html"><span class="name">IsaSAT_Restart</span></a> <a href="IsaSAT_Initialisation.html"><span class="name">IsaSAT_Initialisation</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IsaSAT_with_Restart</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IsaSAT_Restart</span><span> </span><span>IsaSAT_Initialisation</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  We cannot use \&lt;^term&gt;&#8249;cdcl_twl_stgy_restart&#8250; since we do not always end in a final state
  for \&lt;^term&gt;&#8249;cdcl_twl_stgy&#8250;.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>conclusive_TWL_run</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v twl_st &#8658; &#39;v twl_st nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conclusive_TWL_run S =
     SPEC(&#955;T. &#8707;n n&#39;. cdcl_twl_stgy_restart_with_leftovers<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (S, n) (T, n&#39;) &#8743; final_twl_state T)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>isasat_input_bounded_nempty</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_spec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs S &#10233;
  twl_stgy_invs S &#10233;
  clauses_to_update S = {#} &#10233;
  get_conflict S = None &#10233;
  cdcl_twl_stgy_restart_prog S &#8804; conclusive_TWL_run S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl_twl_stgy_prog_spec</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conclusive_TWL_run_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_l_spec_final</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_l_pre S S&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_prog_l S &#8804; &#8659; (twl_st_l None) (conclusive_TWL_run S&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span>
</span><span>     </span><span>cdcl_twl_stgy_restart_prog_l_cdcl_twl_stgy_restart_prog</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_l_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_l_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ref_two_step</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl_twl_stgy_restart_prog_spec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_l_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>conc_fun_R_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_spec_final</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_wl_pre S S&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_prog_wl S &#8804; &#8659; (state_wl_l None O twl_st_l None) (conclusive_TWL_run S&#39;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(S, T) &#8712; state_wl_l None&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_l_pre T S&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_spec</span><span class="delimiter">[</span><span class="string"><span class="delete"><span class="delete">&quot;to_&#8659;&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ref_two_step&#39;</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl_twl_stgy_restart_prog_l_spec_final</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>S&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conc_fun_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_D_spec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_are_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_prog_wl_D S &#8804; &#8659; {(T&#39;, T). T = T&#39; &#8743; literals_are_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> T}
     (cdcl_twl_stgy_restart_prog_wl S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((False, S, 0), False, S, 0) &#8712;
     {((brk&#39;, T&#39;, n&#39;), brk, T, n). brk = brk&#39; &#8743; T = T&#39; &#8743; literals_are_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> T &#8743; n = n&#39;}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_propagation_outer_loop_wl_D S &#8804; &#8659; {(T&#39;, T). T = T&#39; &#8743; literals_are_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> T}
       (unit_propagation_outer_loop_wl T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = T&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_are_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unit_propagation_outer_loop_wl_D_spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_o_prog_wl_D S &#8804; &#8659; {((b&#39;, T&#39;), b, T). b = b&#39; &#8743; T = T&#39; &#8743; literals_are_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> T}
    (cdcl_twl_o_prog_wl T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S = T&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;literals_are_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_o_prog_wl_D_spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_D_def</span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>restart_prog_wl_D_restart_prog_wl</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_curry2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_D_spec_final</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_wl_D_pre S S&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_prog_wl_D S &#8804; &#8659; (state_wl_l None O twl_st_l None) (conclusive_TWL_run S&#39;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_wl_pre S S&#39; &#8743; literals_are_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_D_pre_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_D_spec</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ref_two_step&#39;</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_spec_final</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>S&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conc_fun_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conc_fun_R_mono</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This is temporary copy of IsaSAT and should replace it eventually.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_nat_of_uint32</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (nat_of_uint32 `# A) &#10231; distinct_mset A&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct (map nat_of_uint32 xs) &#10231; distinct xs&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_image_mset_inj</span><span class="delimiter">[</span><span>of</span><span> </span><span>nat_of_uint32</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>distinct_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_prog_wl_D &#8801; isasat_restart_ops.cdcl_twl_stgy_restart_prog_wl_D id&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>isasat_input_bounded.append_el_aa_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>isasat_input_bounded.polarity_pol_code_polarity_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>  </span><span>isasat_input_bounded.cons_trail_Propagated_tr_code_cons_trail_Propagated_tr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>conclusive_CDCL_run</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conclusive_CDCL_run CS T U &#10231;
      (&#8707;n n&#39;. cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (T, n) (U, n&#39;) &#8743; no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub> (U)) &#8744;
          (CS &#8800; {#} &#8743; conflicting U &#8800; None &#8743; count_decided (trail U) = 0 &#8743;
          unsatisfiable (set_mset CS))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;to get a full SAT:
  &#9642; either we fully apply \&lt;^term&gt;&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy&#8250; (up to restarts)
  &#9642; or we can stop early.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SAT</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat clauses &#8658; nat cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;SAT CS = do{
    let T = init_state CS;
    SPEC (conclusive_CDCL_run CS T)
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;In the following program, the condition \&lt;^term&gt;&#8249;length CS &lt; uint_max - 1&#8250; is only necessary
  to simplify the refinement and should not be necessary.&#8250;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* if b &#8743; length CS &lt; uint_max - 1 &#8213; &#8249;simplifies the refinement&#8250;
    then
     do {
      let S = isasat_input_ops.init_state_wl (mset_set &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;);
      T &#8592; init_dt_wl CS (to_init_state S);
      let T = from_init_state T;
      if get_conflict_wl T &#8800; None
      then RETURN T
      else if CS = [] then RETURN (([], fmempty, None, {#}, {#}, {#}, &#955;_. undefined))
      else do {
         ASSERT (extract_atms_clss CS {} &#8800; {});
         ASSERT(isasat_input_bounded_nempty (mset_set &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;));
         ASSERT(mset `# ran_mf (get_clauses_wl T) + get_unit_clauses_wl T = mset `# mset CS);
         ASSERT(learned_clss_l (get_clauses_wl T) = {#});
         isasat_input_ops.cdcl_twl_stgy_prog_break_wl_D (mset_set &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;) (finalise_init T)
      }
   }
   else *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>SAT_wl</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat clause_l list &#8658; nat twl_st_wl nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;SAT_wl CS = do{
    let &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39; = extract_atms_clss CS {};
    b &#8592; SPEC(&#955;_::bool. True);

  do {
      let S = isasat_input_ops.init_state_wl (mset_set &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;);
      T &#8592; init_dt_wl CS (to_init_state S);
      let T = from_init_state T;
      if get_conflict_wl T &#8800; None
      then RETURN T
      else if CS = [] then RETURN (([], fmempty, None, {#}, {#}, {#}, &#955;_. undefined))
      else do {
         ASSERT (extract_atms_clss CS {} &#8800; {});
         ASSERT(isasat_input_bounded_nempty (mset_set &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;));
         ASSERT(mset `# ran_mf (get_clauses_wl T) + get_unit_clauses_wl T = mset `# mset CS);
         ASSERT(learned_clss_l (get_clauses_wl T) = {#});
         cdcl_twl_stgy_restart_prog_wl_D (mset_set &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;) (finalise_init T)
      }
   }
  }&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>extract_model_of_state</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_model_of_state U = Some (map lit_of (get_trail_wl U))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>extract_model_of_state_heur</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_model_of_state_heur U = Some (map lit_of (get_trail_wl_heur U))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>extract_stats</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_stats U = None&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>extract_stats_init</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_stats_init = None&#8250;</span></span></span><span>
</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* if b &#8743; length CS &lt; uint_max - 1
    then do {
      let S = isasat_input_ops.init_state_wl &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;;
      let S = to_init_state S;
      T &#8592; init_dt_wl CS S;
      let T = from_init_state T;
      if &#172;get_conflict_wl_is_None_init T
      then RETURN (None)
      else if CS = [] then RETURN (Some [])
      else do {
         ASSERT(&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39; &#8800; {#});
         ASSERT(isasat_input_bounded_nempty &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;);
         ASSERT(mset `# ran_mf (get_clauses_wl T) + get_unit_clauses_wl T = mset `# mset CS);
         ASSERT(size (learned_clss_l (get_clauses_wl T)) = 0);
         let T = finalise_init T;
         U &#8592; isasat_input_ops.cdcl_twl_stgy_prog_break_wl_D &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39; T;
         RETURN (if get_conflict_wl U = None then extract_model_of_state U else extract_stats U)
      }
    }
    else *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>IsaSAT</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat clause_l list &#8658; nat literal list option nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;IsaSAT CS = do{
    let &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39; = mset_set (extract_atms_clss CS {});
    ASSERT(isasat_input_bounded &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;);
    ASSERT(distinct_mset &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;);
    b &#8592; SPEC(&#955;_::bool. True);
     do {
      let S = isasat_input_ops.init_state_wl &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;;
      let S = to_init_state S;
      T &#8592; init_dt_wl CS S;
      let T = from_init_state T;
      if &#172;get_conflict_wl_is_None_init T
      then RETURN (None)
      else if CS = [] then RETURN (Some [])
      else do {
         ASSERT(&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39; &#8800; {#});
         ASSERT(isasat_input_bounded_nempty &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;);
         ASSERT(mset `# ran_mf (get_clauses_wl T) + get_unit_clauses_wl T = mset `# mset CS);
         ASSERT(size (learned_clss_l (get_clauses_wl T)) = 0);
         let T = finalise_init T;
         U &#8592; cdcl_twl_stgy_restart_prog_wl_D &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39; T;
         RETURN (if get_conflict_wl U = None then extract_model_of_state U else extract_stats U)
      }
    }
  }&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>extract_model_of_state_stat</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_wl_heur &#8658; nat literal list option &#215; stats&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_model_of_state_stat U =
     (Some (map lit_of (rev (get_trail_wl_heur U))),
       (&#955;(M, _,  _, _, _ ,_ ,_ ,_, _, _, _, stat, _). stat) U)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>extract_state_stat</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_wl_heur &#8658; nat literal list option &#215; stats&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_state_stat U =
     (None,
       (&#955;(M, _, _, _, _ ,_ ,_ ,_, _, _, _, stat, _). stat) U)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>empty_conflict</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat literal list option&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;empty_conflict = Some []&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span>empty_conflict_code</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(_ list option &#215; stats) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;empty_conflict_code = do{
     let M0 = op_arl_empty;
     let M1 = Some M0;
     RETURN (M1, (zero_uint64, zero_uint64, zero_uint64, zero_uint64, zero_uint64))}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>model_stat_assn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;model_stat_assn &#8801; option_assn (arl_assn unat_lit_assn) *a stats_assn&#8250;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* heap_array_empty *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>empty_conflict_code&#39;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry0 (empty_conflict_code)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> model_stat_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>empty_conflict_code_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;let _ =  &#8977; in _&#8250;</span></span></span><span> </span><span>annotate_assn</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;arl_assn unat_lit_assn&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>empty_conflict_code&#39;.refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>empty_init_code</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ list option &#215; stats&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;empty_init_code = (None, (zero_uint64, zero_uint64, zero_uint64, zero_uint64, zero_uint64))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>empty_init_code&#39;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry0 (RETURN empty_init_code)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unit_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> model_stat_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>empty_init_code_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>empty_init_code&#39;.refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_dt_wl_code_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry2 (&#955;_. init_dt_wl_code), uncurry2 (isasat_input_ops.init_dt_wl_heur))
  &#8712; [&#955;((N, S), S&#39;). isasat_input_bounded &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8743; N = &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>]<span class="hidden">&#8681;</span><sub>a</sub>
    ghost_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (list_assn (list_assn unat_lit_assn))<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (isasat_input_ops.isasat_init_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>)<span class="hidden">&#8679;</span><sup>d</sup> &#8594;
    isasat_input_ops.isasat_init_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>PR_CONST_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span> </span><span>hn_refine_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>in_pair_collect_simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>init_dt_wl_code.refine</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span class="delimiter">,</span><span>
</span><span>      </span><span>unfolded</span><span> </span><span>in_pair_collect_simp</span><span> </span><span>hfref_def</span><span> </span><span>hn_refine_def</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(snd (fst c), snd c)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(snd (fst a), snd a)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>frame_rule_left</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ * isasat_input_ops.isasat_init_assn _ _ _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ghost_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> (fst (fst a))&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma init_dt_wl_fast_code_refine[sepref_fr_rules]:
  &#8249;(uncurry2 (&#955;_. init_dt_wl_fast_code), uncurry2 (isasat_input_ops.init_dt_wl_heur_fast))
  &#8712; [&#955;((N, S), S&#39;). isasat_input_bounded &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8743; N = &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>]<span class="hidden">&#8681;</span><sub>a</sub>
    ghost_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (list_assn (list_assn unat_lit_assn))<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub>
     (isasat_input_ops.isasat_init_fast_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>)<span class="hidden">&#8679;</span><sup>d</sup> &#8594;
    isasat_input_ops.isasat_init_fast_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#8250;
  unfolding PR_CONST_def
  unfolding hfref_def hn_refine_def
  apply (subst in_pair_collect_simp)
  apply (intro allI impI)
  subgoal for a c
    using init_dt_wl_fast_code.refine[of &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>,
      unfolded in_pair_collect_simp hfref_def hn_refine_def PR_CONST_def,
      rule_format, of &#8249;(snd (fst c), snd c)&#8250; &#8249;(snd (fst a), snd a)&#8250;]
    by (cases a)
       (sep_auto dest!: frame_rule_left[of &#8249;_ * isasat_input_ops.isasat_init_fast_assn _ _ _&#8250; _ _
            &#8249;ghost_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> (fst (fst a))&#8250;])
  done*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span>convert_state</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;convert_state _ S = S&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>convert_state_hnr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry (return oo (&#955;_ S. S)), uncurry (RETURN oo convert_state))
   &#8712; [&#955;(N, S). N = &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8743; N = &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;]<span class="hidden">&#8681;</span><sub>a</sub>
     ghost_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (isasat_input_ops.isasat_init_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>)<span class="hidden">&#8679;</span><sup>d</sup> &#8594;
     isasat_input_ops.isasat_init_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_to_hoare</span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>convert_state_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma (in -) convert_state_fast_hnr:
  &#8249;(uncurry (return oo (&#955;_ S. S)), uncurry (RETURN oo convert_state))
   &#8712; [&#955;(N, S). N = &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8743; N = &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;]<span class="hidden">&#8681;</span><sub>a</sub>
     ghost_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> (isasat_input_ops.isasat_init_fast_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>)<span class="hidden">&#8679;</span><sup>d</sup> &#8594;
     isasat_input_ops.isasat_init_fast_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#8250;
  by sepref_to_hoare (sep_auto simp: convert_state_def)*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>IsaSAT_use_fast_mode</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;IsaSAT_use_fast_mode = True&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IsaSAT_use_fast_mode</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry0 (return IsaSAT_use_fast_mode), uncurry0 (RETURN IsaSAT_use_fast_mode))
   &#8712; unit_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_to_hoare</span><span> </span><span>sep_auto</span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* if IsaSAT_use_fast_mode &#8743; length CS &lt; uint_max - 1
    then do {
        S &#8592; isasat_input_ops.init_state_wl_heur_fast &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;;
        (T::twl_st_wl_heur_init) &#8592; isasat_input_ops.init_dt_wl_heur_fast &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; CS S;
        let T = convert_state &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; T;
        if &#172;get_conflict_wl_is_None_heur_init T
        then RETURN empty_init_code
        else if CS = [] then empty_conflict_code
        else do {
           ASSERT(&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; &#8800; {#});
           ASSERT(isasat_input_bounded_nempty &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39;);
           ASSERT(mset `# ran_mf (get_clauses_wl_heur_init T) &#8838;# mset `# mset CS);
           ASSERT((&#955;(M&#39;, N&#39;, D&#39;, Q&#39;, W&#39;, ((ns, m, fst_As, lst_As, next_search), to_remove), &#966;, clvls). fst_As &#8800; None &#8743;
             lst_As &#8800; None) T);
           ASSERT(size (learned_clss_l (get_clauses_wl_heur_init T)) = 0);
           T &#8592; finalise_init_code (T::twl_st_wl_heur_init);
           ASSERT(isasat_fast T);
           U &#8592; isasat_input_ops.cdcl_twl_stgy_prog_break_wl_D_heur_break &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; T;
           RETURN (if get_conflict_wl_is_None_heur U then extract_model_of_state_stat U
             else extract_state_stat U)
         }
      }
    else *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>IsaSAT_heur</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat clause_l list &#8658; (nat literal list option &#215; stats) nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;IsaSAT_heur CS = do{
    ASSERT(&#8704;C&#8712;set CS. &#8704;L&#8712;set C. nat_of_lit L &#8804; uint_max);
    let &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39; = mset_set (extract_atms_clss CS {});
    ASSERT(isasat_input_bounded &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;);
    ASSERT(distinct_mset &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;);
    let &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; = virtual_copy &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;;
     do {
        S &#8592; isasat_input_ops.init_state_wl_heur &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;;
        (T::twl_st_wl_heur_init) &#8592; isasat_input_ops.init_dt_wl_heur &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; CS S;
        let T = convert_state &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; T;
        if &#172;get_conflict_wl_is_None_heur_init T
        then RETURN (empty_init_code)
        else if CS = [] then empty_conflict_code
        else do {
           ASSERT(&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; &#8800; {#});
           ASSERT(isasat_input_bounded_nempty &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39;);
           _ &#8592; isasat_information_banner T;
           ASSERT((&#955;(M&#39;, N&#39;, D&#39;, Q&#39;, W&#39;, ((ns, m, fst_As, lst_As, next_search), to_remove), &#966;, clvls). fst_As &#8800; None &#8743;
             lst_As &#8800; None) T);
           T &#8592; finalise_init_code (T::twl_st_wl_heur_init);
           U &#8592; isasat_input_ops.cdcl_twl_stgy_restart_prog_wl_heur &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; T;
           RETURN (if get_conflict_wl_is_None_heur U then extract_model_of_state_stat U
             else extract_state_stat U)
         }
      }
    }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_class_in_literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712; set CS&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_ops.literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> (mset_set (extract_atms_clss CS {})) (mset C)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isasat_input_ops.literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_def</span><span> </span><span>extract_atms_clss_alt_def</span><span>
</span><span>       </span><span>isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_def</span><span> </span><span>all_lits_of_m_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>insert_absorb</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span>insert_absorb</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>insert_absorb</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span>id_mset_list_assn_list_mset_assn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CONSTRAINT is_pure R&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(return o id, RETURN o mset) &#8712; (list_assn R)<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> list_mset_assn R&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>R&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;R = pure R&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>is_pure_conv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CONSTRAINT_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>R&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;the_pure R = R&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>R</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>R</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>list_assn_pure_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_mset_assn_def</span><span> </span><span>R&#39;</span><span> </span><span>pure_def</span><span> </span><span>list_mset_rel_def</span><span> </span><span>mset_rel_def</span><span>
</span><span>       </span><span>p2rel_def</span><span> </span><span>rel2p_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>rel_mset_def</span><span> </span><span>br_def</span><span> </span><span>Collect_eq_comp</span><span> </span><span>list_rel_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_D_code_ref&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry (&#955;_. cdcl_twl_stgy_prog_wl_D_code), uncurry isasat_input_ops.cdcl_twl_stgy_prog_wl_D_heur)
  &#8712; [&#955;(N, _). N = &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8743; isasat_input_bounded_nempty &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>]<span class="hidden">&#8681;</span><sub>a</sub>
     (ghost_assn)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub>
    (isasat_input_ops.isasat_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>)<span class="hidden">&#8679;</span><sup>d</sup> &#8594; isasat_input_ops.isasat_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span> </span><span>hn_refine_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>in_pair_collect_simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_D_code.refine</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span class="delimiter">,</span><span>
</span><span>      </span><span>unfolded</span><span> </span><span>in_pair_collect_simp</span><span> </span><span>hfref_def</span><span> </span><span>hn_refine_def</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd c&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd a&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>frame_rule_left</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_ops.isasat_assn _ _ _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ghost_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> (fst a)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma cdcl_twl_stgy_prog_wl_D_break_fast_code_ref&#39;:
  &#8249;(uncurry (&#955;_. cdcl_twl_stgy_prog_wl_D_fast_code),
      uncurry isasat_input_ops.cdcl_twl_stgy_prog_break_wl_D_heur_break)
  &#8712; [&#955;(N, S). N = &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8743; isasat_input_bounded_nempty &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8743; isasat_fast S]<span class="hidden">&#8681;</span><sub>a</sub>
     (ghost_assn)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub>
    (isasat_input_ops.isasat_fast_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>)<span class="hidden">&#8679;</span><sup>d</sup> &#8594; isasat_input_ops.isasat_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#8250;
  unfolding hfref_def hn_refine_def
  apply (subst in_pair_collect_simp)
  apply (intro allI impI)
  subgoal for a c
    using cdcl_twl_stgy_prog_wl_D_fast_code.refine[of &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>,
      unfolded in_pair_collect_simp hfref_def hn_refine_def PR_CONST_def,
      rule_format, of &#8249;snd c&#8250; &#8249;snd a&#8250;]
    by (cases a)
      (sep_auto simp:
      dest!: frame_rule_left[of &#8249;isasat_input_ops.isasat_fast_assn _ _ _&#8250; _ _
       &#8249;ghost_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> (fst a)&#8250;])
  done*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_D_code_ref&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry (&#955;_. cdcl_twl_stgy_restart_prog_wl_heur_code), uncurry isasat_input_ops.cdcl_twl_stgy_restart_prog_wl_heur)
  &#8712; [&#955;(N, _). N = &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8743; isasat_input_bounded_nempty &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>]<span class="hidden">&#8681;</span><sub>a</sub>
     (ghost_assn)<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub>
    (isasat_input_ops.isasat_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>)<span class="hidden">&#8679;</span><sup>d</sup> &#8594; isasat_input_ops.isasat_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hfref_def</span><span> </span><span>hn_refine_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>in_pair_collect_simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_heur_code.refine</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span class="delimiter">,</span><span>
</span><span>      </span><span>unfolded</span><span> </span><span>in_pair_collect_simp</span><span> </span><span>hfref_def</span><span> </span><span>hn_refine_def</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd c&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd a&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>frame_rule_left</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_ops.isasat_assn _ _ _&#8250;</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ghost_assn &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> (fst a)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_D_code_ref&#39;</span><span class="delimiter">[</span><span>to_hnr</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*declare cdcl_twl_stgy_prog_wl_D_break_fast_code_ref&#39;[to_hnr, OF refl, sepref_fr_rules]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_D_code_ref&#39;</span><span class="delimiter">[</span><span>to_hnr</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_trail_wl_code</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_wll_trail &#8658; uint32 array_list option &#215; stats&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_wl_code = (&#955;((M, _), _, _, _, _ ,_ ,_ ,_, _, _, _, stat, _). (Some M, stat))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_stats_code</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_wll_trail &#8658; uint32 array_list option &#215; stats&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_stats_code = (&#955;((M, _), _, _, _, _ ,_ ,_ ,_, _, _, _, stat, _). (None, stat))&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>model_stat_rel</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;model_stat_rel = {((M&#39;, s), M). map_option rev M = M&#39;}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>model_assn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;model_assn = hr_comp model_stat_assn model_stat_rel&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>isasat_input_ops</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extract_model_of_state_stat_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(return o get_trail_wl_code, RETURN o extract_model_of_state_stat) &#8712; isasat_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub>
       model_stat_assn&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;a c. &#8593; ((c, a) &#8712; unat_lit_rel)) = unat_lit_assn&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_lit_rel_def</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;id_assn (an, ao, bb) (bs, bt, bu) = (id_assn an bs * id_assn ao bt * id_assn bb bu)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>an</span><span> </span><span>ao</span><span> </span><span>bb</span><span> </span><span>bs</span><span> </span><span>bt</span><span> </span><span>bu</span><span> </span><span class="delimiter">::</span><span> </span><span>uint64</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>      </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_heur_def</span><span> </span><span>hr_comp_def</span><span> </span><span>trail_pol_def</span><span> </span><span>isasat_assn_def</span><span>
</span><span>        </span><span>isasat_init_assn_def</span><span> </span><span>get_trail_wl_code_def</span><span>
</span><span>        </span><span>extract_model_of_state_def</span><span> </span><span>extract_model_of_state_stat_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ann_lits_split_reasons_map_lit_of</span><span>
</span><span>        </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mod_starE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_stats_code</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(return o get_stats_code, RETURN o extract_state_stat) &#8712; isasat_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub>
       model_stat_assn&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;a c. &#8593; ((c, a) &#8712; unat_lit_rel)) = unat_lit_assn&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_lit_rel_def</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;id_assn (an, ao, bb) (bs, bt, bu) = (id_assn an bs * id_assn ao bt * id_assn bb bu)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>an</span><span> </span><span>ao</span><span> </span><span>bb</span><span> </span><span>bs</span><span> </span><span>bt</span><span> </span><span>bu</span><span> </span><span class="delimiter">::</span><span> </span><span>uint64</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_to_hoare</span><span>
</span><span>      </span><span class="delimiter">(</span><span>sep_auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_heur_def</span><span> </span><span>hr_comp_def</span><span> </span><span>trail_pol_def</span><span> </span><span>isasat_assn_def</span><span>
</span><span>        </span><span>isasat_init_assn_def</span><span> </span><span>get_trail_wl_code_def</span><span> </span><span>get_stats_code_def</span><span>
</span><span>        </span><span>extract_model_of_state_def</span><span> </span><span>extract_model_of_state_stat_def</span><span> </span><span>extract_state_stat_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ann_lits_split_reasons_map_lit_of</span><span>
</span><span>        </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mod_starE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>isasat_input_ops.extract_model_of_state_stat_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>isasat_input_ops.finalise_init_hnr</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>PR_CONST_def</span><span class="delimiter">,</span><span> </span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*declare isasat_input_ops.finalise_init_fast_hnr[unfolded PR_CONST_def, sepref_fr_rules]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>to_init_state</span><span> </span><span>from_init_state</span><span> </span><span>get_conflict_wl_is_None_init</span><span> </span><span>extract_stats</span><span>
</span><span>  </span><span>isasat_input_ops.init_dt_wl_heur</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>init_state_wl_heur_hnr</span><span class="delimiter">[</span><span>to_hnr</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>  </span><span>init_dt_wl_code.refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>  </span><span>isasat_input_ops.get_stats_code</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  init_state_wl_heur_fast_hnr[to_hnr, OF refl, sepref_fr_rules]*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint_max_nat_assn_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry0 (return uint_max), uncurry0 (RETURN uint_max)) &#8712; unit_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> nat_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_to_hoare</span><span> </span><span>sep_auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Crucial and subtil point for the refinement&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>convert_state_hnr</span><span class="delimiter">[</span><span>to_hnr</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* convert_state_fast_hnr[to_hnr, OF _ refl, sepref_fr_rules]*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*isasat_input_ops.init_dt_wl_heur_fast*)</span></span></span></span></span><span>
</span><span>   </span><span>isasat_input_ops.cdcl_twl_stgy_restart_prog_wl_heur</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_definition</span></span><span> </span><span>IsaSAT_code</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;IsaSAT_heur&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(list_assn (list_assn unat_lit_assn))<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> model_stat_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsaSAT_heur_def</span><span> </span><span>empty_conflict_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>get_conflict_wl_is_None</span><span> </span><span>extract_model_of_state_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span>extract_stats_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>get_conflict_wl_is_None_heur_init_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span>isasat_input_bounded.get_conflict_wl_is_None_code_refine</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>  </span><span>isasat_input_bounded.get_conflict_wl_is_None_init_code_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* isasat_input_bounded.get_conflict_wl_is_None_init_fast_code_hnr[sepref_fr_rules]*)</span></span></span></span></span><span>
</span><span>  </span><span>isasat_input_ops.to_init_state_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>  </span><span>isasat_input_ops.from_init_state_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>  </span><span>isasat_input_bounded.get_conflict_wl_is_None_init_wl_hnr</span><span class="delimiter">[</span><span>
</span><span>    </span><span>unfolded</span><span> </span><span>get_conflict_wl_is_None_init_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>  </span><span>isasat_input_bounded_nempty.cdcl_twl_stgy_restart_prog_wl_heur_hnr</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>id_mset_list_assn_list_mset_assn</span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span>get_conflict_wl_is_None_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>   </span><span>option.splits</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span>   </span><span>extract_stats_def</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_atms_clss _ &#8977;&#8250;</span></span></span><span> </span><span>op_extract_list_empty_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nth_u_code&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_u_code&#39; = nth_u_code&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>nth_u_code&#39;</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(fn/ ()/ =&gt;/ Array.sub/ ((_),/ Word32.toInt (_)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nth_u64_code&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_u64_code&#39; = nth_u64_code&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>nth_u64_code&#39;</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(fn/ ()/ =&gt;/ Array.sub/ ((_),/ Uint64.toFixedInt (_)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>heap_array_set&#39;_u&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;heap_array_set&#39;_u&#39; = heap_array_set&#39;_u&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>heap_array_set&#39;_u&#39;</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>   </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(fn/ ()/ =&gt;/ Array.update/ ((_),/ (Word32.toInt (_)),/ (_)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>heap_array_set&#39;_u64&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;heap_array_set&#39;_u64&#39; = heap_array_set&#39;_u64&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>heap_array_set&#39;_u64&#39;</span><span> </span><span class="delimiter">&#8640;</span><span>
</span><span>   </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(fn/ ()/ =&gt;/ Array.update/ ((_),/ (Word64.toInt (_)),/ (_)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>two_uint32</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Word32.fromInt 2)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>length_u_code&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length_u_code&#39; = length_u_code&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>length_u_code&#39;</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML_imp</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(fn/ ()/ =&gt;/ Word32.fromInt (Array.length (_)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>length_aa_u_code&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length_aa_u_code&#39; = length_aa_u_code&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>length_aa_u_code&#39;</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML_imp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;(fn/ ()/ =&gt;/ Word32.fromInt (Array.length (Array.sub/ ((fn/ (a,b)/ =&gt;/ a) (_),/ IntInf.toInt (integer&#39;_of&#39;_nat (_))))))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nth_raa_i_u64&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_raa_i_u64&#39; = nth_raa_i_u64&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>nth_raa_i_u64&#39;</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML_imp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;(fn/ ()/ =&gt;/ Array.sub (Array.sub/ ((fn/ (a,b)/ =&gt;/ a) (_),/ IntInf.toInt (integer&#39;_of&#39;_nat (_))), Uint64.toFixedInt (_)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>length_u64_code&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length_u64_code&#39; = length_u64_code&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>length_u64_code&#39;</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML_imp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;(fn/ ()/ =&gt;/ Uint64.fromFixedInt (Array.length (_)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>arl_get_u</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(fn/ ()/ =&gt;/ Array.sub/ ((fn/ (a,b)/ =&gt;/ a) ((_)),/ Word32.toInt ((_))))&quot;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
definition arl_set_u64&#39; where
  [symmetric, code]: &#8249;arl_set_u64&#39; = arl_set_u64&#8250;
 *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arl_set_u64_code</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;arl_set_u64 a i x =
   Array_upd_u64 i x (fst a) &#10524; (&#955;b. return (b, (snd a)))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>arl_set_u64_def</span><span> </span><span>arl_set_def</span><span> </span><span>heap_array_set&#39;_u64_def</span><span> </span><span>arl_set&#39;_u64_def</span><span>
</span><span>     </span><span>heap_array_set_u64_def</span><span> </span><span>Array.upd&#39;_def</span><span> </span><span>Array_upd_u64_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_of_uint64_code</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>arl_set_u_code</span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;arl_set_u a i x =
   Array_upd_u i x (fst a) &#10524; (&#955;b. return (b, (snd a)))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>arl_set_u_def</span><span> </span><span>arl_set_def</span><span> </span><span>heap_array_set&#39;_u64_def</span><span> </span><span>arl_set&#39;_u_def</span><span>
</span><span>     </span><span>heap_array_set_u_def</span><span> </span><span>Array.upd&#39;_def</span><span> </span><span>Array_upd_u_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_of_uint64_code</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* This equation makes no sense since a resizable array is represent by an array and an infinite
 integer: There is no obvious shortcut.
code_printing constant length_arl_u_code&#39; &#8640; (SML_imp)
   &quot;(fn/ ()/ =&gt;/ Word32.fromLargeInt (snd (_)))&quot;  *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* code_printing constant nth_u64_code &#8640; (SML) &quot;(fn/ ()/ =&gt;/ Array.sub/ ((_),/ Uint64.toFixedInt (_)))&quot; *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>arl_get_u64&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;arl_get_u64&#39; = arl_get_u64&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>arl_get_u64&#39;</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(fn/ ()/ =&gt;/ Array.sub/ ((fn (a,b) =&gt; a) (_),/ Uint64.toFixedInt (_)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>IsaSAT_code</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>SML_imp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span class="comment">&#8213; &#8249;print with line break&#8250;</span><span>
</span><span>  </span><span>println_string</span><span> </span><span class="delimiter">&#8640;</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete"><span class="delete">&quot;ignore/ (print/ ((_) ^ \&quot;\\n\&quot;))&quot;</span></span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>IsaSAT_code</span><span>
</span><span>    </span><span>int_of_integer</span><span>
</span><span>    </span><span>integer_of_int</span><span>
</span><span>    </span><span>integer_of_nat</span><span>
</span><span>    </span><span>nat_of_integer</span><span>
</span><span>    </span><span>uint32_of_nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML_imp</span><span> </span><span class="keyword2"><span class="keyword">module_name</span></span><span> </span><span>SAT_Solver</span><span> </span><span class="keyword2"><span class="keyword">file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;code/IsaSAT_restart_solver.sml&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>TWL_to_clauses_state_conv</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat twl_st_wl &#215; nat cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset) set&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TWL_to_clauses_state_conv = twl_st_of_wl None O {(S&#39;, S). S = state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extract_atms_cls_empty_iff</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_atms_cls Cs C0 = {} &#10231; (C0 = {} &#8743; Cs = [])&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extract_atms_cls_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Cs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C0</span><span class="delimiter">)</span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extract_atms_clss_empty_iff</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_atms_clss CS C0  = {} &#10231; (C0 = {} &#8743; (&#8704;C &#8712; set CS. C = []))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extract_atms_clss_alt_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_extract_atms_clss</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_ops.is_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> (mset_set (extract_atms_clss CS&#39; {}))
       (all_lits_of_mm (mset `# mset CS&#39;))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_neg xb &#10233; Pos (atm_of xb) = - xb&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xb</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xb</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_pos xb &#10233; Neg (atm_of xb) = - xb&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xb</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xb</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;x. x &#8712;# all_lits_of_mm
               (mset `# mset CS&#39;) &#10233;
         x &#8713; Neg `
              (&#8899;C&#8712;set CS&#39;. atm_of ` set C) &#10233;
         x &#8712; Pos ` (&#8899;C&#8712;set CS&#39;. atm_of ` set C)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>CS&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span> </span><span>CS</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_lits_of_mm_add_mset</span><span> </span><span>image_Un</span><span> </span><span>in_all_lits_of_m_ain_atms_of_iff</span><span>
</span><span>        </span><span>atm_of_eq_atm_of</span><span> </span><span>uminus_lit_swap</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_atms_clss_alt_def</span><span>
</span><span>        </span><span>isasat_input_ops.is_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_def</span><span> </span><span>isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_def</span><span> </span><span>all_lits_of_mm_add_mset</span><span>
</span><span>        </span><span>all_lits_of_m_add_mset</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>split_list</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO Move *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_extract_atms_clss</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite (extract_atms_clss CS&#39; {})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_atms_clss_alt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_extract_atms_clss_in_all_lits_of_mm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> (mset_set (extract_atms_clss CS&#39; {})) &#10231;
    L&#8712;#all_lits_of_mm (mset `# mset CS&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A &#10231; ?B&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A &#10231; L&#8712;#all_lits_of_m (mset_set (Pos ` extract_atms_clss CS&#39; {}))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_all_lits_of_m_ain_atms_of_iff</span><span> </span><span>atms_of_def</span><span> </span><span>image_image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8230; &#10231; ?B&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>is_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_extract_atms_clss</span><span> </span><span>isasat_input_ops.is_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span>mset_set</span><span> </span><span>image_mset</span><span> </span><span>image</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_ex_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub> S T &#10233; &#8707;U. cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy S U&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>.cases</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_init_state</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (init_state {#}) S &#10231; S = init_state {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rtranclp_unfold</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>tranclp_unfold_begin</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_init_state_empty_no_step</span><span>
</span><span>       </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_init_state</span><span>
</span><span>      </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>init_state.simps</span><span>
</span><span>       </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_ex_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_init_state</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub> (init_state {#}) S &#10231; False&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_ex_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_init_state_empty_no_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_init_state</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (M, CS, {#}, Some {#}) S &#10231; S = (M, CS, {#}, Some {#})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_def</span><span> </span><span>rtranclp_unfold</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>tranclp_unfold_begin</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.simps</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.conflict.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span>
</span><span>       </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.decide.simps</span><span>
</span><span>       </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.backtrack.simps</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.skip.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.resolve.simps</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_spec_final2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(SAT_wl, SAT) &#8712; [&#955;CS. (&#8704;C &#8712;# CS. distinct_mset C) &#8743;
        (&#8704;C &#8712;# CS. &#8704;L &#8712;# C. nat_of_lit L &#8804; uint_max)]<span class="hidden">&#8681;</span><sub>f</sub>
     (list_mset_rel O &#10216;list_mset_rel&#10217; mset_rel) &#8594; &#10216;TWL_to_clauses_state_conv&#10217;nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_list_mset_rel</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(CS&#39;, y) &#8712; list_mset_rel &#10231; y = mset CS&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_mset_rel_def</span><span> </span><span>br_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_list_mset_rel_mset_rel</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(mset CS&#39;, CS) &#8712; &#10216;list_mset_rel&#10217;mset_rel &#10231; CS = mset `# mset CS&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS</span><span> </span><span>CS&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_mset_rel_def</span><span> </span><span>br_def</span><span> </span><span>mset_rel_def</span><span> </span><span>p2rel_def</span><span> </span><span>rel_mset_def</span><span>
</span><span>        </span><span>rel2p_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>list_all2_op_eq_map_right_iff&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub></span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_ops.is_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> (mset_set (extract_atms_clss CS&#39; {}))
       (all_lits_of_mm (mset `# mset CS&#39;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_extract_atms_clss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extract_nempty</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_atms_clss xs {} = {} &#10231; set xs = {[]}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball ys distinct_mset &#8743; (&#8704;C&#8712;#ys. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>rel</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(xs, ys) &#8712; list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>le_xs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length xs &#8800; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xs</span><span> </span><span>ys</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_xs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extract_atms_clss_alt_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_bounded (mset_set (extract_atms_clss CS&#39; {}))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>CS_p</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C&#8712;set CS&#39;. &#8704;L&#8712;set C. nat_of_lit L &#8804; uint_max&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isasat_input_bounded_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> (mset_set (extract_atms_clss CS&#39; {}))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#8712;set CS&#39; &#8743; (L &#8712;set C &#8744; - L &#8712; set C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_atms_clss_alt_def</span><span> </span><span>uint_max_def</span><span> </span><span>nat_of_uint32_uint32_of_nat_id</span><span>
</span><span>          </span><span>isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>literal.exhaust_sel</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_of_lit L &#8804; uint_max &#8744; nat_of_lit (-L) &#8804; uint_max&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span>CS_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_of_lit L &#8804; uint_max&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_atms_clss_alt_def</span><span> </span><span>uint_max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conflict_during_init</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN (fst T)
      &#8804; &#8659; TWL_to_clauses_state_conv
           (SPEC (conclusive_CDCL_run CS (init_state CS)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball CS distinct_mset &#8743; (&#8704;C&#8712;#CS. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>CS&#39;_CS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(CS&#39;, CS) &#8712; list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>spec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_dt_wl_spec CS&#39; (([], fmempty, None, {#}, {#}, {#}, &#955;_. []), {#}) T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_wl (fst T) &#8800; None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>CS</span><span> </span><span>CS&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((([], fmempty, None, {#}, {#}, {#}, &#955;_. []), {#}), U) &#8712; state_wl_l_init&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>T_V</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, V) &#8712; state_wl_l_init&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>V_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(V, W) &#8712; twl_st_l_init&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs_init W&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l_init V = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>count_dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;s&#8712;set (get_trail_l_init V). &#172; is_decided s&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>clss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset `# mset CS&#39; + mset `# ran_mf (get_clauses_l_init U) +
         other_clauses_l_init U + get_unit_clauses_l_init U =
       mset `# ran_mf (get_clauses_l_init V) + other_clauses_l_init V +
         get_unit_clauses_l_init V&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>learned_UV</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss_lf (get_clauses_l_init U) = learned_clss_lf (get_clauses_l_init V)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l_init V = None &#10230;
          literals_to_update_l_init V = uminus `# lit_of `# mset (get_trail_l_init V)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_learned_unit_clauses_l_init V = get_learned_unit_clauses_l_init U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>add_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs (fst V)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs (fst W)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;other_clauses_l_init V &#8800; {#} &#10230; get_conflict_l_init V &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#} &#8712;# mset `# mset CS&#39; &#10230; get_conflict_l_init V &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l_init U &#8800; None &#10230;
       get_conflict_l_init U = get_conflict_l_init V&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spec</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_dt_wl_spec_def</span><span> </span><span>init_dt_spec_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>learned_U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss_lf (get_clauses_l_init U) = {#}&#8250;</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_l_init U = fmempty&#8250;</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;other_clauses_l_init U  = {#}&#8250;</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_l_init U = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>U</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>learned_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_learned_clauses_init W = {#}&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_learned_clauses_init W = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_init_clauses_init W = get_unit_clauses_l_init V&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span>learned</span><span> </span><span>learned_UV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>U</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>V</span><span class="delimiter">;</span><span>
</span><span>         </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_init_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ran_m_init_U</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ran_m (get_clauses_l_init V) = init_clss_l (get_clauses_l_init V)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span>learned</span><span> </span><span>learned_UV</span><span> </span><span>learned_U</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>all_clss_l_ran_m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>U</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>V</span><span class="delimiter">;</span><span>
</span><span>         </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_init_def</span><span>
</span><span>         </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>all_clss_l_ran_m</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause `# (get_init_clauses_init W) =
       mset `# (init_clss_lf (get_clauses_l_init V))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span>learned</span><span> </span><span>learned_UV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>U</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>V</span><span class="delimiter">;</span><span>
</span><span>         </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_init_def</span><span>
</span><span>         </span><span>mset_take_mset_drop_mset&#39;</span><span> </span><span>mset_take_mset_drop_mset</span><span>
</span><span>         </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>set_mset</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>init_clss_W_V</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clause ` set_mset (get_init_clauses_init W)
        = mset ` set_mset (init_clss_lf (get_clauses_l_init V))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>count_dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (get_trail_wl (fst T)) = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_dec</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>count_decided_0_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_init</span><span>
</span><span>          </span><span>twl_st_wl_init</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS = mset `# mset CS&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CS&#39;_CS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_list_mset_rel</span><span> </span><span>in_list_mset_rel_mset_rel</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause (state<span class="hidden">&#8681;</span><sub>W</sub>_of_init W)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>all_struct_invs</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of_init W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_init_def</span><span>
</span><span>         </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting (state<span class="hidden">&#8681;</span><sub>W</sub>_of_init W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_init_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (mset `# mset (rev CS&#39;)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conflict_of_level_unsatisfiable</span><span class="delimiter">[</span><span>OF</span><span> </span><span>all_struct_invs</span><span class="delimiter">]</span><span> </span><span>count_dec</span><span> </span><span>confl</span><span> </span><span>learned</span><span> </span><span>clss</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span>
</span><span>        </span><span>learned_U</span><span> </span><span>init_clss_W_V</span><span> </span><span>learned_W</span><span> </span><span>le</span><span> </span><span>ran_m_init_U</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span> </span><span>mset_take_mset_drop_mset&#39;</span><span> </span><span>twl_st_init</span><span> </span><span>twl_st_wl_init</span><span> </span><span>image_image</span><span>
</span><span>          </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init_def</span><span> </span><span>ac_simps</span><span> </span><span>twl_st_l_init</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unsat</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (mset ` set CS&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS&#39; &#8800; []&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>unsat</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RETURN_SPEC_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst W)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>state_wl_l_init_def</span><span> </span><span>twl_st_l_init_alt_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TWL_to_clauses_state_conv_def</span><span> </span><span>mset_take_mset_drop_mset&#39;</span><span>
</span><span>            </span><span>clauses_def</span><span> </span><span>in_list_mset_rel</span><span> </span><span>in_list_mset_rel_mset_rel</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conclusive_CDCL_run_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub></span><span> </span><span>struct_invs</span><span> </span><span>learned</span><span> </span><span>count_dec</span><span> </span><span>U</span><span> </span><span>clss</span><span> </span><span>confl</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CS</span><span> </span><span>twl_st_init</span><span> </span><span>twl_st_wl_init</span><span> </span><span>twl_st_l_init</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>empty_clss</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN ([], fmempty, None, {#}, {#}, {#}, &#955;_. undefined)
      &#8804; &#8659; TWL_to_clauses_state_conv
          (SPEC (conclusive_CDCL_run CS (init_state CS)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball CS distinct_mset &#8743; (&#8704;C&#8712;#CS. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>CS&#39;_CS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(CS&#39;, CS) &#8712; list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>spec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_dt_wl_spec CS&#39; (([], fmempty, None, {#}, {#}, {#}, &#955;_. []), {#}) T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; get_conflict_wl (fst T) &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS&#39; = []&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span> </span><span>CS</span><span> </span><span>T</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?init</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], {#}, {#}, None)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?init_twl</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], {#}, {#}, None, {#}, {#}, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?init_l</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], fmempty, None, {#}, {#}, {#}, {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?init_wl</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], fmempty, None, {#}, {#}, {#}, &#955;_. undefined)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CS&#39;_CS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_list_mset_rel</span><span> </span><span>in_list_mset_rel_mset_rel</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy ?init ?init&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>full_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_init_state</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], {#}, {#}, None)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub> ?init S &#10231; False&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_init_state</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(?init_twl, ?init) &#8712; {(S&#39;, S). S = state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(?init_l, ?init_twl) &#8712; twl_st_l None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(?init_wl, ?init_l) &#8712; state_wl_l None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(([], fmempty, None, {#}, {#}, {#}, &#955;_. undefined), [], {#}, {#}, None)
       &#8712; (state_wl_l None O twl_st_l None) O {(S&#39;, S). S = state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spec</span><span> </span><span>confl</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_dt_wl_spec_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RETURN_SPEC_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], {#}, {#}, None)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span> </span><span>TWL_to_clauses_state_conv_def</span><span> </span><span>state_wl_l_init_def</span><span>
</span><span>        </span><span>conclusive_CDCL_run_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>extract_atms_clss_not_nil</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_atms_clss CS&#39; {} &#8800; {}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball CS distinct_mset &#8743; (&#8704;C&#8712;#CS. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>CS&#39;_CS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(CS&#39;, CS) &#8712; list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>spec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_dt_wl_spec CS&#39; (([], fmempty, None, {#}, {#}, {#}, &#955;_. []), {#}) T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; get_conflict_wl (fst T) &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS&#39; &#8800; []&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span> </span><span>CS</span><span> </span><span>T</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((([], fmempty, None, {#}, {#}, {#}, &#955;_. []), {#}), U) &#8712; state_wl_l_init&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>T_V</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, V) &#8712; state_wl_l_init&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>V_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(V, W) &#8712; twl_st_l_init&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs_init W&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l_init V = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>count_dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;s&#8712;set (get_trail_l_init V). &#172; is_decided s&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>clss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset `# mset CS&#39; + mset `# ran_mf (get_clauses_l_init U) +
         other_clauses_l_init U + get_unit_clauses_l_init U =
       mset `# ran_mf (get_clauses_l_init V) + other_clauses_l_init V +
         get_unit_clauses_l_init V&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>learned_UV</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss_lf (get_clauses_l_init U) = learned_clss_lf (get_clauses_l_init V)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l_init V = None &#10230;
          literals_to_update_l_init V = uminus `# lit_of `# mset (get_trail_l_init V)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_learned_unit_clauses_l_init V = get_learned_unit_clauses_l_init U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>add_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs (fst V)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs (fst W)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>snd_T_conflict</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;other_clauses_l_init V &#8800; {#} &#10230; get_conflict_l_init V &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>false_in_conflict</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#} &#8712;# mset `# mset CS&#39; &#10230; get_conflict_l_init V &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l_init U &#8800; None &#10230;
       get_conflict_l_init U = get_conflict_l_init V&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spec</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_dt_wl_spec_def</span><span> </span><span>init_dt_spec_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS = mset `# mset CS&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CS&#39;_CS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_list_mset_rel</span><span> </span><span>in_list_mset_rel_mset_rel</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;other_clauses_init_wl T = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_T_conflict</span><span> </span><span>confl</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_init</span><span> </span><span>twl_st_l_init</span><span>
</span><span>           </span><span>twl_st_wl_init</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;C&#8712;set CS&#39;. C &#8800; []&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>E</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C&#8712;set CS&#39;. C = []&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>CS&#39;</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>T</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>use</span><span> </span><span>E</span><span> </span><span>false_in_conflict</span><span> </span><span>clss</span><span> </span><span>confl</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: clauses_def CS twl_st_init twl_st_l_init   twl_st_wl_init&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extract_atms_clss_empty_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CDCL_steps</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_prog_wl_D (mset_set (extract_atms_clss CS&#39; {})) (fst T)
      &#8804; &#8659; TWL_to_clauses_state_conv
          (SPEC (conclusive_CDCL_run CS (init_state CS)))&#8250;</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?steps</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; &#8659; _ ?Spec&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>clauses</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset `# ran_mf (get_clauses_wl (fst T)) +
         get_unit_clauses_wl (fst T) = mset `# mset CS&#39;&#8250;</span></span></span><span>
</span><span>        </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?clss</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>break_CDCL_steps</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_prog_wl_D (mset_set (extract_atms_clss CS&#39; {})) (fst T)
    &#8804; &#8659; TWL_to_clauses_state_conv (SPEC (conclusive_CDCL_run CS (init_state CS)))&#8250;</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?break_steps</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned_clss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss_l (get_clauses_wl (fst T)) = {#}&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?learned_clss</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>CS_p</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball CS distinct_mset &#8743; (&#8704;C&#8712;#CS. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>CS&#39;_CS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(CS&#39;, CS) &#8712; list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>spec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_dt_wl_spec CS&#39; (([], fmempty, None, {#}, {#}, {#}, &#955;_. []), {#}) T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; get_conflict_wl (fst T) &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>CS&#39;_nempty</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS&#39; &#8800; []&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_atms_clss CS&#39; {} &#8800; {}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_bounded_nempty (mset_set (extract_atms_clss CS&#39; {}))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span> </span><span>CS</span><span> </span><span>T</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>U</span><span> </span><span>V</span><span> </span><span>W</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((([], fmempty, None, {#}, {#}, {#}, &#955;_. []), {#}), U) &#8712; state_wl_l_init&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>T_V</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, V) &#8712; state_wl_l_init&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>V_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(V, W) &#8712; twl_st_l_init&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>corr_w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;correct_watching_init T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs_init W&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>clss_upd</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses_to_update_l_init V = {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>count_dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;s&#8712;set (get_trail_l_init V). &#172; is_decided s&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>clss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset `# mset CS&#39; + mset `# ran_mf (get_clauses_l_init U) +
         other_clauses_l_init U + get_unit_clauses_l_init U =
       mset `# ran_mf (get_clauses_l_init V) + other_clauses_l_init V +
         get_unit_clauses_l_init V&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>learned_UV</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss_lf (get_clauses_l_init U) = learned_clss_lf (get_clauses_l_init V)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l_init V = None &#10230;
          literals_to_update_l_init V = uminus `# lit_of `# mset (get_trail_l_init V)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_learned_unit_clauses_l_init V = get_learned_unit_clauses_l_init U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>add_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_list_invs (fst V)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>stgy_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_stgy_invs (fst W)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>snd_T_conflict</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;other_clauses_l_init V &#8800; {#} &#10230; get_conflict_l_init V &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>false_in_conflict</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#} &#8712;# mset `# mset CS&#39; &#10230; get_conflict_l_init V &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict_l_init U &#8800; None &#10230; get_conflict_l_init U = get_conflict_l_init V&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spec</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_dt_wl_spec_def</span><span> </span><span>init_dt_spec_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>normalize_goal</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;other_clauses_init_wl T = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span>snd_T_conflict</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_init</span><span> </span><span>twl_st_l_init</span><span> </span><span>twl_st_wl_init</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs (fst W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>twl_struct_invs_init_twl_struct_invs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snd_T</span><span> </span><span>struct_invs</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_init</span><span> </span><span>twl_st_l_init</span><span> </span><span>twl_st_wl_init</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>NE</span><span> </span><span>Q</span><span> </span><span>Wa</span><span> </span><span>UE</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T = ((M, N, None, NE, UE, Q, Wa), {#})&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span>snd_T</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span> </span><span>mset_take_mset_drop_mset&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>learned_U</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss_lf (get_clauses_l_init U) = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_l_init U = fmempty&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;other_clauses_l_init U  = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_l_init U = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>U</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>learned_W</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_learned_clauses_init W = {#}&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_learned_clauses_init W = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_init_clauses_init W = get_unit_clauses_l_init V&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>U</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span>learned</span><span> </span><span>learned_UV</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>U</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>V</span><span class="delimiter">;</span><span>
</span><span>         </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_init_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;UE = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_init_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_unit_clauses_l_init V = NE&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_clauses_l_init V = N&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;other_clauses_l_init V = {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst W))) &#8712; convert_lits_l N (NE+UE)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_trail_l_init V = M&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.clauses (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst W)) = mset `# (ran_mf N) + NE&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_init_def</span><span>
</span><span>          </span><span>mset_take_mset_drop_mset</span><span> </span><span>mset_take_mset_drop_mset&#39;</span><span> </span><span>clauses_def</span><span>
</span><span>          </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>all_clss_l_ran_m</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_clss_lf_ran_m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>N_NE</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset `# ran_mf N + NE = mset `# mset CS&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#mset (fst x). x &#8712;# ran_m N#} + NE  = mset `# mset CS&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clss</span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span>learned_U</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span> </span><span>mset_take_mset_drop_mset&#39;</span><span> </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span>st</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>MW</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;MW = trail (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst W))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>st_W</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst W) = (MW, mset `# mset CS&#39;, {#}, None)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T_V</span><span> </span><span>V_W</span><span> </span><span>learned_UV</span><span> </span><span>learned_U</span><span> </span><span>clss</span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_init_def</span><span>
</span><span>          </span><span>mset_take_mset_drop_mset</span><span> </span><span>mset_take_mset_drop_mset&#39;</span><span> </span><span>clauses_def</span><span> </span><span>MW_def</span><span>
</span><span>          </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>all_clss_l_ran_m</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_clss_lf_ran_m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup MW&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L mark a b. a @ Propagated L mark # b = MW &#10233;
            b &#8872;as CNot (remove1_mset L mark) &#8743; L &#8712;# mark&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>clss_in_clss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (get_all_mark_of_propagated MW) &#8838; set_mset (mset `# mset CS&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span> </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span>twl_struct_invs_init_def</span><span>
</span><span>          </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span>
</span><span>          </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span>st</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause_def</span><span>
</span><span>          </span><span>N_NE</span><span> </span><span>st_W</span><span> </span><span>clauses_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>count_dec&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#8712;set MW. &#172;is_decided L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V_W</span><span> </span><span>count_dec</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>st</span><span> </span><span>MW_def</span><span> </span><span>twl_st_init</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>twl_st_l_init_no_decision_iff</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_dec</span><span> </span><span>V_W</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>st</span><span> </span><span>MW_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>CS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS = mset `# mset CS&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CS&#39;_CS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_list_mset_rel</span><span> </span><span>in_list_mset_rel_mset_rel</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ([], CS, {#}, None)
       (MW, mset `# mset CS&#39;, {#}, None)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>count_dec&#39;</span><span> </span><span>propa</span><span> </span><span>clss_in_clss</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>MW</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CS</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>K</span><span> </span><span>MW</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span>-</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_d</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dec</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>propa</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>clss_in_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?init</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;([], CS, {#}, None)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?int</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(MW, mset `# mset CS&#39;, {#}, None)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?final</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(K # MW, mset `# mset CS&#39;, {#}, None)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K = Propagated L C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>K</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ?init ?int&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IH</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M2</span><span> </span><span>L&#39;</span><span> </span><span>mark</span><span> </span><span>M1</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span> </span><span>propa</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K # M2&#8250;</span></span></span><span> </span><span>L&#39;</span><span> </span><span>mark</span><span> </span><span>M1</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clss_in_clss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;MW &#8872;as CNot (remove1_mset L C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[]&#8250;</span></span></span><span> </span><span>L</span><span> </span><span>C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;MW&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.clauses (MW, mset `# mset CS&#39;, {#}, None)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clss_in_clss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>K</span><span> </span><span>clauses_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate ?int
            (Propagated L C # MW, mset `# mset CS&#39;, {#}, None)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.propagate_rule</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#8250;</span></span></span><span> </span><span>L</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy ?int ?final&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>K</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.propagate&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp.rtrancl_into_rtrancl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub></span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_ops.is_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> (mset_set (extract_atms_clss CS&#39; {}))
        (all_lits_of_mm (mset `# mset CS&#39;))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_extract_atms_clss</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_bounded (mset_set (extract_atms_clss CS&#39; {}))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isasat_input_bounded_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> (mset_set (extract_atms_clss CS&#39; {}))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#8712;set CS&#39; &#8743; (L &#8712;set C &#8744; - L &#8712; set C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_atms_clss_alt_def</span><span> </span><span>uint_max_def</span><span> </span><span>nat_of_uint32_uint32_of_nat_id</span><span>
</span><span>          </span><span>isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>literal.exhaust_sel</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C&#8712;#CS. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CS_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_of_lit L &#8804; uint_max &#8744; nat_of_lit (-L) &#8804; uint_max&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_of_lit L &#8804; uint_max&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CS</span><span> </span><span>extract_atms_clss_alt_def</span><span> </span><span>uint_max_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>T_V&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(fst T, fst V) &#8712; state_wl_l None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T_V</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span>state_wl_l_def</span><span> </span><span>state_wl_l_init_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>V_W&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(fst V, fst W) &#8712; twl_st_l None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V_W</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span>twl_st_l_init_def</span><span> </span><span>twl_st_l_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>valid_blits</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L x. x&#8712;set (Wa L) &#10233;
           case x of (i, K, _) &#8658; K &#8712;# all_lits_of_mm (mset `# mset CS&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>corr_w</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>correct_watching_init.simps</span><span> </span><span>st</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>st</span><span> </span><span>N_NE</span><span> </span><span>&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub></span><span> </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span>isasat_input_ops.literals_are_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_def</span><span>
</span><span>        </span><span>isasat_input_ops.blits_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_def</span><span> </span><span>correct_watching.simps</span><span>
</span><span>        </span><span>all_blits_are_in_problem_init.simps</span><span>
</span><span>        </span><span>state_wl_l_def</span><span>  </span><span>correct_watching_init.simps</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_extract_atms_clss_in_all_lits_of_mm</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_l_pre (fst V) (fst W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_l_pre_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>V_W&#39;</span><span> </span><span>struct_invs</span><span> </span><span>corr_w</span><span> </span><span>add_invs</span><span> </span><span>clss</span><span> </span><span>confl</span><span> </span><span>clss</span><span> </span><span>stgy_invs</span><span> </span><span>confl</span><span> </span><span>T_V</span><span> </span><span>clss_upd</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_init</span><span> </span><span>twl_st_l_init</span><span> </span><span>twl_st_wl_init</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_prog_wl_pre (fst T) (fst W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_pre_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst V&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T_V&#39;</span><span> </span><span>corr_w</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>correct_watching_init_correct_watching</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_ops.cdcl_twl_stgy_prog_wl_D_pre (mset_set (extract_atms_clss CS&#39; {})) (fst T) (fst W)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isasat_input_ops.cdcl_twl_stgy_prog_wl_D_pre_def</span><span>
</span><span>        </span><span>cdcl_twl_stgy_prog_wl_pre_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>st</span><span> </span><span>N_NE</span><span> </span><span>&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub></span><span> </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span>isasat_input_ops.literals_are_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_def</span><span>
</span><span>        </span><span>isasat_input_ops.blits_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_def</span><span> </span><span>correct_watching.simps</span><span>
</span><span>        </span><span>all_blits_are_in_problem_init.simps</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_extract_atms_clss_in_all_lits_of_mm</span><span>
</span><span>        </span><span>state_wl_l_def</span><span> </span><span>correct_watching_init.simps</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>  </span><span>valid_blits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_prog_wl_D (mset_set (extract_atms_clss CS&#39; {}))
             (from_init_state T)
            &#8804; &#8659; (state_wl_l None O twl_st_l None)
                 (conclusive_TWL_run (fst W))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_D_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>isasat_input_bounded_nempty.cdcl_twl_stgy_restart_prog_wl_D_spec_final</span><span>
</span><span>        </span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(mset_set (extract_atms_clss CS&#39; {}))&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CS_p</span><span> </span><span>&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub></span><span> </span><span>struct_invs</span><span> </span><span>corr_w</span><span> </span><span>add_invs</span><span> </span><span>clss</span><span> </span><span>confl</span><span> </span><span>clss</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>from_init_state_def</span><span> </span><span>st</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conclusive_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(conclusive_TWL_run (fst W)) &#8804; &#8659; ({(S&#39;, S). S = state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;}) ?Spec&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conc_fun_RES</span><span> </span><span>conclusive_TWL_run_def</span><span> </span><span>less_eq_nres.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; {T. &#8707;n n&#39;.
             cdcl_twl_stgy_restart_with_leftovers<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (fst W, n) (T, n&#39;) &#8743; final_twl_state T}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span>n&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>twl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_with_leftovers<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (fst W, n) (x, n&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>final</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;final_twl_state x&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (state<span class="hidden">&#8681;</span><sub>W</sub>_of (fst W), n) (state<span class="hidden">&#8681;</span><sub>W</sub>_of x, n&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_with_leftovers_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>OF</span><span> </span><span>twl</span><span class="delimiter">]</span><span> </span><span>struct_invs</span><span>
</span><span>          </span><span>stgy_invs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy</span><span class="delimiter">[</span><span>OF</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>stgy</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (([], mset `# mset CS&#39;, {#}, None), n)
            (state<span class="hidden">&#8681;</span><sub>W</sub>_of x, n&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>st_W</span><span> </span><span>CS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_invs_x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_struct_invs x&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>struct_invs</span><span> </span><span>rtranclp_cdcl_twl_stgy_restart_with_leftovers_twl_struct_invs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>twl</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_struct_invs_x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (state<span class="hidden">&#8681;</span><sub>W</sub>_of x)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>twl_struct_invs_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M_lev</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv ([], mset `# mset CS&#39;, {#}, None)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause ([], mset `# mset CS&#39;, {#}, None)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init ([], mset `# mset CS&#39;, {#}, None)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS&#39; &#8800; []&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CS&#39;_nempty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CS</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>entailed</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init (state<span class="hidden">&#8681;</span><sub>W</sub>_of x)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span class="delimiter">[</span><span>OF</span><span> </span><span>stgy</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>fst_conv</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>learned</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>M_lev</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ent</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>        </span><span class="delimiter">(</span><span>ns</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_twl_stgy x&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>        </span><span class="delimiter">(</span><span>stop</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_conflict x &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (get_trail x) = 0&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>final</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>final_twl_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; {(S&#39;, S). S = state<span class="hidden">&#8681;</span><sub>W</sub>_of S&#39;}&#175; ``
          Collect(conclusive_CDCL_run CS (init_state CS) )&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ns</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>no_step_cdcl_twl_stgy_no_step_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub> (state<span class="hidden">&#8681;</span><sub>W</sub>_of x)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_invs</span><span> </span><span>struct_invs_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_ex_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>twl</span><span> </span><span>stgy</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conclusive_CDCL_run_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CS</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>stop</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (init_clss (state<span class="hidden">&#8681;</span><sub>W</sub>_of x)))&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conflict_of_level_unsatisfiable</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_struct_invs_x</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>entailed</span><span> </span><span>stop</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (mset ` set CS&#39;)&#8250;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_init_clss</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>OF</span><span>
</span><span>             </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span class="delimiter">[</span><span>OF</span><span> </span><span>stgy</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stop</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>CS</span><span> </span><span>twl_st_init</span><span> </span><span>twl_st</span><span> </span><span>conclusive_CDCL_run_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?steps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>TWL_to_clauses_state_conv_def</span><span> </span><span>from_init_state_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>conc_fun_chain</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ref_two_step</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conclusive_le</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?clss</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clss</span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_clss_lf_ran_m</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>U</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>S<span class="hidden">&#8681;</span><sub>0</sub></span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>N_NE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_twl_stgy_restart_prog_wl_D (mset_set (extract_atms_clss CS&#39; {}))
             (from_init_state T)
            &#8804; &#8659; (state_wl_l None O twl_st_l None)
                 (conclusive_TWL_run (fst W))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_D_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>isasat_input_bounded_nempty.cdcl_twl_stgy_restart_prog_wl_D_spec_final</span><span>
</span><span>        </span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(mset_set (extract_atms_clss CS&#39; {}))&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CS_p</span><span> </span><span>&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub></span><span>
</span><span>        </span><span>struct_invs</span><span> </span><span>corr_w</span><span> </span><span>add_invs</span><span> </span><span>clss</span><span> </span><span>confl</span><span> </span><span>clss</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>from_init_state_def</span><span> </span><span>st</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?break_steps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>TWL_to_clauses_state_conv_def</span><span> </span><span>from_init_state_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>conc_fun_chain</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ref_two_step</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conclusive_le</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?learned_clss</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned_U</span><span> </span><span>learned_UV</span><span> </span><span>T_V</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>V</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_wl_l_init_def</span><span> </span><span>state_wl_l_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>init</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_dt_wl_pre CS&#39; (([], fmempty, None, {#}, {#}, {#}, &#955;_. []), {#})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Ball (set CS&#39;) distinct&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>init_dt_wl_pre_def</span><span> </span><span>init_dt_pre_def</span><span> </span><span>state_wl_l_init_def</span><span>
</span><span>        </span><span>twl_st_l_init_def</span><span> </span><span>state_wl_l_def</span><span> </span><span>correct_watching_init.simps</span><span> </span><span>clause_to_update_def</span><span>
</span><span>        </span><span>twl_init_invs</span><span> </span><span>all_blits_are_in_problem_init.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite (extract_atms_clss CS&#39; {})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_atms_clss_alt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset_set (extract_atms_clss CS&#39; {}) = {#} &#10231; (&#8704;C &#8712;set CS&#39;. C = [])&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_atms_clss_alt_def</span><span> </span><span>mset_set_empty_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K&#39;</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; (extract_atms_clss CS&#39; {}) &#10233; &#172;(&#8704;C &#8712;set CS&#39;. C = [])&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>K</span><span class="delimiter">[</span><span>of</span><span> </span><span>CS&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>  </span><span>mset_set_empty_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SAT_wl_def</span><span> </span><span>SAT_def</span><span> </span><span>from_init_state_def</span><span> </span><span>to_init_state_def</span><span>
</span><span>     </span><span>isasat_input_ops.empty_watched_alt_def</span><span> </span><span>finalise_init_def</span><span> </span><span>id_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span> </span><span>CS</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;let _ = extract_atms_clss _ _ in _&#8250;</span></span></span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;let _ = isasat_input_ops.init_state_wl _ in _&#8250;</span></span></span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>if_False</span><span> </span><span>isasat_input_ops.init_state_wl_def</span><span>
</span><span>          </span><span>isasat_input_ops.empty_watched_alt_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* bind_refine_spec*)</span></span></span></span></span><span> </span><span>lhs_step_If</span><span> </span><span>init_dt_wl_init_dt_wl_spec</span><span>
</span><span>         </span><span>bind_refine_spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>init_dt_wl_init_dt_wl_spec</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment">&#8213; &#8249;First the fast part:&#8250;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conflict_during_init</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>empty_clss</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>extract_atms_clss_not_nil</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_list_mset_rel</span><span> </span><span>in_list_mset_rel_mset_rel</span><span> </span><span>K</span><span>
</span><span>         </span><span>isasat_input_bounded_nempty_def</span><span> </span><span>isasat_input_bounded_nempty_axioms_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>clauses</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>learned_clss</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>break_CDCL_steps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>init</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_list_mset_rel</span><span> </span><span>in_list_mset_rel_mset_rel</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*       &#8213; &#8249;Now the slow part: &#8250;
      subgoal for b by (rule conflict_during_init)
      subgoal for T by (rule empty_clss)
      subgoal by (rule extract_atms_clss_not_nil)
      subgoal by (auto simp: in_list_mset_rel in_list_mset_rel_mset_rel K
         isasat_input_bounded_nempty_def isasat_input_bounded_nempty_axioms_def)
      subgoal by (rule clauses)
      subgoal by (rule learned_clss)
      subgoal by (rule CDCL_steps)
      subgoal by (rule init) (auto simp: in_list_mset_rel in_list_mset_rel_mset_rel) *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>model_if_satisfiable</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat clauses &#8658; nat literal list option nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;model_if_satisfiable CS = SPEC (&#955;M.
           if satisfiable (set_mset CS) then M &#8800; None &#8743; set (the M) &#8872;sm CS else M = None)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SAT&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat clauses &#8658; nat literal list option nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;SAT&#39; CS = do {
     T &#8592; SAT CS;
     RETURN(if conflicting T = None then Some (map lit_of (trail T)) else None)
  }
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SAT_model_if_satisfiable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(SAT&#39;, model_if_satisfiable) &#8712; [&#955;CS. (&#8704;C &#8712;# CS. distinct_mset C)]<span class="hidden">&#8681;</span><sub>f</sub> Id&#8594; &#10216;Id&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8712;[&#955;CS. ?P CS]<span class="hidden">&#8681;</span><sub>f</sub> Id &#8594; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant (init_state CS)&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (init_state CS)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?P CS&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>
</span><span>        </span><span>twl_struct_invs_def</span><span> </span><span>twl_st_inv.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_propa_def</span><span>
</span><span>        </span><span>past_invs.simps</span><span> </span><span>clauses_def</span><span> </span><span>twl_list_invs_def</span><span> </span><span>twl_stgy_invs_def</span><span> </span><span>clause_to_update_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant_def</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_smaller_confl_def</span><span>
</span><span>        </span><span>distinct_mset_set_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;s &#8712; {M. if satisfiable (set_mset CS) then M &#8800; None &#8743; set (the M) &#8872;sm CS else M = None}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball CS distinct_mset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS&#39; = CS&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>s</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;s &#8712; (&#955;T. if conflicting T = None then Some (map lit_of (trail T)) else None) `
          Collect (conclusive_CDCL_run CS&#39; (init_state CS&#39;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat literal list option&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CS</span><span> </span><span>CS&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>       </span><span>s</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(s = Some (map lit_of (trail T)) &#8743; conflicting T = None) &#8744;
              (s = None &#8743; conflicting T &#8800; None)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>conc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conclusive_CDCL_run CS&#39; ([], CS&#39;, {#}, None) T&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">consider</span></span><span>
</span><span>      </span><span>n</span><span> </span><span>n&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (([], CS&#39;, {#}, None), n) (T, n&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub> T&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS&#39; &#8800; {#}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting T &#8800; None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_lvl T = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset CS&#39;)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conc</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conclusive_CDCL_run_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>n</span><span> </span><span>n&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>st</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ns</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy T&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ns</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>full_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy T T&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant T&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv T&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>st</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_dcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span class="delimiter">]</span><span>
</span><span>          </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_dcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_invariant</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span class="delimiter">]</span><span>
</span><span>          </span><span>H</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dist</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>res</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ([], CS&#39;, {#}, None) T&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init T&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed</span><span class="delimiter">[</span><span>OF</span><span> </span><span>res</span><span class="delimiter">]</span><span> </span><span>H</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dist</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS&#39; = CS&#8250;</span></span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init_def</span><span>
</span><span>          </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss T = CS&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_init_clss</span><span class="delimiter">[</span><span>OF</span><span> </span><span>res</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.full_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_inv_normal_form</span><span class="delimiter">[</span><span>OF</span><span> </span><span>full_T</span><span> </span><span>invs</span><span> </span><span>ent</span><span class="delimiter">]</span><span> </span><span>s</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init (init_state CS)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dist</span><span class="delimiter">]</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.full_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_inv_normal_form</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_state CS&#8250;</span></span></span><span>
</span><span>             </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_state CS&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>s</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SAT&#39;_def</span><span> </span><span>model_if_satisfiable_def</span><span> </span><span>SAT_def</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS&#39;</span><span> </span><span>CS</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>RES_RETURN_RES</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RES_refine</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pair_in_Id_conv</span><span> </span><span>bex_triv_one_point1</span><span> </span><span>bex_triv_one_point2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>H</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_assn_list_mset_rel_clauses_l_assn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(hr_comp (list_assn (list_assn unat_lit_assn)) (list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel)) xs xs&#39;
     = clauses_l_assn xs xs&#39;&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex_remove_xs</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8707;xs. mset xs = mset x &#8743; {#literal_of_nat (nat_of_uint32 x). x &#8712;# mset xs#} = y) &#10231;
       ({#literal_of_nat (nat_of_uint32 x). x &#8712;# mset x#} = y)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_assn_pure_conv</span><span> </span><span>list_mset_assn_pure_conv</span><span>
</span><span>     </span><span>list_rel_mset_rel_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>hr_comp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ent_ex_up_swap</span><span> </span><span>list_mset_assn_def</span><span> </span><span>pure_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;map (&#955;x. literal_of_nat (nat_of_uint32 x)) `# mset xs&#39;&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_mset_rel_def</span><span> </span><span>br_def</span><span> </span><span>mset_rel_def</span><span> </span><span>unat_lit_rel_def</span><span>
</span><span>        </span><span>uint32_nat_rel_def</span><span> </span><span>nat_lit_rel_def</span><span>
</span><span>        </span><span>p2rel_def</span><span> </span><span>Collect_eq_comp</span><span> </span><span>rel2p_def</span><span>
</span><span>        </span><span>list_all2_op_eq_map_map_right_iff</span><span> </span><span>rel_mset_def</span><span> </span><span>rel2p_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span>
</span><span>        </span><span>list_all2_op_eq_map_right_iff&#39;</span><span> </span><span>ex_remove_xs</span><span> </span><span>list_rel_def</span><span>
</span><span>        </span><span>list_all2_op_eq_map_right_iff</span><span>
</span><span>        </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>literal_of_nat.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>isasat_input_ops</span><span class="delimiter">)</span><span> </span><span>twl_st_heur_init_vmtf_next_emptyD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((x1, x1a, x1b, x1c, x1d, ((x1g, x1h, x1i, x1j, x2h), x2i), x1k, x2k), Ta)
       &#8712; twl_st_heur_init &#10233; &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8800; {#} &#10233; x1i &#8800; None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isasat_input_ops.twl_st_heur_init_def</span><span> </span><span>isasat_input_ops.vmtf_init_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>isasat_input_ops</span><span class="delimiter">)</span><span> </span><span>twl_st_heur_init_vmtf_fstD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((x1, x1a, x1b, x1c, x1d, ((x1g, x1h, x1i, x1j, x2h), x2i), x1k, x2k), Ta)
       &#8712; twl_st_heur_init &#10233; &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> &#8800; {#} &#10233; x1j &#8800; None&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isasat_input_ops.twl_st_heur_init_def</span><span> </span><span>isasat_input_ops.vmtf_init_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_conflict_wl_is_None_init_get_conflict_wl_is_None_heur_init</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Tb, Ta) &#8712; isasat_input_ops.twl_st_heur_init A &#10233;
     get_conflict_wl_is_None_init (from_init_state Ta) = get_conflict_wl_is_None_heur_init Tb&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Ta</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>Tb</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isasat_input_ops.twl_st_heur_init_wl_def</span><span> </span><span>from_init_state_def</span><span>
</span><span>      </span><span>get_conflict_wl_is_None_init_def</span><span> </span><span>get_conflict_wl_is_None_heur_init_def</span><span>
</span><span>      </span><span>isasat_input_ops.twl_st_heur_init_def</span><span> </span><span>isasat_input_ops.option_lookup_clause_rel_def</span><span>
</span><span>      </span><span>get_conflict_wl_is_None_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>isasat_input_ops</span><span class="delimiter">)</span><span> </span><span>twl_st_heur_init_wl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, Ta) &#8712; twl_st_heur_init &#10233; (T, from_init_state Ta) &#8712; twl_st_heur_init_wl&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>T</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>Ta</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>twl_st_heur_init_def</span><span> </span><span>twl_st_heur_init_wl_def</span><span> </span><span>from_init_state_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemma(in isasat_input_ops) get_clauses_wl_from_init_get_clauses_wl_heur_init:
  &#8249;(T, Ta) &#8712; twl_st_heur_init &#10233; get_clauses_wl (from_init_state Ta) = get_clauses_wl_heur_init T&#8250;
  by (cases T; cases Ta)
    (auto simp: twl_st_heur_init_def twl_st_heur_init_wl_def from_init_state_def)

lemma isasat_input_bounded_nempty_cdcl_twl_stgy_prog_wl_D_heur_break_cdcl_twl_stgy_prog_wl_D&#39;:
  &#8249;isasat_input_bounded_nempty &#119964; &#10233; (S, S&#39;) &#8712; isasat_input_ops.twl_st_heur &#119964; &#10233; &#119964; = &#119964;&#39; &#10233;
   isasat_input_ops.cdcl_twl_stgy_prog_break_wl_D_heur_break &#119964; S
    &#8804; &#8659; (isasat_input_ops.twl_st_heur &#119964;)
         (isasat_input_ops.cdcl_twl_stgy_prog_break_wl_D &#119964;&#39; S&#39;)&#8250;
  using isasat_input_bounded_nempty.cdcl_twl_stgy_prog_wl_D_heur_break_cdcl_twl_stgy_prog_wl_D
             [THEN fref_to_Down, unfolded comp_def, of &#119964; S S&#39;]
  by fast *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isasat_input_bounded_nempty_cdcl_twl_stgy_restart_prog_wl_D_heur_break_cdcl_twl_stgy_prog_wl_D&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_bounded_nempty &#119964; &#10233; (S, S&#39;) &#8712; isasat_input_ops.twl_st_heur &#119964; &#10233; &#119964; = &#119964;&#39; &#10233;
    isasat_input_ops.cdcl_twl_stgy_restart_prog_wl_heur &#119964; S
    &#8804; &#8659;(isasat_input_ops.twl_st_heur &#119964;)
         (cdcl_twl_stgy_restart_prog_wl_D &#119964;&#39; S&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl_twl_stgy_restart_prog_wl_D_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>isasat_input_bounded_nempty.cdcl_twl_stgy_restart_prog_wl_heur_cdcl_twl_stgy_restart_prog_wl_D</span><span>
</span><span>             </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>comp_def</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>&#119964;</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IsaSAT_heur_IsaSAT</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(IsaSAT_heur, IsaSAT) &#8712;
     [&#955;CS.  Multiset.Ball (mset CS) distinct &#8743; (&#8704;C&#8712;set CS. &#8704;L&#8712;set C. nat_of_lit L &#8804; uint_max)]<span class="hidden">&#8681;</span><sub>f</sub>
     Id &#8594; &#10216;{((M, stat), M&#39;). map_option rev M = M&#39;}&#10217;nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A + B = C &#10233; A &#8838;# C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;twl_st_wl_heur_init &#8658; twl_st_wl_heur_init nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f = RETURN&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IsaSAT_heur_alt_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;IsaSAT_heur CS = do{
    ASSERT(&#8704;C&#8712;set CS. &#8704;L&#8712;set C. nat_of_lit L &#8804; uint_max);
    let &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; = mset_set (extract_atms_clss CS {});
    ASSERT(isasat_input_bounded &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39;);
    ASSERT(distinct_mset &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39;);
    let b = False;
    &#8998;&#8249;if b &#8743; length CS &lt; uint_max - 1
    then do {
        S &#8592; isasat_input_ops.init_state_wl_heur &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39;;
        S &#8592; f S;
        (T::twl_st_wl_heur_init) &#8592; isasat_input_ops.init_dt_wl_heur &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; CS S;
        if &#172;get_conflict_wl_is_None_heur_init T
        then RETURN (empty_init_code)
        else if CS = [] then empty_conflict_code
        else do {
           ASSERT(&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; &#8800; {#});
           ASSERT(isasat_input_bounded_nempty &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39;);
           ASSERT((&#955;(M&#39;, N&#39;, D&#39;, Q&#39;, W&#39;, ((ns, m, fst_As, lst_As, next_search), to_remove), &#966;, clvls). fst_As &#8800; None &#8743;
             lst_As &#8800; None) T);
           T &#8592; finalise_init_code (T::twl_st_wl_heur_init);
           ASSERT(isasat_fast T);
           U &#8592; isasat_input_ops.cdcl_twl_stgy_prog_wl_D_heur &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; T;
           RETURN (if get_conflict_wl_is_None_heur U then extract_model_of_state_stat U
             else extract_state_stat U)
         }
      }
    else&#8250;
        S &#8592; isasat_input_ops.init_state_wl_heur &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39;;
        S &#8592; f S;
        (T::twl_st_wl_heur_init) &#8592; isasat_input_ops.init_dt_wl_heur &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; CS S;
        if &#172;get_conflict_wl_is_None_heur_init T
        then RETURN (empty_init_code)
        else if CS = [] then empty_conflict_code
        else do {
           ASSERT(&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; &#8800; {#});
           ASSERT(isasat_input_bounded_nempty &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39;);
           ASSERT((&#955;(M&#39;, N&#39;, D&#39;, Q&#39;, W&#39;, ((ns, m, fst_As, lst_As, next_search), to_remove), &#966;, clvls). fst_As &#8800; None &#8743;
             lst_As &#8800; None) T);
           T &#8592; finalise_init_code (T::twl_st_wl_heur_init);
           U &#8592; isasat_input_ops.cdcl_twl_stgy_restart_prog_wl_heur &#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>&#39;&#39; T;
           RETURN (if get_conflict_wl_is_None_heur U then extract_model_of_state_stat U
             else extract_state_stat U)
         }

    }&#8250;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A = ?B&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ASSERT &#934; &#10524; (&#955;_. P) &#8804; ASSERT &#934; &#10524; (&#955;_. Q) &#10231; (&#934; &#10230; P &#8804; Q)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>&#934;</span><span> </span><span>P</span><span> </span><span>Q</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Refine_Basic.le_ASSERTI_pres</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A &#8804; ?B&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsaSAT_heur_def</span><span> </span><span>Let_def</span><span> </span><span>isasat_input_ops.init_state_wl_heur_fast_def</span><span> </span><span>f_def</span><span>
</span><span>        </span><span>empty_conflict_code_def</span><span> </span><span>empty_conflict_code_def</span><span> </span><span>empty_init_code_def</span><span> </span><span>convert_state_def</span><span>
</span><span>        </span><span>isasat_information_banner_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>lhs_step_If</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>  </span><span>Refine_Basic.bind_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* apply (subst isasat_input_ops.init_dt_wl_heur_fast_init_dt_wl_heur)
      apply (auto simp: isasat_input_ops.init_state_wl_heur_def map_fun_rel_def
          RES_RES_RETURN_RES RETURN_def in_class_in_literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> Max_dom_fmempty) *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?B &#8804; ?A&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsaSAT_heur_def</span><span> </span><span>Let_def</span><span> </span><span>isasat_input_ops.init_state_wl_heur_fast_def</span><span> </span><span>f_def</span><span>
</span><span>        </span><span>empty_conflict_code_def</span><span> </span><span>empty_conflict_code_def</span><span> </span><span>empty_init_code_def</span><span> </span><span>convert_state_def</span><span>
</span><span>        </span><span>isasat_information_banner_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span> </span><span>lhs_step_If</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>  </span><span>Refine_Basic.bind_mono</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* apply (subst isasat_input_ops.init_dt_wl_heur_fast_init_dt_wl_heur)
      apply (auto simp: isasat_input_ops.init_state_wl_heur_def map_fun_rel_def
          RES_RES_RETURN_RES RETURN_def in_class_in_literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> Max_dom_fmempty) *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>refine</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, T&#39;) &#8712; isasat_input_ops.twl_st_heur_init_wl N &#10233;
    f T &#8804; &#8659; {(T, (T&#39;, OS)). (T, T&#39;) &#8712; isasat_input_ops.twl_st_heur_init_wl N}
        (RETURN (to_init_state T&#39;))&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#10233; _ &#8804; &#8659; ?init _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>T&#39;</span><span> </span><span>N</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>f_def</span><span> </span><span>to_init_state_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>init</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_ops.init_dt_wl_heur (mset_set (extract_atms_clss CS {})) CS T&#39;
      &#8804; &#8659; (isasat_input_ops.twl_st_heur_init (mset_set (extract_atms_clss CS&#39; {})))
          (init_dt_wl CS&#39;
             (to_init_state (isasat_input_ops.init_state_wl (mset_set (extract_atms_clss CS&#39; {})))))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>distinct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball (mset CS&#39;) distinct&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(CS, CS&#39;) &#8712; Id&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_bounded (mset_set (extract_atms_clss CS&#39; {}))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>TT&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inres (f T) T&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>T&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T&#39;, to_init_state (isasat_input_ops.init_state_wl (mset_set (extract_atms_clss CS&#39; {}))))
        &#8712; {(T, T&#39;, OS).
          (T, T&#39;) &#8712; isasat_input_ops.twl_st_heur_init_wl (mset_set (extract_atms_clss CS&#39; {}))}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS</span><span> </span><span>CS&#39;</span><span> </span><span>T</span><span> </span><span>T&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SS&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;CS = CS&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SS&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T = T&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TT&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712; set CS&#39; &#10233; &#8707;CS&#39;&#39;&#39;. set CS&#39; = insert C CS&#39;&#39;&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712; set CS&#39; &#10233;
       isasat_input_ops.literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub> (mset_set (extract_atms_clss CS&#39; {})) (mset C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isasat_input_ops.literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_def</span><span> </span><span>isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_def</span><span>
</span><span>          </span><span>extract_atms_clss_alt_def</span><span> </span><span>in_all_lits_of_m_ain_atms_of_iff</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>          </span><span>atms_of_s_def</span><span> </span><span>image_image</span><span> </span><span>image_Un</span><span> </span><span>in_image_uminus_uminus</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>H</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>image_iff</span><span> </span><span>literal.exhaust_sel</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SS&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>isasat_input_bounded.init_dt_wl_heur_init_dt_wl</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_curry</span><span class="delimiter">,</span><span>
</span><span>            </span><span>unfolded</span><span> </span><span>comp_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bounded</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T&#39;</span><span> </span><span>distinct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isasat_input_ops.twl_st_heur_init_def</span><span>
</span><span>            </span><span>isasat_input_ops.twl_st_heur_init_wl_def</span><span> </span><span>distinct_mset_set_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isasat_input_ops.twl_st_heur_init_def</span><span>
</span><span>            </span><span>isasat_input_ops.twl_st_heur_init_wl_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>from_init_state</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f T &#8804; &#8659; (isasat_input_ops.twl_st_heur_init_wl (mset_set (extract_atms_clss CS&#39; {})))
          (RETURN (from_init_state T&#39;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>      </span><span>TT&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(T, T&#39;) &#8712; isasat_input_ops.twl_st_heur_init (mset_set (extract_atms_clss CS&#39; {}))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>T&#39;</span><span> </span><span>CS</span><span> </span><span>CS&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TT&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isasat_input_ops.twl_st_heur_init_def</span><span> </span><span>from_init_state_def</span><span>
</span><span>         </span><span>isasat_input_ops.twl_st_heur_init_wl_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>RETURN_as_SPEC_refine</span><span class="delimiter">[</span><span>refine2</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsaSAT_heur_alt_def</span><span> </span><span>IsaSAT_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span> </span><span>bind_refine</span><span> </span><span>if_refine</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span>
</span><span>           </span><span>init_state_wl_heur_init_state_wl</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>comp_def</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>           </span><span>init</span><span>
</span><span>           </span><span>from_init_state</span><span>
</span><span>           </span><span>isasat_input_ops.finalise_init_finalise_init</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>comp_def</span><span class="delimiter">]</span><span>
</span><span>           </span><span>isasat_input_bounded_nempty.cdcl_twl_stgy_prog_wl_D_heur_cdcl_twl_stgy_prog_wl_D</span><span>
</span><span>             </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_explode</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>comp_def</span><span class="delimiter">]</span><span>
</span><span>           </span><span>isasat_input_bounded_nempty_cdcl_twl_stgy_restart_prog_wl_D_heur_break_cdcl_twl_stgy_prog_wl_D&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>assumption</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>assumption</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>empty_init_code_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS</span><span> </span><span>CS&#39;</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>p</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>empty_conflict_code_def</span><span> </span><span>op_arl_empty_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>isasat_input_ops.twl_st_heur_init_vmtf_next_emptyD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>isasat_input_ops.twl_st_heur_init_vmtf_fstD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_conflict_wl_is_None_init_def</span><span> </span><span>get_conflict_wl_is_None_def</span><span>
</span><span>          </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>isasat_input_ops.twl_st_heur_init_wl</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*     subgoal for CS CS&#39; b S&#39; S T U&#39; U
      by (rule dom_m_le_uint_max)
    subgoal by fast
    subgoal by fast
    subgoal premises p
      using p(32)
      by (auto simp: extract_model_of_state_stat_def extract_model_of_state_def
          isasat_input_ops.twl_st_heur_def get_conflict_wl_is_None_heur_def
          get_conflict_wl_is_None_heur_init_def extract_state_stat_def rev_map
          get_conflict_wl_is_None_def split: option.splits)
    subgoal by auto
    apply assumption+
    subgoal by fast
    apply assumption+
    subgoal by simp
    subgoal premises p by (simp add: empty_init_code_def)
    subgoal by simp
    subgoal premises p by (simp add: empty_conflict_code_def op_arl_empty_def)
    subgoal by auto
    subgoal by auto
    subgoal
      by (auto simp: isasat_input_ops.get_clauses_wl_from_init_get_clauses_wl_heur_init
        intro: mset_subset_eq_add_left dest: H)
    subgoal
      by (auto dest: isasat_input_ops.twl_st_heur_init_vmtf_next_emptyD)
    subgoal
      by (auto dest!: isasat_input_ops.twl_st_heur_init_vmtf_fstD)
    subgoal
      by (auto simp: isasat_input_ops.twl_st_heur_init_def
        state_wl_l_def from_init_state_def)
    subgoal
      unfolding get_conflict_wl_is_None_init_def get_conflict_wl_is_None by meson
    apply assumption+
    subgoal
      by (rule isasat_input_ops.twl_st_heur_init_wl) *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>p</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span class="delimiter">(</span><span>27</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_model_of_state_stat_def</span><span> </span><span>extract_model_of_state_def</span><span>
</span><span>          </span><span>isasat_input_ops.twl_st_heur_def</span><span> </span><span>get_conflict_wl_is_None_heur_def</span><span>
</span><span>          </span><span>get_conflict_wl_is_None_heur_init_def</span><span> </span><span>extract_state_stat_def</span><span> </span><span>rev_map</span><span>
</span><span>          </span><span>isasat_input_ops.option_lookup_clause_rel_def</span><span>
</span><span>          </span><span>get_conflict_wl_is_None_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite (extract_atms_clss CS {})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_atms_clss_alt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>IsaSAT_code</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(IsaSAT_code, SAT&#39;)
    &#8712; [&#955;x. Multiset.Ball x distinct_mset &#8743; (&#8704;C&#8712;#x. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max)]<span class="hidden">&#8681;</span><sub>a</sub>
      clauses_l_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; model_assn&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>empty_trail</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;empty_trail = Some ([] :: nat literal list)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;B = C &#10233; ((A :: _ nres) &#10524; B) = ((A :: _ nres) &#10524; C)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset_set (extract_atms_clss CS {}) &#8800; {#} &#10231; extract_atms_clss CS {} &#8800; {}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mset_set_empty_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;extract_atms_clss CS {}&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IsaSAT</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;IsaSAT CS = do {
     ASSERT (isasat_input_bounded (mset_set (extract_atms_clss CS {})));
     ASSERT (distinct_mset (mset_set (extract_atms_clss CS {})));
     T &#8592; SAT_wl CS;
     RETURN (if get_conflict_wl T = None then extract_model_of_state T else None)
    }&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>IsaSAT_def</span><span> </span><span>SAT_wl_def</span><span> </span><span>Let_def</span><span> </span><span>get_conflict_wl_is_None_init_def</span><span>
</span><span>     </span><span>finalise_init_def</span><span> </span><span>id_def</span><span> </span><span>get_conflict_wl_is_None</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>empty_trail_def</span><span>
</span><span>     </span><span>extract_model_of_state_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>bind_cong</span><span> </span><span>simp</span><span class="delimiter">:</span><span>  </span><span>intro</span><span class="delimiter">:</span><span> </span><span>bind_cong</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>1</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Multiset.Ball y distinct_mset &#10233;
       (x, y) &#8712; list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel &#10233;
        (&#8704;C&#8712;#y. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max) &#10233;
       SAT_wl x &#8804; &#8659; TWL_to_clauses_state_conv (SAT y)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_twl_stgy_prog_wl_spec_final2</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>fref_def</span><span> </span><span>nres_rel_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SAT&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;SAT&#39; CS =
       do {
          ASSERT(True);ASSERT(True);
          U &#8592; SAT CS;
          RETURN(if conflicting U = None then Some (map lit_of (trail U)) else None)
      }&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>CS</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SAT&#39;_def</span><span> </span><span>SAT_def</span><span> </span><span>empty_trail_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>RES_RETURN_RES</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ASSERT (isasat_input_bounded (mset_set (extract_atms_clss x {}))) &#8804; &#8659; unit_rel (ASSERT True)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>CS_p</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8704;C&#8712;#y. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>CS</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(x, y) &#8712; list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ASSERT_refine</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isasat_input_bounded_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> (mset_set (extract_atms_clss x {}))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C&#8712;set x &#8743; (L &#8712;set C &#8744; - L &#8712; set C)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_atms_clss_alt_def</span><span> </span><span>uint_max_def</span><span> </span><span>nat_of_uint32_uint32_of_nat_id</span><span>
</span><span>          </span><span>isasat_input_ops.&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>literal.exhaust_sel</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;C&#8712;#y. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CS_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_of_lit L &#8804; uint_max &#8744; nat_of_lit (-L) &#8804; uint_max&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span>CS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>list_mset_rel_def</span><span> </span><span>br_def</span><span> </span><span>mset_rel_def</span><span> </span><span>rel2p_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>p2rel_def</span><span>
</span><span>        </span><span>rel_mset_def</span><span> </span><span>list_all2_op_eq_map_right_iff&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_of_lit L &#8804; uint_max&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extract_atms_clss_alt_def</span><span> </span><span>uint_max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ASSERT (distinct_mset (mset_set (extract_atms_clss x {}))) &#8804; &#8659; unit_rel (ASSERT True)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IsaSAT_SAT</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(IsaSAT, SAT&#39;) &#8712;
     [&#955;CS. Multiset.Ball CS distinct_mset &#8743;
      (&#8704;C&#8712;#CS. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max)]<span class="hidden">&#8681;</span><sub>f</sub>
     list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel &#8594; &#10216;&#10216;&#10216;Id&#10217;list_rel&#10217; option_rel&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>SAT&#39;</span><span> </span><span>IsaSAT</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span> </span><span>bind_refine</span><span> </span><span>if_refine</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>3</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>4</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>TWL_to_clauses_state_conv_def</span><span> </span><span>extract_model_of_state_def</span><span>
</span><span>        </span><span>state_wl_l_def</span><span> </span><span>twl_st_l_def</span><span> </span><span>convert_lits_l_map_lit_of</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; &#8593; (x = map_option rev ac) =  &#8593; (ac = map_option rev x)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>ac</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ac</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hr_comp model_stat_assn
        (Collect (case_prod (&#955;(M, stat). (=) (map_option rev M)))) = model_assn&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>model_assn_def</span><span> </span><span>hr_comp_def</span><span> </span><span>model_stat_rel_def</span><span> </span><span>ex_assn_pair_split</span><span> </span><span>eq_commute</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(IsaSAT_code, IsaSAT)
      &#8712; [&#955;x. Ball (set x) distinct  &#8743; (&#8704;C&#8712;set x. &#8704;L&#8712;set C. nat_of_lit L &#8804; uint_max)]<span class="hidden">&#8681;</span><sub>a</sub>
         (list_assn (list_assn unat_lit_assn))<span class="hidden">&#8679;</span><sup>k</sup> &#8594; model_assn&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IsaSAT_code.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>IsaSAT_heur_IsaSAT</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list_assn_list_mset_rel_clauses_l_assn</span><span> </span><span>H</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?c &#8712; [?pre]<span class="hidden">&#8681;</span><sub>a</sub> ?im &#8594; ?f&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?c &#8712;
       [comp_PRE (list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel)
          (&#955;CS. Multiset.Ball CS distinct_mset &#8743; (&#8704;C&#8712;#CS. &#8704;L&#8712;#C. nat_of_lit L &#8804; uint_max))
          (&#955;x y. Ball (set y) distinct  &#8743; (&#8704;C&#8712;set y. &#8704;L&#8712;set C. nat_of_lit L &#8804; uint_max))
           (&#955;x. nofail (SAT&#39; x))]<span class="hidden">&#8681;</span><sub>a</sub>
       hrp_comp ((list_assn (list_assn unat_lit_assn))<span class="hidden">&#8679;</span><sup>k</sup>) (list_mset_rel O &#10216;list_mset_rel&#10217;mset_rel) &#8594;
       hr_comp model_assn  (&#10216;&#10216;nat_lit_lit_rel&#10217;list_rel&#10217;option_rel)&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8712; [?pre&#39;]<span class="hidden">&#8681;</span><sub>a</sub> ?im&#39; &#8594; ?f&#39;&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hfref_compI_PRE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>H</span><span> </span><span>IsaSAT_SAT</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pre</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?pre&#39; x&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?pre x&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_PRE_def</span><span> </span><span>list_mset_rel_def</span><span> </span><span>br_def</span><span>
</span><span>          </span><span>mset_rel_def</span><span> </span><span>p2rel_def</span><span> </span><span>rel2p_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>rel_mset_def</span><span>
</span><span>          </span><span>list_all2_op_eq_map_right_iff&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>im</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?im&#39; = ?im&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>prod_hrp_comp</span><span> </span><span>hrp_comp_dest</span><span> </span><span>hrp_comp_keep</span><span>
</span><span>        </span><span>list_assn_list_mset_rel_clauses_l_assn</span><span>
</span><span>      </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?f&#39; = ?f&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_weaken_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>im</span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pre</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Final correctness theorem:&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>IsaSAT_code_full_correctness</span><span> </span><span class="delimiter">=</span><span> </span><span>IsaSAT_code</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>SAT_model_if_satisfiable</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2018 </td><td align="center">26d8aaa66074 </td><td align="center">24d4e5b9 </td><td align="center">Tue 06 Nov 2018 04:20:56 PM CET </td></tr></table></p></footer></div>

<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2019 </td><td align="center">93cdb54371e6+ </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:14:54 AM CEST </td></tr></table></p></footer></div>

<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:25:56 AM CEST </td></tr></table></p></footer></div>

</html>






