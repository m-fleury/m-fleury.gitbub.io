<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory IsaSAT_Trail (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory IsaSAT_Trail</h1>

<span class="command">theory</span> <span class="name">IsaSAT_Trail</span><br/>
<span class="keyword">imports</span> <a href="IsaSAT_Literals.html"><span class="name">IsaSAT_Literals</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IsaSAT_Trail</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IsaSAT_Literals</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Efficient Trail&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Our trail contains several additional information compared to the simple trail:
  &#9642; the (reversed) trail in an array (i.e., the trail in the same order as presented in
  ``Automated Reasoning&#39;&#39;);
  &#9642; the mapping from any &#8727;&#8249;literal&#8250; (and not an atom) to its polarity;
  &#9642; the mapping from a &#8727;&#8249;atom&#8250; to its level or reason (in two different arrays);
  &#9642; the current level of the state;
  &#9642; the control stack.

We copied the idea from the mapping from a literals to it polarity instead of an atom to its
polarity from a comment by Armin Biere in CaDiCal. We only observed a (at best) faint
performance increase, but as it seemed slightly faster and does not increase the length of the
formalisation, we kept it.

The control stack is the latest addition: it contains the positions of the decisions in the trail.
It is mostly to enable fast restarts (since it allows to directly iterate over all decision of the
trail), but might also slightly speed up backjumping (since we know how far we are going back in the
trail). Remark that the control stack contains is not updated during the backjumping, but only
&#8727;&#8249;after&#8250; doing it (as we keep only the the beginning of it).
&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Polarities&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>tri_bool</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bool option&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>UNSET</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tri_bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;UNSET = None&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SET_FALSE</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tri_bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;SET_FALSE = Some False&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>SET_TRUE</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tri_bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;SET_TRUE = Some True&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>tri_bool_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tri_bool &#8658; tri_bool &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tri_bool_eq = (=)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Types&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>trail_pol</span><span> </span><span class="delimiter">=</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat literal list &#215; tri_bool list &#215; nat list &#215; nat list &#215; nat &#215; nat list&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_level_atm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level_atm M L = get_level M (Pos L)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>polarity_atm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity_atm M L =
    (if Pos L &#8712; lits_of_l M then SET_TRUE
    else if Neg L &#8712; lits_of_l M then SET_FALSE
    else None)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>defined_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, nat) ann_lits &#8658; &#39;v &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_atm M L = defined_lit M (Pos L)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>undefined_atm</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_atm M L &#8801; &#172;defined_atm M L&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Control Stack&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>control_stack</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack [] []&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>cons_prop</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M &#10233; control_stack cs (Propagated L C # M)&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>cons_dec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M &#10233; n = length M &#10233; control_stack (cs @ [n]) (Decided L # M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>control_stackE</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_length_count_dec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M &#10233; length cs = count_decided M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>control_stack.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_le_length_M</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M &#10233; c&#8712;set cs &#10233; c &lt; length M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>control_stack.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_propa</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs (Propagated x21 x22 # list) &#10231; control_stack cs list&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>control_stack.intros</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>control_stackE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_filter_map_nth</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M &#10233; filter is_decided (rev M) = map (nth (rev M)) cs&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>control_stack.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>cs</span><span> </span><span>M</span><span> </span><span>L</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>control_stack_le_length_M</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>cs</span><span> </span><span>M</span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>control_stack_le_length_M</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_empty_cs</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack [] M &#10231; count_decided M = 0&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M</span><span> </span><span>rule</span><span class="delimiter">:</span><span>ann_lit_list_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>control_stack.empty</span><span> </span><span>control_stack.cons_prop</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>control_stackE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This is an other possible definition. It is not inductive, which makes it easier to reason
about appending (or removing) some literals from the trail. It is however much less clear if the
definition is correct.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>control_stack&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack&#39; cs M &#10231;
     (length cs = count_decided M &#8743;
       (&#8704;L&#8712;set M. is_decided L &#10230; (cs ! (get_level M (lit_of L) - 1) &lt; length M &#8743;
          rev M!(cs ! (get_level M (lit_of L) - 1)) = L)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_rev_get_lev</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M  &#10233;
    no_dup M &#10233; L&#8712;set M &#10233; is_decided L &#10233; rev M!(cs ! (get_level M (lit_of L) - 1)) = L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>L</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>control_stack.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>cs</span><span> </span><span>M</span><span> </span><span>L</span><span> </span><span>C</span><span> </span><span>La</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>control_stack_le_length_M</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>M</span><span class="delimiter">]</span><span> </span><span>control_stack_length_count_dec</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>      </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of La&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>nth_append</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>undefined_notin</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_count_decided_gt_get_level</span><span> </span><span>Suc_less_eq</span><span> </span><span>Suc_pred</span><span> </span><span>count_decided_0_iff</span><span> </span><span>diff_is_0_eq</span><span>
</span><span>        </span><span>le_SucI</span><span> </span><span>le_refl</span><span> </span><span>neq0_conv</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>cs</span><span> </span><span>M</span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>control_stack_le_length_M</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>M</span><span class="delimiter">]</span><span> </span><span>control_stack_length_count_dec</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span> </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>undefined_notin</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_count_decided_gt_get_level</span><span> </span><span>Suc_less_eq</span><span> </span><span>Suc_pred</span><span> </span><span>count_decided_0_iff</span><span> </span><span>diff_is_0_eq</span><span>
</span><span>        </span><span>le_SucI</span><span> </span><span>le_refl</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_alt_def_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M &#10233; (&#8896;L. L &#8712;set M &#10233; is_decided L &#10233; cs ! (get_level M (lit_of L) - 1) &lt; length M &#8743;
        rev M!(cs ! (get_level M (lit_of L) - 1)) = L) &#10233;
    length cs = count_decided M &#10233;
    control_stack cs M&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>cs</span><span> </span><span>rule</span><span class="delimiter">:</span><span>ann_lit_list_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Decided</span><span> </span><span>L</span><span> </span><span>M</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_d</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dec</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>length</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs&#39;</span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cs</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cs = cs&#39; @ [n]&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rev M ! n &#8712; set M &#10233; is_decided (rev M ! n) &#10233; count_decided M &#8800; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_decided_0_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dec&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39;&#8712;set M &#10233; is_decided L&#39; &#10233; cs&#39; ! (get_level M (lit_of L&#39;) - 1) &lt; length M &#8743;
        rev M ! (cs&#39; ! (get_level M (lit_of L&#39;) - 1)) = L&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec</span><span class="delimiter">[</span><span>of</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span> </span><span>n_d</span><span> </span><span>length</span><span>
</span><span>    </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of L&#39;&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>undefined_notin</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length cs&#39; = count_decided M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n = length M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>dec</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>le</span><span> </span><span>undefined_notin</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rev M ! n&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>nth_mem</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rev M&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cs</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>control_stack.cons_dec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IH</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>dec&#39;</span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Propagated</span><span> </span><span>L</span><span> </span><span>m</span><span> </span><span>M</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_d</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>dec</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>length</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rev M ! n &#8712; set M &#10233; is_decided (rev M ! n) &#10233; count_decided M &#8800; 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_decided_0_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dec&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39;&#8712;set M &#10233; is_decided L&#39; &#10233; cs ! (get_level M (lit_of L&#39;) - 1) &lt; length M &#8743;
        rev M ! (cs ! (get_level M (lit_of L&#39;) - 1)) = L&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec</span><span class="delimiter">[</span><span>of</span><span> </span><span>L&#39;</span><span class="delimiter">]</span><span> </span><span>n_d</span><span> </span><span>length</span><span>
</span><span>    </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of L&#39;&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>undefined_notin</span><span>
</span><span>        </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>control_stack.cons_prop</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>IH</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_alt_def</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M &#10233; control_stack&#39; cs M &#10231; control_stack cs M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>control_stack_alt_def_imp</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span>cs</span><span class="delimiter">]</span><span> </span><span>control_stack_rev_get_lev</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>    </span><span>control_stack_length_count_dec</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>M</span><span class="delimiter">]</span><span> </span><span>control_stack_le_length_M</span><span class="delimiter">[</span><span>of</span><span> </span><span>cs</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>control_stack&#39;_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_count_decided_gt_get_level</span><span> </span><span>Suc_less_eq</span><span> </span><span>Suc_pred</span><span> </span><span>count_decided_0_iff</span><span>
</span><span>        </span><span>less_imp_diff_less</span><span> </span><span>neq0_conv</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_decomp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided L # M1, M2) &#8712; set (get_all_ann_decomposition M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack (take (count_decided M1) cs) M1&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M3 @ M2 @ Decided L # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39; = M3 @ M2&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M = M2&#39; @ Decided L # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span>M2&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>no_dup_appendD</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack&#39; cs M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cs</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>control_stack_alt_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>n_d</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>cs_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length cs = count_decided M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L. L&#8712;set M &#10233; is_decided L &#10233;
      cs ! (get_level M (lit_of L) - 1) &lt; length M &#8743; rev M ! (cs ! (get_level M (lit_of L) - 1)) = L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>control_stack&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712; set M1 &#10233; undefined_lit M2&#39; (lit_of L&#39;) &#8743; atm_of (lit_of L&#39;) &#8800; atm_of L&#8250;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>defined_lit_no_dupD</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>defined_lit_uminus</span><span> </span><span>lit_of.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span>no_dup_appendD</span><span> </span><span>no_dup_append_cons</span><span> </span><span>no_dup_cons</span><span> </span><span>undefined_notin</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup_imp_distinct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_d</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#39; &#8712; set M1 &#10233; x &lt; length M &#10233; rev M ! x = L&#39; &#10233; x &lt; length M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>L&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span> </span><span>nth_Cons</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>nat.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_rev</span><span> </span><span>less_diff_conv</span><span> </span><span>local.H</span><span> </span><span>not_less_eq</span><span> </span><span>nth_mem</span><span> </span><span>set_rev</span><span> </span><span>undefined_notin</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set M1 &#10233; is_decided L &#10233; get_level M1 (lit_of L) &gt; 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>split_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cs&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack&#39; (take (count_decided M1) cs) M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>control_stack&#39;_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>ballI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cs_M</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>L</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>K</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cs ! (get_level M1 (lit_of L) - Suc 0)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>I</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>L</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>K</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cs ! (get_level M1 (lit_of L) - Suc 0)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>I</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>control_stack_alt_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>n_d1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cs&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Encoding of the reasons&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>DECISION_REASON</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECISION_REASON = 1&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ann_lits_split_reasons</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ann_lits_split_reasons &#119964; = {((M, reasons), M&#39;). M = map lit_of (rev M&#39;) &#8743;
    (&#8704;L &#8712; set M&#39;. is_proped L &#10230;
        reasons ! (atm_of (lit_of L)) = mark_of L &#8743; mark_of L &#8800; DECISION_REASON) &#8743;
    (&#8704;L &#8712; set M&#39;. is_decided L &#10230; reasons ! (atm_of (lit_of L)) = DECISION_REASON) &#8743;
    (&#8704;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;. atm_of L &lt; length reasons)
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trail_pol</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat multiset &#8658; (trail_pol &#215; (nat, nat) ann_lits) set&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#119964; =
   {((M&#39;, xs, lvls, reasons, k, cs), M). ((M&#39;, reasons), M) &#8712; ann_lits_split_reasons &#119964; &#8743;
    no_dup M &#8743;
    (&#8704;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;. nat_of_lit L &lt; length xs &#8743; xs ! (nat_of_lit L) = polarity M L) &#8743;
    (&#8704;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;. atm_of L &lt; length lvls &#8743; lvls ! (atm_of L) = get_level M L) &#8743;
    k = count_decided M &#8743;
    (&#8704;L&#8712;set M. lit_of L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;) &#8743;
    control_stack cs M &#8743;
    isasat_input_bounded &#119964;}&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definition of the full trail&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trail_pol_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#119964; = {((M&#39;, xs, lvls, reasons, k, cs), M).
    ((M&#39;, reasons), M) &#8712; ann_lits_split_reasons &#119964; &#8743;
    no_dup M &#8743;
    (&#8704;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;. nat_of_lit L &lt; length xs &#8743; xs ! (nat_of_lit L) = polarity M L) &#8743;
    (&#8704;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;. atm_of L &lt; length lvls &#8743; lvls ! (atm_of L) = get_level M L) &#8743;
    k = count_decided M &#8743;
    (&#8704;L&#8712;set M. lit_of L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;) &#8743;
    control_stack cs M &#8743; literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_trail &#119964; M &#8743;
    length M &lt; uint32_max &#8743;
    length M &#8804; uint32_max div 2 + 1 &#8743;
    count_decided M &lt; uint32_max &#8743;
    length M&#39; = length M &#8743;
    M&#39; = map lit_of (rev M) &#8743;
    isasat_input_bounded &#119964;
   }&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M &lt; n &#10233; count_decided M &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_filter_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>is_decided</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_trail_def</span><span> </span><span>uint32_max_def</span><span> </span><span>count_decided_def</span><span>
</span><span>        </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>length_filter_le</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>length_trail_uint32_max_div2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trail_pol_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_trail_def</span><span> </span><span>uint32_max_def</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>length_trail_uint32_max_div2</span><span>
</span><span>	</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>isasat_input_bounded_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Code generation&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Conversion between incomplete and complete mode&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trail_fast_of_slow</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat, nat) ann_lits &#8658; (nat, nat) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_fast_of_slow = id&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trail_pol_slow_of_fast</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; trail_pol&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol_slow_of_fast =
    (&#955;(M, val, lvls, reason, k, cs). (M, val, lvls, reason, k, cs))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trail_slow_of_fast</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat, nat) ann_lits &#8658; (nat, nat) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_slow_of_fast = id&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trail_pol_fast_of_slow</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; trail_pol&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol_fast_of_slow =
    (&#955;(M, val, lvls, reason, k, cs). (M, val, lvls, reason, k, cs))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trail_pol_slow_of_fast_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol_slow_of_fast M = M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_slow_of_fast_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trail_pol_fast_of_slow_trail_fast_of_slow</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o trail_pol_fast_of_slow, RETURN o trail_fast_of_slow)
    &#8712; [&#955;M. (&#8704;C L. Propagated L C &#8712; set M &#10230; C &lt; uint64_max)]<span class="hidden">&#8681;</span><sub>f</sub>
        trail_pol &#119964; &#8594; &#10216;trail_pol &#119964;&#10217; nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>trail_pol_fast_of_slow_def</span><span>
</span><span>    </span><span>trail_fast_of_slow_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trail_pol_slow_of_fast_trail_slow_of_fast</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o trail_pol_slow_of_fast, RETURN o trail_slow_of_fast)
    &#8712; trail_pol &#119964; &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;trail_pol &#119964;&#10217; nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>trail_pol_fast_of_slow_def</span><span>
</span><span>     </span><span>trail_fast_of_slow_def</span><span> </span><span>trail_slow_of_fast_def</span><span>
</span><span>     </span><span>trail_pol_slow_of_fast_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trail_pol_same_length</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964; &#10233; length (fst M&#39;) = length M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_alt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>counts_maximum_level</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;counts_maximum_level M C = {i. C &#8800; None &#10230; i = card_max_lvl M (the C)}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>counts_maximum_level_None</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;counts_maximum_level M None = Collect (&#955;_. True)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>counts_maximum_level_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Level of a literal&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_level_atm_pol_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level_atm_pol_pre = (&#955;((M, xs, lvls, k), L). L &lt; length lvls)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_level_atm_pol</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; nat &#8658; nat&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level_atm_pol = (&#955;(M, xs, lvls, k) L. lvls ! L)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_level_atm_pol_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level_atm_pol_pre (M&#39;, L)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>nat_lit_rel_def</span><span>
</span><span>    </span><span>br_def</span><span> </span><span>get_level_atm_pol_pre_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>get_level_get_level_atm</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = get_level_atm M (atm_of L)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>get_level_atm_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_Neg_Pos</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_level_pol</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level_pol M L = get_level_atm_pol M (atm_of L)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_level_pol_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level_pol_pre = (&#955;((M, xs, lvls, k), L). atm_of L &lt; length lvls)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_level_pol_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level_pol_pre (M&#39;, L)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>nat_lit_rel_def</span><span>
</span><span>     </span><span>br_def</span><span> </span><span>get_level_pol_pre_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_level_get_level_pol</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M L = get_level_pol M&#39; L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_pol_def</span><span> </span><span>get_level_atm_pol_def</span><span> </span><span>trail_pol_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Current level&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>count_decided_pol</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided_pol = (&#955;(_, _, _, _, k, _). k)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>count_decided_trail_ref</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o count_decided_pol, RETURN o count_decided) &#8712; trail_pol &#119964; &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;nat_rel&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>count_decided_pol_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Polarity&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>polarity_pol</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; nat literal &#8658; bool option&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity_pol = (&#955;(M, xs, lvls, k) L. do {
     xs ! (nat_of_lit L)
  })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>polarity_pol_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;polarity_pol_pre = (&#955;(M, xs, lvls, k) L. nat_of_lit L &lt; length xs)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>polarity_pol_polarity</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry (RETURN oo polarity_pol), uncurry (RETURN oo polarity)) &#8712;
     [&#955;(M, L). L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id &#8594; &#10216;&#10216;bool_rel&#10217;option_rel&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>nres_relI</span><span> </span><span>frefI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>polarity_def</span><span> </span><span>polarity_pol_def</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>polarity_pol_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964; &#10233; L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964; &#10233; polarity_pol_pre M&#39; L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>polarity_def</span><span> </span><span>polarity_pol_def</span><span> </span><span>polarity_pol_pre_def</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Length of the trail&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>isa_length_trail_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_length_trail_pre = (&#955; (M&#39;, xs, lvls, reasons, k, cs). length M&#39; &#8804; uint32_max)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>isa_length_trail</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_length_trail = (&#955; (M&#39;, xs, lvls, reasons, k, cs). length_uint32_nat M&#39;)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_length_trail_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M, M&#39;) &#8712; trail_pol &#119964; &#10233; isa_length_trail_pre M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_length_trail_def</span><span> </span><span>trail_pol_alt_def</span><span> </span><span>isa_length_trail_pre_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_length_trail_length_u</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o isa_length_trail, RETURN o length_uint32_nat) &#8712; trail_pol &#119964; &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;nat_rel&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_length_trail_def</span><span> </span><span>trail_pol_alt_def</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ASSERT_leI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mop_isa_length_trail</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mop_isa_length_trail = (&#955;(M). do {
    ASSERT(isa_length_trail_pre M);
    RETURN (isa_length_trail M)
  })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mop_isa_length_trail_length_u</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(mop_isa_length_trail, RETURN o length_uint32_nat) &#8712; trail_pol &#119964; &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;nat_rel&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mop_isa_length_trail_def</span><span> </span><span>isa_length_trail_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>isa_length_trail_pre</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ASSERT_leI</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_alt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Consing elements&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cons_trail_Propagated_tr_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail_Propagated_tr_pre = (&#955;((L, C), (M, xs, lvls, reasons, k)). nat_of_lit L &lt; length xs &#8743;
    nat_of_lit (-L) &lt; length xs &#8743; atm_of L &lt; length lvls &#8743; atm_of L &lt; length reasons &#8743; length M &lt; uint32_max)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cons_trail_Propagated_tr</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat literal &#8658; nat &#8658; trail_pol &#8658; trail_pol nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail_Propagated_tr = (&#955;L C (M&#39;, xs, lvls, reasons, k, cs). do {
     ASSERT(cons_trail_Propagated_tr_pre ((L, C), (M&#39;, xs, lvls, reasons, k, cs)));
     RETURN (M&#39; @ [L], let xs = xs[nat_of_lit L := SET_TRUE] in xs[nat_of_lit (-L) := SET_FALSE],
      lvls[atm_of L := k], reasons[atm_of L:= C], k, cs)})&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_list_pos_neg_notD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (atm_of (lit_of La)) &#8713; lits_of_l bc &#10233;
       Neg (atm_of (lit_of La)) &#8713; lits_of_l bc &#10233;
       La &#8712; set bc &#10233; False&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Neg_atm_of_iff</span><span> </span><span>Pos_atm_of_iff</span><span> </span><span>lits_of_def</span><span> </span><span>rev_image_eqI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cons_trail_Propagated_tr_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8800; DECISION_REASON&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail_Propagated_tr_pre ((L, C), M&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_alt_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>uminus_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_iff</span><span>
</span><span>       </span><span>cons_trail_Propagated_tr_pre_def</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cons_trail_Propagated_tr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry2 (cons_trail_Propagated_tr), uncurry2 (cons_trail_propagate_l)) &#8712;
   [&#955;((L, C), M). L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964; &#8743; C &#8800; DECISION_REASON]<span class="hidden">&#8681;</span><sub>f</sub>
    Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#8594; &#10216;trail_pol &#119964;&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cons_trail_Propagated_tr_def</span><span> </span><span>cons_trail_propagate_l_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cons_trail_Propagated_tr_pre</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (x)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (y)&#8250;</span></span></span><span> </span><span>&#119964;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (fst y)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (fst y)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uncurry_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (fst y)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>polarity_def</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>        </span><span>cons_trail_Propagated_tr_def</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>nth_list_update&#39;</span><span>
</span><span>        </span><span>ann_lits_split_reasons_def</span><span> </span><span>atms_of_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span>
</span><span>        </span><span>uminus_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_iff</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ASSERT_refine_right</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_list_pos_neg_notD</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>pos_lit_in_atms_of</span><span> </span><span>neg_lit_in_atms_of</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span>
</span><span>      </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>nat_of_lit.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cons_trail_Propagated_tr2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(((L, C), M), ((L&#39;, C&#39;), M&#39;)) &#8712; Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#10233; L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964; &#10233;
      C &#8800; DECISION_REASON &#10233;
  cons_trail_Propagated_tr L C M
  &#8804; &#8659; ({(M&#39;&#39;, M&#39;&#39;&#39;). (M&#39;&#39;, M&#39;&#39;&#39;) &#8712; trail_pol &#119964; &#8743; M&#39;&#39;&#39; = Propagated L C # M&#39; &#8743; no_dup M&#39;&#39;&#39;})
      (cons_trail_propagate_l L&#39; C&#39; M&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cons_trail_Propagated_tr</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fref_to_Down_curry2</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>&#119964;</span><span> </span><span>L&#39;</span><span> </span><span>C&#39;</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>C</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cons_trail_Propagated_tr_def</span><span> </span><span>cons_trail_propagate_l_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cons_trail_Propagated_tr_pre</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span>M&#39;</span><span> </span><span>&#119964;</span><span> </span><span>L</span><span> </span><span>C</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uncurry_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>refine_vcg</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>undefined_lit_count_decided_uint32_max</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>M_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub></span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#8712;set M. lit_of L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_bounded &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (count_decided M) &#8804; uint32_max&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_atm_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset {#atm_of (lit_of x). x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distinct_mset_mset_distinct</span><span> </span><span>mset_map</span><span> </span><span>no_dup_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>incl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of `# lit_of `# mset (Decided L # M) &#8838;# remdups_mset (atm_of `# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_subseteq_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>dist_atm_M</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>lits_of_def</span><span> </span><span>no_dup_distinct</span><span>
</span><span>        </span><span>atm_of_eq_atm_of</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>size_mset_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M + 1 &#8804; size (remdups_mset (atm_of `# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_filter_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>is_decided</span><span> </span><span>M</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint32_max_def</span><span> </span><span>count_decided_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>length_filter_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inj_on</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inj_on nat_of_lit (set_mset (remdups_mset (&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964; &#10233; atm_of xa &#8804; uint32_max div 2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xa</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uint32_max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remdups_mset (atm_of `# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;) &#8838;# mset [0..&lt; 1 + (uint32_max div 2)]&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_subseteq_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>distinct_image_mset_inj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inj_on</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>literal_of_nat.simps</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_mset_set</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>le_neq_implies_less</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>_</span><span> </span><span class="delimiter">=</span><span> </span><span>size_mset_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (nat_of_lit `# remdups_mset (&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;)) = size (remdups_mset (&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (remdups_mset (atm_of `# (&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;))) &#8804; 1 + uint32_max div 2&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uint32_max_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>size_mset_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>incl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M + 1 &#8804; size (remdups_mset (atm_of `# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint32_max_def</span><span> </span><span>count_decided_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>length_filter_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M  &#8804; uint32_max&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_trail_uint32_max</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>M_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub></span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#8712;set M. lit_of L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>bounded</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isasat_input_bounded &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M &#8804; uint32_max&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_atm_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset {#atm_of (lit_of x). x &#8712;# mset M#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distinct_mset_mset_distinct</span><span> </span><span>mset_map</span><span> </span><span>no_dup_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>incl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of `# lit_of `# mset M &#8838;# remdups_mset (atm_of `# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_subseteq_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>dist_atm_M</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>lits_of_def</span><span> </span><span>no_dup_distinct</span><span>
</span><span>        </span><span>atm_of_eq_atm_of</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inj_on</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inj_on nat_of_lit (set_mset (remdups_mset (&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964; &#10233; atm_of xa &#8804; uint32_max div 2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xa</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bounded</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uint32_max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remdups_mset (atm_of `# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;) &#8838;# mset [0..&lt; 1 + (uint32_max div 2)]&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_subseteq_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>distinct_image_mset_inj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>inj_on</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>literal_of_nat.simps</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_mset_set</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>le_neq_implies_less</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>_</span><span> </span><span class="delimiter">=</span><span> </span><span>size_mset_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (nat_of_lit `# remdups_mset (&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;)) = size (remdups_mset (&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (remdups_mset (atm_of `# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;)) &#8804; 1 + uint32_max div 2&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>size_mset_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>incl</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M &#8804; size (remdups_mset (atm_of `# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>uint32_max_def</span><span> </span><span>count_decided_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>length_filter_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>uint32_max_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>last_trail_pol_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;last_trail_pol_pre = (&#955;(M, xs, lvls, reasons, k). atm_of (last M) &lt; length reasons &#8743; M &#8800; [])&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>last_trail_pol</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; (nat literal &#215; nat option)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;last_trail_pol = (&#955;(M, xs, lvls, reasons, k).
      let r = reasons ! (atm_of (last M)) in
      (last M, if r = DECISION_REASON then None else Some r))&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tl_trailt_tr</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; trail_pol&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trailt_tr = (&#955;(M&#39;, xs, lvls, reasons, k, cs).
    let L = last M&#39; in
    (butlast M&#39;,
    let xs = xs[nat_of_lit L := None] in xs[nat_of_lit (-L) := None],
    lvls[atm_of L := 0],
    reasons, if reasons ! atm_of L = DECISION_REASON then k-1 else k,
      if reasons ! atm_of L = DECISION_REASON then butlast cs else cs))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tl_trailt_tr_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trailt_tr_pre = (&#955;(M, xs, lvls, reason, k, cs). M &#8800; [] &#8743; nat_of_lit(last M) &lt; length xs &#8743;
        nat_of_lit(-last M) &lt; length xs  &#8743; atm_of (last M) &lt; length lvls &#8743;
        atm_of (last M) &lt; length reason &#8743;
        (reason ! atm_of (last M) = DECISION_REASON &#10230; k &#8805; 1 &#8743; cs &#8800; []))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ann_lits_split_reasons_map_lit_of</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((M, reasons), M&#39;) &#8712; ann_lits_split_reasons &#119964; &#10233; M = map lit_of (rev M&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ann_lits_split_reasons_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_dec_butlast</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack b (Decided x1 # M&#39;s) &#10233; control_stack (butlast b) M&#39;s&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>control_stackE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_trail_tr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((RETURN o tl_trailt_tr), (RETURN o tl)) &#8712;
    [&#955;M. M &#8800; []]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#8594; &#10216;trail_pol &#119964;&#10217;nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;y&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M&#39;s</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trail_pol_def</span><span> </span><span>comp_def</span><span> </span><span>RETURN_refine_iff</span><span> </span><span>trail_pol_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">;</span><span> </span><span>clarify</span><span class="delimiter">?</span><span class="delimiter">;</span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span>
</span><span>            </span><span>ann_lits_split_reasons_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_def</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span>
</span><span>            </span><span>uminus_lit_swap</span><span> </span><span>Let_def</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ann_lits_split_reasons_map_lit_of</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>Let_def</span><span>
</span><span>           </span><span>atm_of_eq_atm_of</span><span> </span><span>get_level_cons_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span>
</span><span>           </span><span>atm_of_eq_atm_of</span><span> </span><span>get_level_cons_if</span><span> </span><span>Let_def</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ann_lits_split_reasons_map_lit_of</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tl_trailt_tr_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>            </span><span>control_stack_dec_butlast</span><span>
</span><span>            </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_trailt_tr_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8800; []&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trailt_tr_pre M&#39;&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8800; [] &#10233; is_decided (last x) &#10233; Suc 0 &#8804; count_decided x&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hd M&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>uminus_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_iff</span><span>
</span><span>        </span><span>rev_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>hd_append</span><span> </span><span>hd_map</span><span>  </span><span>tl_trailt_tr_pre_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>rev_map</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tl_trail_propedt_tr</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; trail_pol&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trail_propedt_tr = (&#955;(M&#39;, xs, lvls, reasons, k, cs).
    let L = last M&#39; in
    (butlast M&#39;,
    let xs = xs[nat_of_lit L := None] in xs[nat_of_lit (-L) := None],
    lvls[atm_of L := 0],
    reasons, k, cs))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tl_trail_propedt_tr_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trail_propedt_tr_pre =
     (&#955;(M, xs, lvls, reason, k, cs). M &#8800; [] &#8743; nat_of_lit(last M) &lt; length xs &#8743;
        nat_of_lit(-last M) &lt; length xs  &#8743; atm_of (last M) &lt; length lvls &#8743;
        atm_of (last M) &lt; length reason)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_trail_propedt_tr_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8800; []&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trail_propedt_tr_pre M&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trail_pol_def</span><span> </span><span>comp_def</span><span> </span><span>RETURN_refine_iff</span><span> </span><span>trail_pol_def</span><span> </span><span>Let_def</span><span>
</span><span>    </span><span>tl_trail_propedt_tr_def</span><span> </span><span>tl_trail_propedt_tr_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M</span><span class="delimiter">;</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">;</span><span> </span><span>clarify</span><span class="delimiter">?</span><span class="delimiter">;</span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span>
</span><span>	</span><span>ann_lits_split_reasons_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span>
</span><span>       </span><span>atm_of_eq_atm_of</span><span> </span><span>get_level_cons_if</span><span> </span><span>Let_def</span><span>
</span><span>	</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ann_lits_split_reasons_map_lit_of</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hd M&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>	</span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hd M&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>	</span><span>control_stack_dec_butlast</span><span>
</span><span>	</span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hd M&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>	</span><span>control_stack_dec_butlast</span><span>
</span><span>	</span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>lit_of_hd_trail</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of_hd_trail M = lit_of (hd M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>lit_of_last_trail_pol</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of_last_trail_pol = (&#955;(M, _). last M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lit_of_last_trail_pol_lit_of_last_trail</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o lit_of_last_trail_pol, RETURN o lit_of_hd_trail) &#8712;
         [&#955;S. S &#8800; []]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#8594; &#10216;Id&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lit_of_hd_trail_def</span><span> </span><span>trail_pol_def</span><span> </span><span>lit_of_last_trail_pol_def</span><span>
</span><span>     </span><span>ann_lits_split_reasons_def</span><span> </span><span>hd_map</span><span> </span><span>rev_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>last_rev</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Setting a new literal&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cons_trail_Decided</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat literal &#8658; (nat, nat) ann_lits &#8658; (nat, nat) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail_Decided L M&#39; = Decided L # M&#39;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cons_trail_Decided_tr</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat literal &#8658; trail_pol &#8658; trail_pol&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail_Decided_tr = (&#955;L (M&#39;, xs, lvls, reasons, k, cs). do{
    let n = length M&#39; in
    (M&#39; @ [L], let xs = xs[nat_of_lit L := SET_TRUE] in xs[nat_of_lit (-L) := SET_FALSE],
      lvls[atm_of L := k+1], reasons[atm_of L := DECISION_REASON], k+1, cs @ [n])})&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cons_trail_Decided_tr_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail_Decided_tr_pre =
    (&#955;(L, (M, xs, lvls, reason, k, cs)). nat_of_lit L &lt; length xs &#8743; nat_of_lit (-L) &lt; length xs &#8743;
      atm_of L &lt; length lvls &#8743; atm_of L &lt; length reason  &#8743; length cs &lt; uint32_max &#8743;
      Suc k &#8804; uint32_max &#8743; length M &lt; uint32_max)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_cons_trail_Decided</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (cons_trail_Decided L M) = Suc (length M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cons_trail_Decided_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cons_trail_Decided_tr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry (RETURN oo cons_trail_Decided_tr), uncurry (RETURN oo cons_trail_Decided)) &#8712;
  [&#955;(L, M). undefined_lit M L &#8743; L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;]<span class="hidden">&#8681;</span><sub>f</sub> Id &#215;<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#8594; &#10216;trail_pol &#119964;&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst x&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>polarity_def</span><span> </span><span>cons_trail_Decided_def</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>        </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span>
</span><span>        </span><span>cons_trail_Decided_tr_def</span><span> </span><span>nth_list_update&#39;</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_list_pos_neg_notD</span><span> </span><span>multi_member_split</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>control_stack.cons_dec</span><span>
</span><span>      </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>nat_of_lit.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cons_trail_Decided_tr_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail_Decided_tr_pre (L, M&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_alt_def</span><span> </span><span>image_image</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>uminus_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_iff</span><span>
</span><span>         </span><span>cons_trail_Decided_tr_pre_def</span><span> </span><span>control_stack_length_count_dec</span><span>
</span><span>       </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>undefined_lit_count_decided_uint32_max</span><span> </span><span>length_trail_uint32_max</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Polarity: Defined or Undefined&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>defined_atm_pol_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_atm_pol_pre = (&#955;(M, xs, lvls, k) L. 2*L &lt; length xs &#8743;
      2*L &#8804; uint32_max)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>defined_atm_pol</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_atm_pol = (&#955;(M, xs, lvls, k) L. &#172;((xs!(2*L)) = None))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>undefined_atm_code</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry (RETURN oo defined_atm_pol), uncurry (RETURN oo defined_atm)) &#8712;
   [&#955;(M, L). Pos L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>r</sub> Id &#8594; &#10216;bool_rel&#10217; nres_rel&#8250;</span></span></span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?A</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>defined_atm_pol_pre</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964; &#10233; L &#8712;#  &#119964; &#10233; defined_atm_pol_pre M&#39; L&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;2*L &lt; length xs&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?length&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>none</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_atm M L &#10231; xs ! (2*L) &#8800; None&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?undef</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;2*L &#8804; uint32_max&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>L_N</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>tr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((M&#39;, xs, lvls, k), M) &#8712; trail_pol &#119964;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span> </span><span>xs</span><span> </span><span>lvls</span><span> </span><span>k</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; = map lit_of (rev M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;L&#8712;#&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;. nat_of_lit L &lt; length xs &#8743; xs ! nat_of_lit L = polarity M L&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tr</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trail_pol_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_of_lit (Pos L) &lt; length xs&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>xsL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xs ! (nat_of_lit (Pos L)) = polarity M (Pos L)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_N</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?length</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?undef</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xsL</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_def</span><span> </span><span>defined_atm_def</span><span>
</span><span>          </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;2*L &#8804; uint32_max&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tr</span><span> </span><span>L_N</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trail_pol_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>defined_atm_pol_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>5</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>none</span><span> </span><span>H</span><span> </span><span>le</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ASSERT_leI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol &#119964; &#10233; L &#8712;# &#119964; &#10233; defined_atm_pol_pre M&#39; L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_atm_pol_pre_def</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Reasons&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_propagation_reason_pol</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; nat literal &#8658; nat option nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_propagation_reason_pol = (&#955;(_, _, _, reasons, _) L. do {
      ASSERT(atm_of L &lt; length reasons);
      let r = reasons ! atm_of L;
      RETURN (if r = DECISION_REASON then None else Some r)})&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_propagation_reason_pol</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry get_propagation_reason_pol, uncurry get_propagation_reason) &#8712;
       [&#955;(M, L). L &#8712; lits_of_l M]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>r</sub> Id &#8594; &#10216;&#10216;nat_rel&#10217;option_rel&#10217; nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lits_of_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>aa</span><span> </span><span>ab</span><span> </span><span>ac</span><span> </span><span>b</span><span> </span><span>ba</span><span> </span><span>ad</span><span> </span><span>bb</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_propagation_reason_def</span><span> </span><span>get_propagation_reason_pol_def</span><span>
</span><span>      </span><span>trail_pol_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>lits_of_def</span><span> </span><span>assert_bind_spec_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_propagation_reason_raw_pol</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; nat literal &#8658; nat nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_propagation_reason_raw_pol = (&#955;(_, _, _, reasons, _) L. do {
      ASSERT(atm_of L &lt; length reasons);
      let r = reasons ! atm_of L;
      RETURN r})&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The version \&lt;^term&gt;&#8249;get_propagation_reason&#8250; can return the reason, but does not have to: it can be
more suitable for specification (like for the conflict minimisation, where finding the reason is
not mandatory).

The following version &#8727;&#8249;always&#8250; returns the reasons if there is one. Remark that both functions
are linked to the same code (but \&lt;^term&gt;&#8249;get_propagation_reason&#8250; can be called first with some additional
filtering later).
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>get_the_propagation_reason</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, &#39;mark) ann_lits &#8658; &#39;v literal &#8658; &#39;mark option nres&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_the_propagation_reason M L = SPEC(&#955;C.
     (C &#8800; None &#10231; Propagated L (the C) &#8712; set M) &#8743;
     (C = None &#10231; Decided L &#8712; set M &#8744; L &#8713; lits_of_l M))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_dup_Decided_PropedD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup ad &#10233; Decided L &#8712; set ad &#10233; Propagated L C &#8712; set ad &#10233; False&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>annotated_lit.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>in_set_conv_decomp</span><span> </span><span>lit_of.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>lit_of.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span>no_dup_appendD</span><span> </span><span>no_dup_cons</span><span> </span><span>undefined_notin</span><span> </span><span>xy_in_set_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_the_propagation_reason_pol</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; nat literal &#8658; nat option nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_the_propagation_reason_pol = (&#955;(_, xs, _, reasons, _) L. do {
      ASSERT(atm_of L &lt; length reasons);
      ASSERT(nat_of_lit L &lt; length xs);
      let r = reasons ! atm_of L;
      RETURN (if xs ! nat_of_lit L = SET_TRUE &#8743; r &#8800; DECISION_REASON then Some r else None)})&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_the_propagation_reason_pol</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry get_the_propagation_reason_pol, uncurry get_the_propagation_reason) &#8712;
       [&#955;(M, L). L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>r</sub> Id &#8594; &#10216;&#10216;nat_rel&#10217;option_rel&#10217; nres_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup bb &#10233;
       SET_TRUE = polarity bb (Pos x1) &#10233; Pos x1 &#8712; lits_of_l bb &#8743; Neg x1 &#8713; lits_of_l bb&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>bb</span><span> </span><span>x1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lits_of_def</span><span> </span><span>get_the_propagation_reason_def</span><span> </span><span>uncurry_def</span><span> </span><span>get_the_propagation_reason_pol_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>refine_vcg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_the_propagation_reason_def</span><span> </span><span>get_the_propagation_reason_pol_def</span><span> </span><span>Let_def</span><span>
</span><span>        </span><span>trail_pol_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>assert_bind_spec_conv</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_the_propagation_reason_def</span><span> </span><span>get_the_propagation_reason_pol_def</span><span> </span><span>Let_def</span><span>
</span><span>        </span><span>trail_pol_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>assert_bind_spec_conv</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>aa</span><span> </span><span>ab</span><span> </span><span>ac</span><span> </span><span>ad</span><span> </span><span>b</span><span> </span><span>ba</span><span> </span><span>ae</span><span> </span><span>bb</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;aa ! nat_of_lit ba &#8800; SET_TRUE&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ba &#8713; lits_of_l ae&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_the_propagation_reason_def</span><span> </span><span>get_the_propagation_reason_pol_def</span><span> </span><span>Let_def</span><span>
</span><span>          </span><span>trail_pol_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>assert_bind_spec_conv</span><span> </span><span>polarity_spec&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>imageI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>lit_of</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ba &#8712; lits_of_l ae&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_the_propagation_reason_def</span><span> </span><span>get_the_propagation_reason_pol_def</span><span> </span><span>Let_def</span><span>
</span><span>          </span><span>trail_pol_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>assert_bind_spec_conv</span><span> </span><span>polarity_spec&#39;</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_the_propagation_reason_def</span><span> </span><span>get_the_propagation_reason_pol_def</span><span> </span><span>Let_def</span><span>
</span><span>        </span><span>trail_pol_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>assert_bind_spec_conv</span><span> </span><span>lits_of_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Direct access to elements in the trail&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>rev_trail_nth</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rev_trail_nth M i = lit_of (rev M ! i)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>isa_trail_nth</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; nat &#8658; nat literal nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;isa_trail_nth = (&#955;(M, _) i. do {
    ASSERT(i &lt; length M);
    RETURN (M ! i)
  })&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_trail_nth_rev_trail_nth</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry isa_trail_nth, uncurry (RETURN oo rev_trail_nth)) &#8712;
    [&#955;(M, i). i &lt; length M]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>r</sub> nat_rel &#8594; &#10216;Id&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_trail_nth_def</span><span> </span><span>rev_trail_nth_def</span><span> </span><span>trail_pol_def</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ASSERT_leI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;We here define a variant of the trail representation, where the the control stack is out of
  sync of the trail (i.e., there are some leftovers at the end). This might make backtracking a
  little faster.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trail_pol_no_CS</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat multiset &#8658; (trail_pol &#215; (nat, nat) ann_lits) set&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol_no_CS &#119964; =
   {((M&#39;, xs, lvls, reasons, k, cs), M). ((M&#39;, reasons), M) &#8712; ann_lits_split_reasons &#119964; &#8743;
    no_dup M &#8743;
    (&#8704;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;. nat_of_lit L &lt; length xs &#8743; xs ! (nat_of_lit L) = polarity M L) &#8743;
    (&#8704;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;. atm_of L &lt; length lvls &#8743; lvls ! (atm_of L) = get_level M L) &#8743;
    (&#8704;L&#8712;set M. lit_of L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;) &#8743;
    isasat_input_bounded &#119964; &#8743;
    control_stack (take (count_decided M) cs) M
  }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tl_trailt_tr_no_CS</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; trail_pol&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trailt_tr_no_CS = (&#955;(M&#39;, xs, lvls, reasons, k, cs).
    let L = last M&#39; in
    (butlast M&#39;,
    let xs = xs[nat_of_lit L := None] in xs[nat_of_lit (-L) := None],
    lvls[atm_of L := 0],
    reasons, k, cs))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tl_trailt_tr_no_CS_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trailt_tr_no_CS_pre = (&#955;(M, xs, lvls, reason, k, cs). M &#8800; [] &#8743; nat_of_lit(last M) &lt; length xs &#8743;
        nat_of_lit(-last M) &lt; length xs  &#8743; atm_of (last M) &lt; length lvls &#8743;
        atm_of (last M) &lt; length reason)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_take_Suc_count_dec_unstack</span><span class="delimiter">:</span><span>
</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack (take (Suc (count_decided M&#39;s)) cs) (Decided x1 # M&#39;s) &#10233;
    control_stack (take (count_decided M&#39;s) cs) M&#39;s&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>control_stack_length_count_dec</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;take (Suc (count_decided M&#39;s)) cs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided x1 # M&#39;s&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>min_def</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>control_stackE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_trailt_tr_no_CS_pre</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(M&#39;, M) &#8712; trail_pol_no_CS &#119964;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8800; []&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trailt_tr_no_CS_pre M&#39;&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8800; [] &#10233; is_decided (last x) &#10233; Suc 0 &#8804; count_decided x&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trail_pol_def</span><span> </span><span>comp_def</span><span> </span><span>RETURN_refine_iff</span><span> </span><span>trail_pol_no_CS_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span>tl_trailt_tr_no_CS_def</span><span> </span><span>tl_trailt_tr_no_CS_pre_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hd M&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_no_CS_def</span><span> </span><span>ann_lits_split_reasons_def</span><span> </span><span>uminus_&#119964;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_iff</span><span>
</span><span>          </span><span>rev_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>hd_append</span><span> </span><span>hd_map</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>rev_map</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_trail_tr_no_CS</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((RETURN o tl_trailt_tr_no_CS), (RETURN o tl)) &#8712;
    [&#955;M. M &#8800; []]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol_no_CS &#119964; &#8594; &#10216;trail_pol_no_CS &#119964;&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;y&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M&#39;s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trail_pol_def</span><span> </span><span>comp_def</span><span> </span><span>RETURN_refine_iff</span><span> </span><span>trail_pol_no_CS_def</span><span> </span><span>Let_def</span><span>
</span><span>      </span><span>tl_trailt_tr_no_CS_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">;</span><span> </span><span>clarify</span><span class="delimiter">?</span><span class="delimiter">;</span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span>
</span><span>	  </span><span>ann_lits_split_reasons_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>	</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_def</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span>
</span><span>	  </span><span>uminus_lit_swap</span><span> </span><span>Let_def</span><span>
</span><span>	  </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ann_lits_split_reasons_map_lit_of</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>Let_def</span><span>
</span><span>	 </span><span>atm_of_eq_atm_of</span><span> </span><span>get_level_cons_if</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>polarity_atm_def</span><span> </span><span>tl_trailt_tr_def</span><span>
</span><span>	 </span><span>atm_of_eq_atm_of</span><span> </span><span>get_level_cons_if</span><span> </span><span>Let_def</span><span>
</span><span>	  </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ann_lits_split_reasons_map_lit_of</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>	</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>	  </span><span>control_stack_dec_butlast</span><span>
</span><span>	  </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>	</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tl_trailt_tr_def</span><span> </span><span>in_&#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub>_atm_of_in_atms_of_iff</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>	  </span><span>control_stack_dec_butlast</span><span> </span><span>control_stack_take_Suc_count_dec_unstack</span><span>
</span><span>	  </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_consistentD</span><span> </span><span>ann_lits_split_reasons_map_lit_of</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trail_conv_to_no_CS</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat, nat) ann_lits &#8658; (nat, nat) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_conv_to_no_CS M = M&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trail_pol_conv_to_no_CS</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol &#8658; trail_pol&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol_conv_to_no_CS M = M&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>id_trail_conv_to_no_CS</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o trail_pol_conv_to_no_CS, RETURN o trail_conv_to_no_CS) &#8712; trail_pol &#119964; &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;trail_pol_no_CS &#119964;&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_no_CS_def</span><span> </span><span>trail_conv_to_no_CS_def</span><span> </span><span>trail_pol_def</span><span>
</span><span>      </span><span>control_stack_length_count_dec</span><span> </span><span>trail_pol_conv_to_no_CS_def</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trail_conv_back</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; (nat, nat) ann_lits &#8658; (nat, nat) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_conv_back j M = M&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>trail_conv_back_imp</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; trail_pol &#8658; trail_pol nres&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_conv_back_imp j = (&#955;(M, xs, lvls, reason, _, cs). do {
     ASSERT(j &#8804; length cs); RETURN (M, xs, lvls, reason, j, take (j) cs)})&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trail_conv_back</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry trail_conv_back_imp, uncurry (RETURN oo trail_conv_back))
      &#8712; [&#955;(k, M). k = count_decided M]<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#215;<span class="hidden">&#8681;</span><sub>f</sub> trail_pol_no_CS &#119964; &#8594; &#10216;trail_pol &#119964;&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_no_CS_def</span><span> </span><span>trail_conv_to_no_CS_def</span><span> </span><span>trail_pol_def</span><span>
</span><span>      </span><span>control_stack_length_count_dec</span><span> </span><span>trail_conv_back_def</span><span> </span><span>trail_conv_back_imp_def</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ASSERT_refine_left</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>control_stack_length_count_dec</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span>take_arl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;take_arl = (&#955;i (xs, j). (xs, i))&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_trail_nth_rev_trail_nth_no_CS</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry isa_trail_nth, uncurry (RETURN oo rev_trail_nth)) &#8712;
    [&#955;(M, i). i &lt; length M]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol_no_CS &#119964; &#215;<span class="hidden">&#8681;</span><sub>r</sub> nat_rel &#8594; &#10216;Id&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_trail_nth_def</span><span> </span><span>rev_trail_nth_def</span><span> </span><span>trail_pol_def</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>      </span><span>trail_pol_no_CS_def</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ASSERT_leI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trail_pol_no_CS_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail_pol_no_CS &#119964; =
    {((M&#39;, xs, lvls, reasons, k, cs), M). ((M&#39;, reasons), M) &#8712; ann_lits_split_reasons &#119964; &#8743;
    no_dup M &#8743;
    (&#8704;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;. nat_of_lit L &lt; length xs &#8743; xs ! (nat_of_lit L) = polarity M L) &#8743;
    (&#8704;L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;. atm_of L &lt; length lvls &#8743; lvls ! (atm_of L) = get_level M L) &#8743;
    (&#8704;L&#8712;set M. lit_of L &#8712;# &#8466;<span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>l</sub><span class="hidden">&#8681;</span><sub>l</sub> &#119964;) &#8743;
    control_stack (take (count_decided M) cs) M &#8743; literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_trail &#119964; M &#8743;
    length M &lt; uint32_max &#8743;
    length M &#8804; uint32_max div 2 + 1 &#8743;
    count_decided M &lt; uint32_max &#8743;
    length M&#39; = length M &#8743;
    isasat_input_bounded &#119964; &#8743;
    M&#39; = map lit_of (rev M)
   }&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M &lt; n &#10233; count_decided M &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_filter_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>is_decided</span><span> </span><span>M</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_trail_def</span><span> </span><span>uint32_max_def</span><span> </span><span>count_decided_def</span><span>
</span><span>        </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>length_filter_le</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>length_trail_uint32_max_div2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trail_pol_no_CS_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>literals_are_in_&#8466;<span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>n</sub>_trail_def</span><span> </span><span>uint32_max_def</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>length_trail_uint32_max_div2</span><span>
</span><span>	</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>isasat_input_bounded_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Kill the other definition *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isa_length_trail_length_u_no_CS</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o isa_length_trail, RETURN o length_uint32_nat) &#8712; trail_pol_no_CS &#119964; &#8594;<span class="hidden">&#8681;</span><sub>f</sub> &#10216;nat_rel&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>isa_length_trail_def</span><span> </span><span>trail_pol_no_CS_alt_def</span><span> </span><span>ann_lits_split_reasons_def</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ASSERT_leI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_is_decided</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M &#10233; c&#8712;set cs &#10233; is_decided ((rev M)!c)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>c</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>control_stack.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>control_stack_le_length_M</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_distinct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M &#10233; distinct cs&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>control_stack.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_append</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>control_stack_le_length_M</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>control_stack_level_control_stack</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;control_stack cs M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; length cs&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M (lit_of (rev M ! (cs ! i))) = Suc i&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = rev M ! (cs ! i)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>csi</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cs ! i &lt; length M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cs</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>control_stack_le_length_M</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_mem</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cs !i&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rev M&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dec_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_decided L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>control_stack_is_decided</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span class="delimiter">]</span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rev M!(cs ! (get_level M (lit_of L) - 1)) = L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>control_stack_rev_get_lev</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span> </span><span>n_d</span><span> </span><span>L_M</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup_distinct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_d</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mset_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>distinct_mset_mset_distinct</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>distinct_mapI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev0</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M (lit_of L) &#8805; 1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>L_M</span><span class="delimiter">]</span><span> </span><span>n_d</span><span> </span><span>dec_L</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_append_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cs ! (get_level M (lit_of (rev M ! (cs ! i))) - Suc 0) &lt; length M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>control_stack_le_length_M</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span class="delimiter">,</span><span>
</span><span>         </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cs ! (get_level M (lit_of (rev M ! (cs ! i))) - Suc 0)&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>nth_mem</span><span class="delimiter">]</span><span>
</span><span>      </span><span>control_stack_length_count_dec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span class="delimiter">]</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of (rev M ! (cs ! i))&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>lev0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>L_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cs ! (get_level M (lit_of L) - 1) = cs ! i&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_eq_iff_index_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rev M&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>csi</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = get_level M (lit_of L) - 1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_eq_iff_index_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>control_stack_distinct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>i</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level M (lit_of L) - 1&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>i</span><span> </span><span>lev0</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of (rev M ! (cs ! i))&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>control_stack_length_count_dec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cs</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>L_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>L_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_pos_of_level_in_trail</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_pos_of_level_in_trail M<span class="hidden">&#8681;</span><sub>0</sub> lev =
     SPEC(&#955;i. i &lt; length M<span class="hidden">&#8681;</span><sub>0</sub> &#8743; is_decided (rev M<span class="hidden">&#8681;</span><sub>0</sub>!i) &#8743; get_level M<span class="hidden">&#8681;</span><sub>0</sub> (lit_of (rev M<span class="hidden">&#8681;</span><sub>0</sub>!i)) = lev+1)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>get_pos_of_level_in_trail_imp</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_pos_of_level_in_trail_imp = (&#955;(M&#39;, xs, lvls, reasons, k, cs) lev. do {
      ASSERT(lev &lt; length cs);
      RETURN (cs ! lev)
   })&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>get_pos_of_level_in_trail_pre</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_pos_of_level_in_trail_pre = (&#955;(M, lev). lev &lt; count_decided M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_pos_of_level_in_trail_imp_get_pos_of_level_in_trail</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry get_pos_of_level_in_trail_imp, uncurry get_pos_of_level_in_trail) &#8712;
    [get_pos_of_level_in_trail_pre]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol_no_CS &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#8594; &#10216;nat_rel&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>nres_relI</span><span> </span><span>frefI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>get_pos_of_level_in_trail_imp_def</span><span> </span><span>uncurry_def</span><span> </span><span>get_pos_of_level_in_trail_def</span><span>
</span><span>    </span><span>get_pos_of_level_in_trail_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ASSERT_leI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_no_CS_alt_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>control_stack_length_count_dec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>aa</span><span> </span><span>ab</span><span> </span><span>ac</span><span> </span><span>ad</span><span> </span><span>b</span><span> </span><span>ba</span><span> </span><span>ae</span><span> </span><span>bb</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_no_CS_def</span><span> </span><span>control_stack_length_count_dec</span><span> </span><span>in_set_take_conv_nth</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>control_stack_le_length_M</span><span> </span><span>control_stack_is_decided</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>control_stack_level_control_stack</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_pos_of_level_in_trail_imp_get_pos_of_level_in_trail_CS</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(uncurry get_pos_of_level_in_trail_imp, uncurry get_pos_of_level_in_trail) &#8712;
    [get_pos_of_level_in_trail_pre]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol &#119964; &#215;<span class="hidden">&#8681;</span><sub>f</sub> nat_rel &#8594; &#10216;nat_rel&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>nres_relI</span><span> </span><span>frefI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>get_pos_of_level_in_trail_imp_def</span><span> </span><span>uncurry_def</span><span> </span><span>get_pos_of_level_in_trail_def</span><span>
</span><span>    </span><span>get_pos_of_level_in_trail_pre_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ASSERT_leI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>control_stack_length_count_dec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>aa</span><span> </span><span>ab</span><span> </span><span>ac</span><span> </span><span>ad</span><span> </span><span>b</span><span> </span><span>ba</span><span> </span><span>ae</span><span> </span><span>bb</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trail_pol_def</span><span> </span><span>control_stack_length_count_dec</span><span> </span><span>in_set_take_conv_nth</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>control_stack_le_length_M</span><span> </span><span>control_stack_is_decided</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>control_stack_level_control_stack</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lit_of_last_trail_pol_lit_of_last_trail_no_CS</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o lit_of_last_trail_pol, RETURN o lit_of_hd_trail) &#8712;
         [&#955;S. S &#8800; []]<span class="hidden">&#8681;</span><sub>f</sub> trail_pol_no_CS &#119964; &#8594; &#10216;Id&#10217;nres_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lit_of_hd_trail_def</span><span> </span><span>trail_pol_no_CS_def</span><span> </span><span>lit_of_last_trail_pol_def</span><span>
</span><span>     </span><span>ann_lits_split_reasons_def</span><span> </span><span>hd_map</span><span> </span><span>rev_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>last_rev</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>frefI</span><span> </span><span>nres_relI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:25:56 AM CEST </td></tr></table></p></footer></div>

</html>


