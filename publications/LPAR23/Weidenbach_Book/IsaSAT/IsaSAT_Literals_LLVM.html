<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory IsaSAT_Literals_LLVM (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory IsaSAT_Literals_LLVM</h1>

<span class="command">theory</span> <span class="name">IsaSAT_Literals_LLVM</span><br/>
<span class="keyword">imports</span> <a href="WB_More_Word.html"><span class="name">WB_More_Word</span></a> <a href="IsaSAT_Literals.html"><span class="name">IsaSAT_Literals</span></a> <a href="../../Unsorted/Watched_Literals/WB_More_IICF_LLVM.html"><span class="name">WB_More_IICF_LLVM</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IsaSAT_Literals_LLVM</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>WB_More_Word</span><span> </span><span>IsaSAT_Literals</span><span> </span><span>Watched_Literals.WB_More_IICF_LLVM</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inline_ho</span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;doM { f &#8592; return f; m f } = m f&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8658; _&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move
  TODO:  Write generic postprocessing for that!
  Maybe just beta contraction of form (&#955;x. f x)$x = f$x
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RETURN_comp_5_10_hnr_post</span><span class="delimiter">[</span><span>to_hnr_post</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN ooooo f5)$a$b$c$d$e = RETURN$(f5$a$b$c$d$e)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN oooooo f6)$a$b$c$d$e$f = RETURN$(f6$a$b$c$d$e$f)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN ooooooo f7)$a$b$c$d$e$f$g = RETURN$(f7$a$b$c$d$e$f$g)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN oooooooo f8)$a$b$c$d$e$f$g$h = RETURN$(f8$a$b$c$d$e$f$g$h)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN ooooooooo f9)$a$b$c$d$e$f$g$h$i = RETURN$(f9$a$b$c$d$e$f$g$h$i)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN oooooooooo f10)$a$b$c$d$e$f$g$h$i$j = RETURN$(f10$a$b$c$d$e$f$g$h$i$j)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o<span class="hidden">&#8681;</span><sub>1</sub><span class="hidden">&#8681;</span><sub>1</sub> f11)$a$b$c$d$e$f$g$h$i$j$k = RETURN$(f11$a$b$c$d$e$f$g$h$i$j$k)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o<span class="hidden">&#8681;</span><sub>1</sub><span class="hidden">&#8681;</span><sub>2</sub> f12)$a$b$c$d$e$f$g$h$i$j$k$l = RETURN$(f12$a$b$c$d$e$f$g$h$i$j$k$l)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o<span class="hidden">&#8681;</span><sub>1</sub><span class="hidden">&#8681;</span><sub>3</sub> f13)$a$b$c$d$e$f$g$h$i$j$k$l$m = RETURN$(f13$a$b$c$d$e$f$g$h$i$j$k$l$m)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(RETURN o<span class="hidden">&#8681;</span><sub>1</sub><span class="hidden">&#8681;</span><sub>4</sub> f14)$a$b$c$d$e$f$g$h$i$j$k$l$m$n = RETURN$(f14$a$b$c$d$e$f$g$h$i$j$k$l$m$n)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  TODO/FIXME: Ad-hoc optimizations for large tuples *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>llvm_inline</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case_prod_open &#8801; case_prod&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fold_case_prod_open</span><span> </span><span class="delimiter">=</span><span> </span><span>case_prod_open_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>case_prod_open_arity</span><span class="delimiter">[</span><span>sepref_monadify_arity</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case_prod_open &#8801; &#955;<span class="hidden">&#8681;</span><sub>2</sub>fp p. SP case_prod_open$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>a b. fp$a$b)$p&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>SP_def</span><span> </span><span>APP_def</span><span> </span><span>PROTECT2_def</span><span> </span><span>RCALL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>case_prod_open_comb</span><span class="delimiter">[</span><span>sepref_monadify_comb</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;fp p. case_prod_open$fp$p &#8801; Refine_Basic.bind$(EVAL$p)$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>p. (SP case_prod_open$fp$p))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>case_prod_open_plain_comb</span><span class="delimiter">[</span><span>sepref_monadify_comb</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;EVAL$(case_prod_open$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>a b. fp a b)$p) &#8801;
    Refine_Basic.bind$(EVAL$p)$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>p. case_prod_open$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>a b. EVAL$(fp a b))$p)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eq_reflection</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split</span><span> </span><span>prod.split</span><span> </span><span>option.split</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hn_case_prod_open&#39;</span><span class="delimiter">[</span><span>sepref_comb_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FR</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#915; &#8866; hn_ctxt (prod_assn P1 P2) p&#39; p ** &#915;1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;a1 a2 a1&#39; a2&#39;. &#10214;p&#39;=(a1&#39;,a2&#39;)&#10215;
    &#10233; hn_refine (hn_ctxt P1 a1&#39; a1 ** hn_ctxt P2 a2&#39; a2 ** &#915;1) (f a1 a2)
          (&#915;2 a1 a2 a1&#39; a2&#39;) R (f&#39; a1&#39; a2&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>FR2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;a1 a2 a1&#39; a2&#39;. &#915;2 a1 a2 a1&#39; a2&#39; &#8866; hn_ctxt P1&#39; a1&#39; a1 ** hn_ctxt P2&#39; a2&#39; a2 ** &#915;1&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hn_refine &#915; (case_prod_open f p) (hn_ctxt (prod_assn P1&#39; P2&#39;) p&#39; p ** &#915;1&#39;)
                   R (case_prod_open$(&#955;<span class="hidden">&#8681;</span><sub>2</sub>a b. f&#39; a b)$p&#39;)&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?G &#915;&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>autoref_tag_defs</span><span> </span><span>PROTECT2_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>FR</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply1</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>p</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>p&#39;</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prod_assn_pair_conv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>prod_assn_ctxt</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hn_refine_cons</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>Pair</span><span> </span><span>_</span><span> </span><span>entails_refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FR2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hn_ctxt_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ho_prod_open_move</span><span class="delimiter">[</span><span>sepref_preproc</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;case_prod_open (&#955;a b x. f x a b) = (&#955;p x. case_prod_open (f x) p)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tuple4 a b c d &#8801; (a,b,c,d)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tuple7 a b c d e f g &#8801; tuple4 a b c (tuple4 d e f g)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tuple13 a b c d e f g h i j k l m &#8801; (tuple7 a b c d e f (tuple7 g h i j k l m))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fold_tuples</span><span> </span><span class="delimiter">=</span><span> </span><span>tuple4_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>tuple7_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>tuple13_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span>tuple4</span><span> </span><span>tuple7</span><span> </span><span>tuple13</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>tuple4_impl</span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry3 (RETURN oooo tuple4)&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A1<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A2<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A3<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A4<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> A1 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A2 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A3 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A4&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tuple4_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>tuple7_impl</span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry6 (RETURN ooooooo tuple7)&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A1<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A2<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A3<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A4<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A5<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A6<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A7<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> A1 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A2 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A3 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A4 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A5 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A6 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A7&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tuple7_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>tuple13_impl</span><span> </span><span class="delimiter">[</span><span>llvm_inline</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry12 (RETURN o<span class="hidden">&#8681;</span><sub>1</sub><span class="hidden">&#8681;</span><sub>3</sub> tuple13)&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;A1<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A2<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A3<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A4<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A5<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A6<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A7<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A8<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A9<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A10<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A11<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A12<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> A13<span class="hidden">&#8679;</span><sup>d</sup>
  &#8594;<span class="hidden">&#8681;</span><sub>a</sub> A1 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A2 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A3 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A4 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A5 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A6 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A7 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A8 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A9 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A10 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A11 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A12 &#215;<span class="hidden">&#8681;</span><sub>a</sub> A13&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tuple13_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>fold_tuple_optimizations</span><span> </span><span class="delimiter">=</span><span> </span><span>fold_tuples</span><span> </span><span>fold_case_prod_open</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
(* TODO: Also for max_unat, and move to default simpset of Sepref! *)
lemma max_snat_numeral[simp]:
  &#8249;0 &lt; max_snat n&#8250;
  &#8249;1 &lt; max_snat n &#10231; n&gt;1&#8250;
  &#8249;numeral x &lt; max_snat n &#10231; (numeral x ::nat) &lt; 2^(n-1)&#8250;
  subgoal by (auto simp: max_snat_def) []
  subgoal unfolding max_snat_def by (metis nat_neq_iff nat_power_eq_Suc_0_iff nat_zero_less_power_iff not_less_eq numerals(2) power_0 zero_less_Suc zero_less_diff)
  subgoal by (auto simp: max_snat_def) []
  done

lemma max_unat_numeral[simp]:
  &#8249;0 &lt; max_unat n&#8250;
  &#8249;1 &lt; max_unat n &#10231; n&gt;0&#8250;
  &#8249;numeral x &lt; max_unat n &#10231; (numeral x ::nat) &lt; 2^n&#8250;
  subgoal by (auto simp: max_unat_def) []
  subgoal unfolding max_unat_def by (metis nat_neq_iff nat_power_eq_Suc_0_iff nat_zero_less_power_iff not_less_eq numerals(2) power_0 zero_less_Suc)
  subgoal by (auto simp: max_unat_def) []
  done
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move!
  TODO: General max functions!
  TODO: Name should be snatN_max

*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint64_max_refine</span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(0x7FFFFFFFFFFFFFFF, sint64_max)&#8712;snat_rel&#39; TYPE(64)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_rel_def</span><span> </span><span>snat.rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>sint64_max_def</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sint32_max_refine</span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(0x7FFFFFFF, sint32_max)&#8712;snat_rel&#39; TYPE(32)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_rel_def</span><span> </span><span>snat.rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>sint32_max_def</span><span> </span><span>snat_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>snat_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint64_max_refine</span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(0xFFFFFFFFFFFFFFFF, uint64_max)&#8712;unat_rel&#39; TYPE(64)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_rel_def</span><span> </span><span>unat.rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>uint64_max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uint32_max_refine</span><span class="delimiter">[</span><span>sepref_import_param</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(0xFFFFFFFF, uint32_max)&#8712;unat_rel&#39; TYPE(32)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_rel_def</span><span> </span><span>unat.rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>uint32_max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>convert_fref</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;WB_More_Refinement.fref = Sepref_Rules.frefnd&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;WB_More_Refinement.freft = Sepref_Rules.freftnd&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>WB_More_Refinement.fref_def</span><span> </span><span>Sepref_Rules.fref_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>WB_More_Refinement.fref</span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[_]<span class="hidden">&#8681;</span><sub>f</sub> _ &#8594; _&#8250;</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>WB_More_Refinement.freft</span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8594;<span class="hidden">&#8681;</span><sub>f</sub> _&#8250;</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span>60</span><span class="delimiter">]</span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uint32_nat_assn &#8801; unat_assn&#39; TYPE(32)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uint64_nat_assn &#8801; unat_assn&#39; TYPE(64)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sint32_nat_assn &#8801; snat_assn&#39; TYPE(32)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sint64_nat_assn &#8801; snat_assn&#39; TYPE(64)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_bounds_simps</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>uint32_max_def</span><span> </span><span>sint32_max_def</span><span>
</span><span>  </span><span>uint64_max_def</span><span> </span><span>sint64_max_def</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_up&#39;_32_64</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_up&#39; UCAST(32 &#8594; 64)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_up&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_down&#39;_64_32</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_down&#39; UCAST(64 &#8594; 32)&#8250;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_down&#39;</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ins_idx_upcast64</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;l[i:=y] = op_list_set l (op_unat_snat_upcast TYPE(64) i) y&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;l!i = op_list_get l (op_unat_snat_upcast TYPE(64) i)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>array_list32</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a,32)array_list&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>array_list64</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a,64)array_list&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;arl32_assn &#8801; al_assn&#39; TYPE(32)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;arl64_assn &#8801; al_assn&#39; TYPE(64)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>larray32</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a,32) larray&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>larray64</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;a,64) larray&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;larray32_assn &#8801; larray_assn&#39; TYPE(32)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;larray64_assn &#8801; larray_assn&#39; TYPE(64)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unat_lit_rel == unat_rel&#39; TYPE(32) O nat_lit_rel&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>fcomp_norm_unfold</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>unat_lit_rel_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>unat_lit_assn</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat literal &#8658; 32 word &#8658; assn&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unat_lit_assn &#8801; pure unat_lit_rel&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Atom-Of&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>atom_assn</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;32 word&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atom_rel &#8801; b_rel (unat_rel&#39; TYPE(32)) (&#955;x. x&lt;2^31)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atom_assn &#8801; pure atom_rel&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atom_rel_alt</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atom_rel = unat_rel&#39; TYPE(32) O nbn_rel (2^31)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atom_rel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>atom</span><span class="delimiter">:</span><span> </span><span>dflt_pure_option_private</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;2^32-1&#8250;</span></span></span><span> </span><span>atom_assn</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ll_icmp_eq (2^32-1)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atom_rel_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pure_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>pred_lift_extract_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>unat_rel_def</span><span> </span><span>unat.rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>unat_minus_one_word</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>goal_cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>llvm_prim_arith_setup</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bool.assn_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>vcg&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atm_of_refine</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;x. x div 2 , atm_of) &#8712; nat_lit_rel &#8594; nat_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_lit_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>atm_of_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN o (&#955;x::nat. x div 2)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> atom_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atom_rel_def</span><span> </span><span>b_assn_pure_conv</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hfref_bassn_resI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref_bounds</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_unat_const</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TYPE(32)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>atm_of_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>atm_of_refine</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Pos_rel</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; nat&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos_rel n = 2 * n&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pos_refine_aux</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Pos_rel,Pos)&#8712;nat_rel &#8594; nat_lit_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_lit_rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Neg_refine_aux</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;x. 2*x + 1,Neg)&#8712;nat_rel &#8594; nat_lit_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_lit_rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>Pos_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN o Pos_rel&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atom_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> uint32_nat_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atom_rel_def</span><span> </span><span>Pos_rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_unat_const</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TYPE(32)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>Neg_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN o (&#955;x. 2*x+1)&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atom_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> uint32_nat_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atom_rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_unat_const</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TYPE(32)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*sepref_definition Neg_impl is &#8249;RETURN o (&#955;x. 2*x+1)&#8250; :: &#8249;[&#955;x. x &#8804; uint32_max div 2]<span class="hidden">&#8681;</span><sub>a</sub> uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594; uint32_nat_assn&#8250;
  apply (annot_unat_const &#8249;TYPE(32)&#8250;)
  by sepref
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>Pos_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>Pos_refine_aux</span><span class="delimiter">]</span><span>
</span><span>  </span><span>Neg_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>Neg_refine_aux</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>atom_eq_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry (RETURN oo (=))&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atom_assn<span class="hidden">&#8679;</span><sup>d</sup> *<span class="hidden">&#8681;</span><sub>a</sub> atom_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atom_rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>value_of_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; nat&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;value_of_atm A = A&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>value_of_atm_rel</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;x. x, value_of_atm) &#8712; nat_rel &#8594; nat_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>value_of_atm_impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN o (&#955;x. x)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atom_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> unat_assn&#39; TYPE(32)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>value_of_atm_def</span><span> </span><span>atom_rel_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>value_of_atm_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>value_of_atm_rel</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>index_of_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; nat&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;index_of_atm A = value_of_atm A&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>index_of_atm_rel</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;x. value_of_atm x, index_of_atm) &#8712; nat_rel &#8594; nat_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>index_of_atm_impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN o (&#955;x. value_of_atm x)&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atom_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> snat_assn&#39; TYPE(64)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>index_of_atm_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>at</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_&#8250;</span></span></span><span> </span><span>eta_expand</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>annot_unat_snat_upcast</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;l</span><span class="delimiter">=</span><span>64</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>index_of_atm_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>index_of_atm_rel</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_index_of_atm</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xs ! x = xs ! index_of_atm x&#8250;</span></span></span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xs [x := a] = xs [index_of_atm x := a]&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>index_atm_of</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;index_atm_of L = index_of_atm (atm_of L)&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Use at more places! *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;NO_MATCH (index_of_atm y) x&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>annot_index_of_atm&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>annot_index_of_atm</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span class="delimiter">]</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>annot_all_atm_idxs</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Scan.succeed (fn ctxt =&gt; SIMPLE_METHOD&#39;
    let
      val ctxt = put_simpset HOL_basic_ss ctxt
      val ctxt = ctxt addsimps @{thms annot_index_of_atm&#39;}
      val ctxt = ctxt addsimprocs [@{simproc NO_MATCH}]
    in
      simp_tac ctxt
    end
  )&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_index_atm_of</span><span class="delimiter">[</span><span>def_pat_rules</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth$xs$(atm_of$x) &#8801; nth$xs$(index_atm_of$x)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;list_update$xs$(atm_of$x)$a &#8801; list_update$xs$(index_atm_of$x)$a&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>index_atm_of_impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN o index_atm_of&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unat_lit_assn<span class="hidden">&#8679;</span><sup>d</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> snat_assn&#39; TYPE(64)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>index_atm_of_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_of_lit_refine_aux</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((&#955;x. x), nat_of_lit) &#8712; nat_lit_rel &#8594; nat_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_lit_rel_def</span><span> </span><span>in_br_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>nat_of_lit_rel_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN o (&#955;x::nat. x)&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> sint64_nat_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rewrite</span><span> </span><span>annot_unat_snat_upcast</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">&#39;l</span><span class="delimiter">=</span><span>64</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>nat_of_lit_rel_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>nat_of_lit_refine_aux</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>uminus_refine_aux</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;x. x XOR 1, uminus) &#8712; nat_lit_rel &#8594; nat_lit_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_lit_rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>bitXOR_1_if_mod_2</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dvd_minus_mod</span><span> </span><span>even_Suc_div_two</span><span> </span><span>odd_Suc_minus_one</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>uminus_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN o (&#955;x::nat. x XOR 1)&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> uint32_nat_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_unat_const</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TYPE(32)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>uminus_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>uminus_refine_aux</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lit_eq_refine_aux</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;( (=), (=) ) &#8712; nat_lit_rel &#8594; nat_lit_rel &#8594; bool_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_lit_rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">?</span><span class="delimiter">;</span><span> </span><span>presburger</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>lit_eq_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry (RETURN oo (=))&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>lit_eq_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>lit_eq_refine_aux</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_pos_refine_aux</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#955;x. x AND 1 = 0, is_pos) &#8712; nat_lit_rel &#8594; bool_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_lit_rel_def</span><span> </span><span>in_br_conv</span><span> </span><span>bitAND_1_mod_2</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>is_pos_impl</span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;RETURN o (&#955;x. x AND 1 = 0)&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>annot_unat_const</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;TYPE(32)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>sepref_fr_rules</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>is_pos_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>is_pos_refine_aux</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_decl_op</span></span><span> </span><span>nat_lit_eq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(=) :: nat literal &#8658; _ &#8658; _&#8250;</span></span></span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Id :: (nat literal &#215; _) set) &#8594; (Id :: (nat literal &#215; _) set) &#8594; bool_rel&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_def</span></span><span> </span><span>nat_lit_eq_impl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uncurry (RETURN oo (&#955;x y. x = y))&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> *<span class="hidden">&#8681;</span><sub>a</sub> uint32_nat_assn<span class="hidden">&#8679;</span><sup>k</sup> &#8594;<span class="hidden">&#8681;</span><sub>a</sub> bool1_assn&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>sepref</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_lit_rel</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;((=), op_nat_lit_eq) &#8712; nat_lit_rel &#8594; nat_lit_rel &#8594; bool_rel&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nat_lit_rel_def</span><span> </span><span>br_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">;</span><span> </span><span>presburger</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sepref_register</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(=) :: nat literal &#8658; _ &#8658; _&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>nat_lit_eq_impl.refine</span><span class="delimiter">[</span><span>FCOMP</span><span> </span><span>nat_lit_rel</span><span class="delimiter">,</span><span> </span><span>sepref_fr_rules</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:25:56 AM CEST </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


