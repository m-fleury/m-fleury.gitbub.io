<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Show_Instances (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Show_Instances</h1>

<span class="command">theory</span> <span class="name">Show_Instances</span><br/>
<span class="keyword">imports</span> <a href="Show.html"><span class="name">Show</span></a> <a href="../../HOL/HOL/Rat.html"><span class="name">Rat</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Show
    Author:      Christian Sternagel &lt;c.sternagel@gmail.com&gt;
    Author:      René Thiemann &lt;rene.thiemann@uibk.ac.at&gt;
    Maintainer:  Christian Sternagel &lt;c.sternagel@gmail.com&gt;
    Maintainer:  René Thiemann &lt;rene.thiemann@uibk.ac.at&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Instances of the Show Class for Standard Types&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Show_Instances</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Show</span><span>
</span><span>  </span><span>HOL.Rat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>showsp_unit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;unit showsp&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_unit p x = shows_string &#39;&#39;()&#39;&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show_law_unit</span><span> </span><span class="delimiter">[</span><span>show_law_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;show_law showsp_unit x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>show_lawI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>showsp_unit_def</span><span> </span><span>show_law_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>showsp_char</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;char showsp&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_char &#8801; shows_prec&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show_law_char</span><span> </span><span class="delimiter">[</span><span>show_law_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;show_law showsp_char x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>show_lawI</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>show_law_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>showsp_bool</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;bool showsp&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_bool p True = shows_string &#39;&#39;True&#39;&#39;&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_bool p False = shows_string &#39;&#39;False&#39;&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show_law_bool</span><span> </span><span class="delimiter">[</span><span>show_law_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;show_law showsp_bool x&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>show_lawI</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>show_law_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>pshowsp_prod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(shows &#215; shows) showsp&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;pshowsp_prod p (x, y) = shows_string &#39;&#39;(&#39;&#39; o x o shows_string &#39;&#39;, &#39;&#39; o y o shows_string &#39;&#39;)&#39;&#39;&quot;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NOTE: in order to be compatible with automatically generated show funtions,
show-arguments of &quot;map&quot;-functions need to get precedence 1 (which may lead to
redundant parentheses in the output, but seems unavoidable in the current setup,
i.e., pshowsp via primrec followed by defining showsp via pshowsp composed with map).*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>showsp_prod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a showsp &#8658; &#39;b showsp &#8658; (&#39;a &#215; &#39;b) showsp&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_prod s1 s2 p = pshowsp_prod p o map_prod (s1 1) (s2 1)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>showsp_prod_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_prod s1 s2 p (x, y) =
    shows_string &#39;&#39;(&#39;&#39; o s1 1 x o shows_string &#39;&#39;, &#39;&#39; o s2 1 y o shows_string &#39;&#39;)&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>showsp_prod_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show_law_prod</span><span> </span><span class="delimiter">[</span><span>show_law_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;x. x &#8712; Basic_BNFs.fsts y &#10233; show_law s1 x) &#10233;
   (&#8896;x. x &#8712; Basic_BNFs.snds y &#10233; show_law s2 x) &#10233;
    show_law (showsp_prod s1 s2) y&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pair</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>*</span><span> </span><span class="delimiter">=</span><span> </span><span>Pair</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>prod_set_simps</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>show_lawI</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>o_apply</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>o_append</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>show_lawD</span><span> </span><span>*</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>show_law_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>string_of_digit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; string&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;string_of_digit n =
    (if n = 0 then &#39;&#39;0&#39;&#39;
    else if n = 1 then &#39;&#39;1&#39;&#39;
    else if n = 2 then &#39;&#39;2&#39;&#39;
    else if n = 3 then &#39;&#39;3&#39;&#39;
    else if n = 4 then &#39;&#39;4&#39;&#39;
    else if n = 5 then &#39;&#39;5&#39;&#39;
    else if n = 6 then &#39;&#39;6&#39;&#39;
    else if n = 7 then &#39;&#39;7&#39;&#39;
    else if n = 8 then &#39;&#39;8&#39;&#39;
    else &#39;&#39;9&#39;&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>showsp_nat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat showsp&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_nat p n =
    (if n &lt; 10 then shows_string (string_of_digit n)
    else showsp_nat p (n div 10) o shows_string (string_of_digit (n mod 10)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>showsp_nat.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show_law_nat</span><span> </span><span class="delimiter">[</span><span>show_law_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;show_law showsp_nat n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>show_lawI</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>n</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nat_less_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>show_law_simps</span><span> </span><span>showsp_nat.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>showsp_nat_append</span><span> </span><span class="delimiter">[</span><span>show_law_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_nat p n (x @ y) = showsp_nat p n x @ y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>show_lawD</span><span> </span><span>show_law_intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>showsp_int</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;int showsp&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_int p i =
    (if i &lt; 0 then shows_string &#39;&#39;-&#39;&#39; o showsp_nat p (nat (- i)) else showsp_nat p (nat i))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show_law_int</span><span> </span><span class="delimiter">[</span><span>show_law_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;show_law showsp_int i&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>show_lawI</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; 0&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>showsp_int_def</span><span> </span><span>show_law_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>showsp_int_append</span><span> </span><span class="delimiter">[</span><span>show_law_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_int p i (x @ y) = showsp_int p i x @ y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>show_lawD</span><span> </span><span>show_law_intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>showsp_rat</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;rat showsp&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_rat p x =
    (case quotient_of x of (d, n) &#8658;
      if n = 1 then showsp_int p d else showsp_int p d o shows_string &#39;&#39;/&#39;&#39; o showsp_int p n)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>show_law_rat</span><span> </span><span class="delimiter">[</span><span>show_law_intros</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;show_law showsp_rat r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>show_lawI</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;quotient_of r&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>showsp_rat_def</span><span> </span><span>show_law_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>showsp_rat_append</span><span> </span><span class="delimiter">[</span><span>show_law_simps</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;showsp_rat p r (x @ y) = showsp_rat p r x @ y&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>show_lawD</span><span> </span><span>show_law_intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Automatic show functions are not used for @{type unit}, @{type prod}, and numbers:
  for @{type unit} and @{type prod}, we do not want to display @{term &quot;&#39;&#39;Unity&#39;&#39;&quot;} and
  @{term &quot;&#39;&#39;Pair&#39;&#39;&quot;}; for @{type nat}, we do not want to display
  @{term &quot;&#39;&#39;Suc (Suc (... (Suc 0) ...))&#39;&#39;&quot;}; and neither @{type int}
  nor @{type rat} are datatypes.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">local_setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Show_Generator.register_foreign_partial_and_full_showsp @{type_name prod} 0
       @{term &quot;pshowsp_prod&quot;}
       @{term &quot;showsp_prod&quot;} (SOME @{thm showsp_prod_def})
       @{term &quot;map_prod&quot;} (SOME @{thm prod.map_comp}) [true, true]
       @{thm show_law_prod}
  #&gt; Show_Generator.register_foreign_showsp @{typ unit} @{term &quot;showsp_unit&quot;} @{thm show_law_unit}
  #&gt; Show_Generator.register_foreign_showsp @{typ bool} @{term &quot;showsp_bool&quot;} @{thm show_law_bool}
  #&gt; Show_Generator.register_foreign_showsp @{typ char} @{term &quot;showsp_char&quot;} @{thm show_law_char}
  #&gt; Show_Generator.register_foreign_showsp @{typ nat} @{term &quot;showsp_nat&quot;} @{thm show_law_nat}
  #&gt; Show_Generator.register_foreign_showsp @{typ int} @{term &quot;showsp_int&quot;} @{thm show_law_int}
  #&gt; Show_Generator.register_foreign_showsp @{typ rat} @{term &quot;showsp_rat&quot;} @{thm show_law_rat}
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;show&quot;</span></span></span><span> </span><span>option</span><span> </span><span>sum</span><span> </span><span>prod</span><span> </span><span>unit</span><span> </span><span>bool</span><span> </span><span>nat</span><span> </span><span>int</span><span> </span><span>rat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;shows_prec :: &#39;a::show option showsp&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;shows_prec :: (&#39;a::show, &#39;b::show) sum showsp&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;shows_prec :: (&#39;a::show &#215; &#39;b::show) showsp&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;shows_prec :: unit showsp&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;shows_prec :: char showsp&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;shows_prec :: bool showsp&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;shows_prec :: nat showsp&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;shows_prec :: int showsp&quot;</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;shows_prec :: rat showsp&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">checking</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:25:56 AM CEST </td></tr></table></p></footer></div>

</html>


