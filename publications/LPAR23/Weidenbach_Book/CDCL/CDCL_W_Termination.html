<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory CDCL_W_Termination (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory CDCL_W_Termination</h1>

<span class="command">theory</span> <span class="name">CDCL_W_Termination</span><br/>
<span class="keyword">imports</span> <a href="CDCL_W.html"><span class="name">CDCL_W</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CDCL_W_Termination</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>CDCL_W</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>conflict_driven_clause_learning<span class="hidden">&#8681;</span><sub>W</sub></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Termination&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;No Relearning of a clause&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Because of the conflict minimisation, this version is less clear than the version without:
  instead of extracting the clause from the conflicting clause, we must take it from the clause
  used to backjump; i.e., the annotation of the first literal of the trail.

  We also prove below that no learned clause is subsumed by a (smaller) clause in the clause set.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_relearned_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mark_of (hd_trail T) &#8713;# clauses S&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n_dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;v literal&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;v, &#39;v clause) ann_lit list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span> </span><span>D&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>confl_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;conflicting S = Some (add_mset L D)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Decided K # M1, M2) &#8712; set (get_all_ann_decomposition (trail S))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_level (trail S) L = backtrack_lvl S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>max_D_L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_level (trail S) L = get_maximum_level (trail S) (add_mset L D&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_maximum_level (trail S) D&#39; &#8801; i&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_level (trail S) K = i + 1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T &#8764; cons_trail (Propagated L (add_mset L D&#39;))
        (reduce_trail_to M1
          (add_learned_cls (add_mset L D&#39;)
            (update_conflicting None S)))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>D_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; &#8838;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses S &#8872;pm add_mset L D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S = (M2&#39; @ M2) @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv</span><span> </span><span>inv</span><span> </span><span>W_other</span><span> </span><span>backtrack</span><span> </span><span>bj</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_M1_CNot_D&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>D&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D&#8250;</span></span></span><span> </span><span>T</span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L (add_mset L D&#39;)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>inv</span><span> </span><span>confl_S</span><span> </span><span>decomp</span><span> </span><span>i</span><span> </span><span>T</span><span> </span><span>D_D&#39;</span><span> </span><span>lev_K</span><span> </span><span>lev_L</span><span> </span><span>max_D_L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_mset_trans_add_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_T</span><span> </span><span>T</span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; + {#L#} &#8712;# clauses S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_dist</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller</span><span> </span><span>M1_D&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_smaller_propa_def</span><span> </span><span>M2&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_relearned_larger_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_conf</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_confl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>E_subset</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;E &#8834;# mark_of (hd_trail T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;E &#8713;# clauses S&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n_dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;v literal&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;v, &#39;v clause) ann_lit list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span> </span><span>D&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>confl_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;conflicting S = Some (add_mset L D)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Decided K # M1, M2) &#8712; set (get_all_ann_decomposition (trail S))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_level (trail S) L = backtrack_lvl S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>max_D_L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_level (trail S) L = get_maximum_level (trail S) (add_mset L D&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_maximum_level (trail S) D&#39; &#8801; i&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_level (trail S) K = i + 1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T &#8764; cons_trail (Propagated L (add_mset L D&#39;))
        (reduce_trail_to M1
          (add_learned_cls (add_mset L D&#39;)
            (update_conflicting None S)))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>D_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; &#8838;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses S &#8872;pm add_mset L D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S = (M2&#39; @ M2) @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv</span><span> </span><span>inv</span><span> </span><span>W_other</span><span> </span><span>backtrack</span><span> </span><span>bj</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (add_mset L D&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_T</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist_E</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset E&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_mset_mono_strict</span><span class="delimiter">[</span><span>OF</span><span> </span><span>E_subset</span><span class="delimiter">]</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_M1_CNot_D&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>D&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D&#8250;</span></span></span><span> </span><span>T</span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L (add_mset L D&#39;)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>inv</span><span> </span><span>confl_S</span><span> </span><span>decomp</span><span> </span><span>i</span><span> </span><span>T</span><span> </span><span>D_D&#39;</span><span> </span><span>lev_K</span><span> </span><span>lev_L</span><span> </span><span>max_D_L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_mset_trans_add_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_T</span><span> </span><span>T</span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# E&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>E&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>E</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;E = add_mset L E&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset E&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# E&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E&#39;_E&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;E&#39; &#8838;# D&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist_E</span><span> </span><span>T</span><span> </span><span>E_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1_E&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot E&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M1_D&#39;</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>E</span><span class="delimiter">]</span><span> </span><span>mset_subset_eq_insertD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M&#39; K M L D. trail S = M&#39; @ Decided K # M &#10233;
      D + {#L#} &#8712;# clauses S &#10233; undefined_lit M L &#10233; &#172; M &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_smaller_propa_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M1_E&#39;</span><span> </span><span>propa</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39; @ M2&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>E&#39;</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>M2&#39;</span><span> </span><span>_</span><span> </span><span>undef_L</span><span class="delimiter">]</span><span> </span><span>n_dist</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;E &#8838;# D&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_subset</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_add_mset_notin_subset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1_E</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot E&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M1_D&#39;</span><span> </span><span>T</span><span> </span><span>dist_E</span><span> </span><span>E_subset</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>E</span><span class="delimiter">]</span><span> </span><span>mset_subset_eq_insertD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M&#39; K M L D. trail S = M&#39; @ Decided K # M &#10233;
      D &#8712;# clauses S &#10233; &#172; M &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller_conf</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_smaller_confl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39; @ M2&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>E</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>M2&#39;</span><span class="delimiter">]</span><span> </span><span>n_dist</span><span> </span><span>M1_E</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_relearned_highest_subres_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_conf</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_confl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>E_subset</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mark_of (hd_trail T) = add_mset (lit_of (hd_trail T)) E&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset (- lit_of (hd_trail T)) E &#8713;# clauses S&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n_dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;v literal&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;v, &#39;v clause) ann_lit list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span> </span><span>D&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>confl_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;conflicting S = Some (add_mset L D)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Decided K # M1, M2) &#8712; set (get_all_ann_decomposition (trail S))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_level (trail S) L = backtrack_lvl S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>max_D_L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_level (trail S) L = get_maximum_level (trail S) (add_mset L D&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_maximum_level (trail S) D&#39; &#8801; i&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;get_level (trail S) K = i + 1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;T &#8764; cons_trail (Propagated L (add_mset L D&#39;))
        (reduce_trail_to M1
          (add_learned_cls (add_mset L D&#39;)
            (update_conflicting None S)))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>D_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; &#8838;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses S &#8872;pm add_mset L D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M2&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S = (M2&#39; @ M2) @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inv_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv</span><span> </span><span>inv</span><span> </span><span>W_other</span><span> </span><span>backtrack</span><span> </span><span>bj</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (add_mset L D&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_T</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M1_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1 &#8872;as CNot D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_M1_CNot_D&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>D&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D&#8250;</span></span></span><span> </span><span>T</span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L (add_mset L D&#39;)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>inv</span><span> </span><span>confl_S</span><span> </span><span>decomp</span><span> </span><span>i</span><span> </span><span>T</span><span> </span><span>D_D&#39;</span><span> </span><span>lev_K</span><span> </span><span>lev_L</span><span> </span><span>max_D_L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_mset_trans_add_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_L</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 L&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_T</span><span> </span><span>T</span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undef_uL</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 (-L)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M&#39; K M L D. trail S = M&#39; @ Decided K # M &#10233;
    D + {#L#} &#8712;# clauses S &#10233; undefined_lit M L &#10233; &#172; M &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_smaller_propa_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>E</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;E = D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>E_subset</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M&#39; K M L D. trail S = M&#39; @ Decided K # M &#10233;
    D + {#L#} &#8712;# clauses S &#10233; undefined_lit M L &#10233; &#172; M &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_smaller_propa_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span>M1_D&#39;</span><span> </span><span>propa</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39; @ M2&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>D&#39;</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>M2&#39;</span><span> </span><span>_</span><span> </span><span>undef_uL</span><span class="delimiter">]</span><span> </span><span>n_dist</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>E</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clauses S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (clauses T)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n_dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; distinct_mset (clauses T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span>
</span><span>        </span><span>elim</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>conflictE</span><span> </span><span>decideE</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_dist</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_relearned_clause</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>dist</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv</span><span> </span><span>smaller</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  This is a more restrictive version of the previous theorem, but is a better bound for an
  implementation that does not do duplication removal (esp. as part of preprocessing).
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_learned_distinct_mset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (learned_clss S + remdups_mset (init_clss S))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (learned_clss T + remdups_mset (init_clss T))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n_dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span>
</span><span>        </span><span>elim</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>conflictE</span><span> </span><span>decideE</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_dist</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_relearned_clause</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>dist</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv</span><span> </span><span>smaller</span><span> </span><span>clauses_def</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> R S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>invR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv R&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_mset (clauses R)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa R&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_mset (clauses S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset</span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_smaller_propa</span><span>
</span><span>      </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset_learned_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> R S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>invR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv R&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_mset (learned_clss R + remdups_mset (init_clss R))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa R&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_mset (learned_clss S + remdups_mset (init_clss S))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_learned_distinct_mset</span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_smaller_propa</span><span>
</span><span>      </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (init_state N) S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_duplicate_clause</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_mset N&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_duplicate_in_clause</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_mset_mset N&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_mset (clauses S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset_clauses</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span>no_smaller_propa_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_learned_distinct_mset_new</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (learned_clss S - A)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (learned_clss T - A)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (add_mset C (learned_clss S) - A) &#10231;
     C &#8713;# (learned_clss S) - A&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>distinct_mset_add_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss S - A&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;learned_clss S - A = remove1_mset C (add_mset C (learned_clss S) - A)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Multiset.diff_right_commute</span><span> </span><span>add_mset_remove_trivial</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;remove1_mset C (add_mset C (learned_clss S) - A) = add_mset C (learned_clss S) - A &#10230;
        distinct_mset (add_mset C (learned_clss S) - A)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Multiset.diff_right_commute</span><span> </span><span>add_mset_remove_trivial</span><span> </span><span>dist</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; distinct_mset (add_mset C (learned_clss S - A)) &#8744;
        distinct_mset (add_mset C (learned_clss S) - A) &#8800; (C &#8712;# learned_clss S - A)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Multiset.diff_right_commute</span><span>
</span><span>          </span><span>distinct_mset_add_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss S - A&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>add_mset_remove_trivial</span><span>
</span><span>          </span><span>diff_single_trivial</span><span> </span><span>insert_DiffM</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>distinct_mset_add_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss S - A&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>diff_single_trivial</span><span> </span><span>dist</span><span> </span><span>insert_DiffM</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n_dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span>
</span><span>        </span><span>elim</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>conflictE</span><span> </span><span>decideE</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_dist</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_relearned_clause</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inv</span><span> </span><span>smaller</span><span> </span><span>clauses_def</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset_clauses_new_abs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> R S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>invR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv R&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa R&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (learned_clss R - A)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_mset (learned_clss S - A)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset</span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_smaller_propa</span><span>
</span><span>      </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_learned_distinct_mset_new</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset_clauses_new</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> R S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>invR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv R&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa R&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_mset (learned_clss S - learned_clss R)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_distinct_mset_clauses_new_abs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decrease of a Measure&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure S =
  [(3::nat) ^ (card (atms_of_mm (init_clss S))) - card (set_mset (learned_clss S)),
    if conflicting S = None then 1 else 0,
    if conflicting S = None then card (atms_of_mm (init_clss S)) - length (trail S)
    else length (trail S)
    ]&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_model_le_vars</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;no_strange_atm S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (trail S)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;finite (atms_of_mm (init_clss S))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (trail S) &#8804; card (atms_of_mm (init_clss S))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span>N</span><span> </span><span>U</span><span> </span><span>k</span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;state S = (M, N, U, k, D)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;state S&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;finite (atm_of ` lits_of_l (trail S))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (trail S) = card (atm_of ` lits_of_l (trail S))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup_length_eq_card_atm_of_lits_of_l</span><span> </span><span>no_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_strange_atm_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_model_le_vars_all_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (trail S) &#8804; card (atms_of_mm (init_clss S))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>length_model_le_vars</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_decomp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>learned_clss_less_upper_bound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;st</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s &#8712;# learned_clss S. &#172;tautology s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card(set_mset (learned_clss S)) &#8804; 3 ^ card (atms_of_mm (learned_clss S))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set_mset (learned_clss S) &#8838; simple_clss (atms_of_mm (learned_clss S))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>simplified_in_simple_clss</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card(set_mset (learned_clss S))
    &#8804; card (simple_clss (atms_of_mm (learned_clss S)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>simple_clss_finite</span><span> </span><span>card_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>atms_of_ms_finite</span><span> </span><span>simple_clss_card</span><span> </span><span>finite_set_mset</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure_decreasing</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;st</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart S S&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_restart</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(learned_clss S &#8838;# learned_clss S&#39; &#8743; [] = trail S&#39; &#8743; conflicting S&#39; = None)&quot;</span></span></span><span>
</span><span>    </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*no restart*)</span></span></span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_forget</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;learned_clss S &#8838;# learned_clss S&#39;&quot;</span></span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*no forget*)</span></span></span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_relearn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;S&#39;. backtrack S S&#39; &#10233; mark_of (hd_trail S&#39;) &#8713;# learned_clss S&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_strange_atm S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>M_level</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_taut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s &#8712;# learned_clss S. &#172;tautology s&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure S&#39;, cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure S) &#8712; lexn less_than 3&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_all_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>propagate</span><span> </span><span>C</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conf</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;propagate S (cons_trail (Propagated L C) S)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propagate_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>propagate.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>propagate.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_dup&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (Propagated L C # trail S)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M_level</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_decomp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>undef</span><span> </span><span>defined_lit_map</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?N</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;init_clss S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_strange_atm (cons_trail (Propagated L C) S)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart.propagate</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_no_strange_atm_inv</span><span> </span><span>propa</span><span> </span><span>M_level</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atm_of ` lits_of_l (Propagated L C # trail S)
    &#8838; atms_of_mm (init_clss S)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_strange_atm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (atm_of ` lits_of_l (Propagated L C # trail S))
    &#8804; card (atms_of_mm (init_clss S))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>atms_of_ms_finite</span><span> </span><span>card_mono</span><span> </span><span>finite_set_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (Propagated L C # trail S) &#8804; card (atms_of_mm ?N)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup_length_eq_card_atm_of_lits_of_l</span><span> </span><span>no_dup&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (atms_of_mm (init_clss S)) - length (trail S)
    = Suc (card (atms_of_mm (init_clss S)) - Suc (length (trail S)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conf</span><span> </span><span>T</span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>H</span><span> </span><span>lexn3_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>decide</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conf</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undef</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;decide S (cons_trail (Decided L) S)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decide_rule</span><span> </span><span>decide.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart S (cons_trail (Decided L) S)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.intros</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lev</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (cons_trail (Decided L) S)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span> </span><span>M_level</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_consistent_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_dup (Decided L # trail S)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>undef</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;no_strange_atm (cons_trail (Decided L) S)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M_level</span><span> </span><span>alien</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_no_strange_atm_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (Decided L # (trail S))
      &#8804; card (atms_of_mm (init_clss S))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span>undef</span><span>
</span><span>      </span><span>length_model_le_vars</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cons_trail (Decided L) S&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lexn3_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>skip</span><span> </span><span>L</span><span> </span><span>C&#39;</span><span> </span><span>M</span><span> </span><span>D</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>tr</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>conf</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conf</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tr</span><span> </span><span>lexn3_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>conflict</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lexn3_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>resolve</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lexn3_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>i</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>T</span><span> </span><span>D&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conf</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>decomp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D_D&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?D&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;backtrack S T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>backtrack.hyps</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?D&#39; &#8713;# learned_clss S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_relearn</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bt</span><span class="delimiter">]</span><span> </span><span>conf</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_T</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;card (set_mset ({#?D&#39;#} + learned_clss S)) = Suc (card (set_mset (learned_clss S)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bt</span><span> </span><span>M_level</span><span> </span><span>distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_inv</span><span> </span><span>no_dup</span><span> </span><span>other</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.intros</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.intros</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;#learned_clss T. &#172; tautology s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>learned_clss_are_not_tautologies</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart.other</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.bj</span><span class="delimiter">[</span><span>OF</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.backtrack</span><span class="delimiter">[</span><span>OF</span><span> </span><span>bt</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>M_level</span><span> </span><span>no_taut</span><span> </span><span>confl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (set_mset (learned_clss T)) &#8804; 3 ^ card (atms_of_mm (learned_clss T))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>learned_clss_less_upper_bound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (set_mset ({#?D&#39;#} + learned_clss S))
      &#8804; 3 ^ card (atms_of_mm ({#?D&#39;#} + learned_clss S))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span>decomp</span><span> </span><span>M_level</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_decomp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;atms_of_mm ({#?D&#39;#} + learned_clss S) &#8838; atms_of_mm (init_clss S)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>conf</span><span> </span><span>atms_of_subset_mset_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>D_D&#39;</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_strange_atm_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;card (atms_of_mm ({#?D&#39;#} + learned_clss S))
      &#8804; card (atms_of_mm (init_clss S))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>atms_of_ms_finite</span><span> </span><span>card_mono</span><span> </span><span>finite_set_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3::nat) ^ card (atms_of_mm ({#?D&#39;#} + learned_clss S))
      &#8804; 3 ^ card (atms_of_mm (init_clss S))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(3::nat) ^ card (atms_of_mm (init_clss S))
    &#8805; card (set_mset ({#?D&#39;#} + learned_clss S))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span>diff_less_mono2</span><span> </span><span>card_T</span><span> </span><span>T</span><span> </span><span>M_level</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_decomp</span><span> </span><span>lexn3_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>restart</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>forget</span><span> </span><span>C</span><span> </span><span>T</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>no_forget</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;C &#8712;# learned_clss S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;C &#8713;# learned_clss T&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>forget.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; learned_clss S &#8838;# learned_clss T&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mset_subset_eqD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_forget</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_step_decreasing</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;st</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure T, cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure S) &#8712; lexn less_than 3&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure_decreasing</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; (learned_clss S &#8838;# learned_clss T &#8743; [] = trail T &#8743; conflicting T = None)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss S &#8838;# learned_clss T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mark_of (hd_trail S&#39;) &#8713;# learned_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack S S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_relearned_clause</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span class="delimiter">]</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_smaller_propa</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span>cdcl</span><span> </span><span>struct_inv</span><span> </span><span>smaller</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_strange_atm S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;s&#8712;#learned_clss S. &#172; tautology s&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_inv</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_trail_no_smaller_propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail R = [] &#10233; no_smaller_propa R&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_smaller_propa_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Roughly corresponds to \cwref{theo:prop:cdcltermlc}{theorem 2.9.15 page 100}
  but using a different bound (the bound is below)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_decreasing</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;st</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> R S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>tr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;trail R = []&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv R&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure S, cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure R) &#8712; lexn less_than 3&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induction</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_trail_no_smaller_propa</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_relearned_clause</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_step_decreasing</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tranclp_into_rtranclp</span><span class="delimiter">[</span><span>of</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span> </span><span>R</span><span class="delimiter">]</span><span> </span><span>lexn_transI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans_less_than</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>3</span><span class="delimiter">]</span><span>
</span><span>    </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_no_smaller_propa</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trans_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_step_decreasing</span><span> </span><span>empty_trail_no_smaller_propa</span><span>
</span><span>      </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_S0_decreasing</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>R</span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;st</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>pl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (init_state N) S&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>no_dup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct_mset_mset N&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure S, cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure (init_state N)) &#8712; lexn less_than 3&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (init_state N)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pl</span><span> </span><span>tranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_decreasing</span><span> </span><span>init_state_trail</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_tranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;wf {(S::&#39;st, init_state N)| S N. distinct_mset_mset N &#8743; cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> (init_state N) S}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_wf_if_measure&#39;_notation2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;lexn less_than 3&quot;</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_measure</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wf</span><span> </span><span>wf_lexn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_stgy_S0_decreasing</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The following theorems is deeply linked with the strategy: It shows that a decision alone
cannot lead to a conflict. This is obvious but I expect this to be a major part of the proof that
the number of learnt clause cannot be larger that \&lt;^term&gt;&#8249;2^n&#8250;.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_conflict_after_decide</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>dec</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;decide S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_confl T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;conflict T U&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# clauses T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail T &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflict.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (trail S) L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8712; atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; cons_trail (Decided L) S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>decide.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span>undef</span><span> </span><span>T</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# D&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail T = M&#39; @ Decided K # M &#10233;
      D + {#L#} &#8712;# clauses T &#10233; undefined_lit M L &#10233; &#172; M &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>M&#39;</span><span> </span><span>D</span><span> </span><span>L</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_smaller_propa_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot (remove1_mset (-L) D)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_annots_CNot_lit_of_notin_skip</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided L&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset (-L) D&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>T</span><span> </span><span>True</span><span>
</span><span>        </span><span>dist</span><span> </span><span>confl</span><span> </span><span>L_D</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Nil&#8250;</span></span></span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove1_mset (-L) D&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>T</span><span> </span><span>D</span><span> </span><span>confl</span><span> </span><span>undef</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail T = M&#39; @ Decided K # M &#10233;
      D &#8712;# clauses T &#10233; &#172; M &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span> </span><span>K</span><span> </span><span>M&#39;</span><span> </span><span>D</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller_confl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_smaller_confl_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_annots_CNot_lit_of_notin_skip</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided L&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span> </span><span>D</span><span class="delimiter">]</span><span> </span><span>T</span><span> </span><span>False</span><span>
</span><span>        </span><span>dist</span><span> </span><span>confl</span><span> </span><span>L_D</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Nil&#8250;</span></span></span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span> </span><span>D</span><span class="delimiter">]</span><span> </span><span>T</span><span> </span><span>D</span><span> </span><span>confl</span><span> </span><span>undef</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>list_weight_propa_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249; (&#39;v literal, &#39;v literal, &#39;v literal multiset) annotated_lit list &#8658; bool list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;list_weight_propa_trail M &#8801; map is_proped M&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>comp_list_weight_propa_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658;  (&#39;v literal, &#39;v literal, &#39;v literal multiset) annotated_lit list &#8658; bool list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;comp_list_weight_propa_trail b M &#8801; replicate (b - length M) False @ list_weight_propa_trail M&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_list_weight_propa_trail_append</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;comp_list_weight_propa_trail b (M @ M&#39;) =
     comp_list_weight_propa_trail (b - length M&#39;) M @ list_weight_propa_trail M&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_list_weight_propa_trail_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_list_weight_propa_trail_append_single</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;comp_list_weight_propa_trail b (M @ [K]) =
    comp_list_weight_propa_trail (b - 1) M @ [is_proped K]&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_list_weight_propa_trail_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_list_weight_propa_trail_cons</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;comp_list_weight_propa_trail b (K # M&#39;) =
    comp_list_weight_propa_trail (b - Suc (length M&#39;)) [] @ is_proped K # list_weight_propa_trail M&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_list_weight_propa_trail_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>of_list_weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;bool list &#8658; nat&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight [] = 0&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight (b # xs) = (if b then 1 else 0) + 2 * of_list_weight xs&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_list_weight_append</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight (a @ b) = of_list_weight a + 2^(length a) * of_list_weight b&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_list_weight_append_single</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight (a @ [b]) = of_list_weight a + 2^(length a) * (if b then 1 else 0)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_list_weight_append</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[b]&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>of_list_weight_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_list_weight_replicate_False</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight (replicate n False) = 0&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_list_weight_replicate_True</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight (replicate n True) = 2^n - 1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power_gt1_lemma</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;2 :: nat&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span> </span><span>Suc_diff_Suc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_list_weight_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight xs &#8804; 2^(length xs) - 1&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight xs &#8804; of_list_weight (replicate (length xs) True)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_list_weight_lt</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight xs &lt; 2^(length xs)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_list_weight_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span class="delimiter">]</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_le_lessD</span><span>
</span><span>    </span><span>Suc_le_mono</span><span> </span><span>Suc_pred</span><span> </span><span>of_list_weight_le</span><span> </span><span>zero_less_numeral</span><span> </span><span>zero_less_power</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight (comp_list_weight_propa_trail n []) = 0&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_list_weight_propa_trail_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>propa_weight</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; (&#39;v literal, &#39;v literal, &#39;v literal multiset) annotated_lit list &#8658; nat&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight n M &#8801; of_list_weight (comp_list_weight_propa_trail n M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_comp_list_weight_propa_trail</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (comp_list_weight_propa_trail a M) = max (length M) a&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_list_weight_propa_trail_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span>pow2_times_n</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a &#8804; n &#10233; 2 * 2^(n - Suc a) = (2::nat)^ (n - a)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a &#8804; n &#10233; 2^(n - Suc a) * 2 = (2::nat)^ (n - a)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a &#8804; n &#10233; 2^(n - Suc a) * b * 2 = (2::nat)^ (n - a) * b&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a &#8804; n &#10233; 2^(n - Suc a) * (b * 2) = (2::nat)^ (n - a) * b&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a &#8804; n &#10233; 2^(n - Suc a) * (2 * b) = (2::nat)^ (n - a) * b&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a &#8804; n &#10233; 2 * b * 2^(n - Suc a) = (2::nat)^ (n - a) * b&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a &#8804; n &#10233; 2 * (b * 2^(n - Suc a)) = (2::nat)^ (n - a) * b&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Suc_diff_Suc</span><span> </span><span>semiring_normalization_rules</span><span class="delimiter">(</span><span>27</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_diff_le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decide_propa_weight</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;decide S T &#10233; n &#8805; length (trail T) &#10233; propa_weight n (trail S) &#8804; propa_weight n (trail T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>decideE</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_list_weight_propa_trail_def</span><span>
</span><span>    </span><span>algebra_simps</span><span> </span><span>pow2_times_n</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>propagate_propa_weight</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate S T &#10233; n &#8805; length (trail T) &#10233; propa_weight n (trail S) &lt; propa_weight n (trail T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_list_weight_propa_trail_def</span><span>
</span><span>    </span><span>algebra_simps</span><span> </span><span>pow2_times_n</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  The theorem below corresponds the bound of \cwref{theo:prop:cdcltermlc}{theorem 2.9.15 page 100}.
  In the current version there is no proof of the bound.

  The following proof contains an immense amount of stupid bookkeeping. The proof itself
  is rather easy and Isabelle makes it extra-complicated.

  Let&#39;s consider the sequence \&lt;^text&gt;&#8249;S &#8594; ... &#8594; T&#8250;.
  The bookkeping part:
    &#9656; We decompose it into its components \&lt;^text&gt;&#8249;f 0 &#8594; f 1 &#8594; ... &#8594; f n&#8250;.
    &#9656; Then we extract the backjumps out of it, which are at position \&lt;^text&gt;&#8249;nth_nj 0&#8250;,
      \&lt;^text&gt;&#8249;nth_nj 1&#8250;, ...
    &#9656; Then we extract the conflicts out of it, which are at position \&lt;^text&gt;&#8249;nth_confl 0&#8250;,
      \&lt;^text&gt;&#8249;nth_confl 1&#8250;, ...

  Then the simple part:
    &#9656; each backtrack increases \&lt;^term&gt;&#8249;propa_weight&#8250;
    &#9656; but \&lt;^term&gt;&#8249;propa_weight&#8250; is bounded by \&lt;^term&gt;&#8249;2 ^ (card (atms_of_mm (init_clss S)))&#8250;
  Therefore, we get the bound.

  Comments on the proof:
  &#9642; The main problem of the proof is the number of inductions in the bookkeeping part.
  &#9642; The proof is actually by contradiction to make sure that enough backtrack step exists. This could
    probably be avoided, but without change in the proof.

  Comments on the bound:
  &#9642; The proof is very very crude: Any propagation also decreases the bound. The lemma
    @{thm no_conflict_after_decide} above shows that a decision cannot lead immediately to a
    conflict.
  &#9642; TODO: can a backtrack could be immediately followed by another conflict
    (if there are several conflicts for the initial backtrack)? If not the bound can be divided by
    two.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_pow2_n_learned_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (learned_clss T) &#8804; size (learned_clss S) + 2 ^ (card (atms_of_mm (init_clss S)))&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8804; _ + ?b&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ge</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?m</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card (atms_of_mm (init_clss S))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(cdcl<span class="hidden">&#8681;</span><sub>W</sub>^^n) S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rtranclp_power</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>f</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;i. i &lt; n &#10233; cdcl<span class="hidden">&#8681;</span><sub>W</sub> (f i) (f (Suc i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f 0 = S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f n = T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>power_ex_decomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cdcl_st_k</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S (f k)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &#8804; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?g</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;i. size (learned_clss (f i))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g 0 = size (learned_clss S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g n &gt; ?g 0 + 2 ^ (card (atms_of_mm (init_clss S)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g (Suc i) = ?g i &#8744; (?g (Suc i) = Suc (?g i) &#8743; backtrack (f i) (f (Suc i)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; n&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>conflictE</span><span> </span><span>decideE</span><span> </span><span>backtrackE</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g i &#8804; i + ?g 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8804; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_ge_m</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &gt; ?b&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_n</span><span> </span><span>ge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_add_less1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>nth_bj</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj = rec_nat 0 (&#955;_ j. (LEAST i. i &gt; j &#8743; i &lt; n &#8743; backtrack (f i) (f (Suc i))))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj 0 = 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_bj_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nth_bj_Suc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj (Suc i) = (LEAST x. nth_bj i &lt; x &#8743; x &lt; n &#8743; backtrack (f x) (f (Suc x)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>nth_bj_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>between_nth_bj_not_bt</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;backtrack (f k) (f (Suc k))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; n&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &gt; nth_bj i&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; nth_bj (Suc i) &#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_less_Least</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;x. nth_bj i &lt; x &#8743; x &lt; n &#8743; backtrack (f x) (f (Suc x))&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nth_bj_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g_nth_bj_eq</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g (Suc k) = ?g k&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; n&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &gt; nth_bj i&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; nth_bj (Suc i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>between_nth_bj_not_bt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>f</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>conflictE</span><span> </span><span>decideE</span><span> </span><span>backtrackE</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g_nth_bj_eq2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g (Suc k) = ?g (Suc (nth_bj i))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; n&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &gt; nth_bj i&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; nth_bj (Suc i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_nth_bj_eq</span><span> </span><span>less_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g (Suc 0) = ?g 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span>f</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>n0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>conflictE</span><span> </span><span>decideE</span><span> </span><span>backtrackE</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(?g (nth_bj i) = size (learned_clss S) + (i - 1)) &#8743;
    nth_bj i &lt; n &#8743;
    nth_bj i &#8805; i &#8743;
    (i &gt; 0 &#10230; backtrack (f (nth_bj i)) (f (Suc (nth_bj i)))) &#8743;
    (i &gt; 0 &#10230; ?g (Suc (nth_bj i)) = size (learned_clss S) + i) &#8743;
    (i &gt; 0 &#10230; nth_bj i &gt; nth_bj (i-1))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8804; ?b+1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g (nth_bj i) = size (learned_clss S) + (i - 1)&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; i &#10233; backtrack (f (nth_bj i)) (f (Suc (nth_bj i)))&#8250;</span></span></span><span>
</span><span>	</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;0 &lt; i &#10233; ?g (Suc (nth_bj i))  = size (learned_clss S) + i&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>i_le_m</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc i &#8804; ?b+1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>le_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj i &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>gei</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj i &#8805; i&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex_larger</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;x&gt;nth_bj i. x &lt; n &#8743; backtrack (f x) (f (Suc x))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n&gt;x &#10233; x&gt;nth_bj i &#10233; ?g (Suc x) = ?g x&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>n_ge_m</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj i &lt; Suc x &#10233; &#172; nth_bj i &lt; x &#10233; x = nth_bj i&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>eq2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj i &lt; x &#10233; &#172; nth_bj i &lt; x - Suc 0 &#10233; nth_bj i = x - Suc 0&#8250;</span></span></span><span>
</span><span>	 </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex_larger</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n&gt;x &#10233; x&gt;nth_bj i &#10233; ?g (Suc x) = ?g (Suc (nth_bj i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj i &lt; x&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>eq1</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n-1&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g_n_nth_bj</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g n = ?g (Suc (nth_bj i))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_ge_m</span><span> </span><span>i_le_m</span><span> </span><span>le_n</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj i &lt; n - Suc 0&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>eq2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (learned_clss (f (Suc (nth_bj i)))) &lt; size (learned_clss T)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_n</span><span> </span><span>i_le_m</span><span> </span><span>n_ge_m</span><span> </span><span>g_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_bj i)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>le_n</span><span> </span><span>ge</span><span>
</span><span>	   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g (nth_bj i) = size (learned_clss S) + (i - 1)&#8250;</span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.IH</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_n</span><span> </span><span>i_le_m</span><span> </span><span>n_ge_m</span><span> </span><span>g_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_bj i)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>g_n_nth_bj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>LeastI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ex_larger</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bt</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack (f (nth_bj (Suc i))) (f (Suc (nth_bj (Suc i))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj (Suc i) &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>nth_mono</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj i &lt; nth_bj (Suc i)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nth_bj_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g_nth_Suc_g_Suc_nth</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?g (nth_bj (Suc i)) = ?g (Suc (nth_bj i))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>g_nth_bj_eq2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj (Suc i) - 1&#8250;</span></span></span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>le</span><span> </span><span>nth_mono</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*TODO proof*)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_pred</span><span> </span><span>gr0I</span><span> </span><span>less_Suc0</span><span> </span><span>less_Suc_eq</span><span> </span><span>less_imp_diff_less</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (learned_clss (f (Suc (nth_bj (Suc i))))) =
       1 + size (learned_clss (f (nth_bj (Suc i))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>that</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>backtrackE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &gt; 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IH</span><span> </span><span>that</span><span> </span><span>nth_mono</span><span> </span><span>le</span><span> </span><span>bt</span><span> </span><span>gei</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>backtrackE</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>g_nth_Suc_g_Suc_nth</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span>bt</span><span> </span><span>gei</span><span> </span><span>nth_mono</span><span> </span><span>IH</span><span> </span><span>g_nth_bj_eq2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj (Suc i) - 1&#8250;</span></span></span><span> </span><span>i</span><span class="delimiter">]</span><span>
</span><span>        </span><span>g_nth_Suc_g_Suc_nth</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>that</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>backtrackE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>that</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>backtrackE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span>Hk</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>that</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>backtrackE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>that</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>backtrackE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(?g (nth_bj i) = size (learned_clss S) + (i - 1))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>nth_bj_le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj i &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>nth_bj_ge</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj i &#8805; i&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>bt_nth_bj</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &gt; 0 &#10233; backtrack (f (nth_bj i)) (f (Suc (nth_bj i)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &gt; 0 &#10233; ?g (Suc (nth_bj i)) = size (learned_clss S) + i&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>nth_bj_mono</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &gt; 0 &#10233; nth_bj (i - 1) &lt; nth_bj i&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8804; ?b+1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>confl_None</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (f (Suc (nth_bj i))) = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl_nth_bj</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (f (nth_bj i)) &#8800; None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8804; ?b+1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bt_nth_bj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>backtrack.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conflicting_still_conflicting</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (f k) &#8800; None &#10230; conflicting (f (Suc k)) &#8800; None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; n&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &gt; nth_bj i&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; nth_bj (Suc i)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>between_nth_bj_not_bt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span>f</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>conflictE</span><span> </span><span>decideE</span><span> </span><span>backtrackE</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>nth_confl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_confl n &#8801; LEAST i. i &gt; nth_bj n &#8743; i &lt; nth_bj (Suc n) &#8743; conflict (f i) (f (Suc i))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;i&gt;nth_bj a. i &lt; nth_bj (Suc a) &#8743; conflict (f i) (f (Suc i))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; ?thesis&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (f (nth_bj a + Suc i)) = None&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj a + Suc i &#8804; nth_bj (Suc a)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_None</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>a_n</span><span> </span><span>n_ge_m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_bj a + i) &lt; n&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj a + Suc i&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>H</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>conflictE</span><span> </span><span>decideE</span><span> </span><span>backtrackE</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_bj_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>a_n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj (Suc a) - 1 - nth_bj a&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>a_n</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_bj_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>a_n</span><span> </span><span>nth_bj_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>confl_nth_bj</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>LeastI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nth_bj_le_nth_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj a &lt; nth_confl a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>nth_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflict (f (nth_confl a)) (f (Suc (nth_confl a)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>nth_confl_le_nth_bj_Suc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_confl a &lt; nth_bj (Suc a)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nth_confl_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nth_confl_conflicting</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (f (Suc (nth_confl a))) &#8800; None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_confl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflict.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_conflict_before_nth_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;conflict (f k) (f (Suc k))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &gt; nth_bj a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; nth_confl a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_less_Least</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;i. i &gt; nth_bj a &#8743; i &lt; nth_bj (Suc a) &#8743; conflict (f i) (f (Suc i))&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>that</span><span>
</span><span>    </span><span>nth_confl_le_nth_bj_Suc</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>nth_confl_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conflicting_after_nth_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (f (Suc (nth_confl a) + k)) &#8800; None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &gt; 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>k</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_confl a) + k &lt; nth_bj (Suc a)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_confl_conflicting</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conflicting_still_conflicting</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_confl a + k)&#8250;</span></span></span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>a_n</span><span>
</span><span>        </span><span>nth_bj_le</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>nth_bj_le_nth_confl</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_confl a + k) &lt; n&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Suc_le_lessD</span><span> </span><span>add.commute</span><span> </span><span>le_less</span><span> </span><span>less_trans_Suc</span><span> </span><span>nth_bj_le</span><span>
</span><span>         </span><span>plus_1_eq_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conflicting_before_nth_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (f (Suc (nth_bj a) + k)) = None&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &gt; 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>k</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_bj a) + k &lt; nth_confl a&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl_None</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>a_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_bj a) + k&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>no_conflict_before_nth_confl</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_bj a) + k&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>a_n</span><span>
</span><span>        </span><span>nth_confl_le_nth_bj_Suc</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>nth_bj_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_bj a + k) &lt; n&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>conflictE</span><span> </span><span>decideE</span><span> </span><span>backtrackE</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>ex_trail_decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;M. trail (f (Suc (nth_confl a))) = M @ trail (f (Suc (nth_confl a + k)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &gt; 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>k</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_confl a) + k &#8804; nth_bj (Suc a)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?case&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_confl a + k &lt; n&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>	</span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nth_bj (Suc a) &lt; n&quot;</span></span></span><span>
</span><span>	  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_bj_le</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>a_n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>	  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;Ma. M @ trail (f (Suc (nth_confl a + k))) =
            Ma @ tl (trail (f (Suc (nth_confl a + k))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (f (Suc (nth_confl a + k)))&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_confl a + k)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>conflicting_after_nth_confl</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span> </span><span>Suc</span><span>
</span><span>        </span><span>between_nth_bj_not_bt</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_confl a + k)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>	</span><span>nth_bj_le_nth_confl</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_confl a + k) &lt; n&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>propagateE</span><span> </span><span>conflictE</span><span> </span><span>decideE</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span>
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Suc_leD</span><span> </span><span>Suc_lessI</span><span> </span><span>a_n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span> </span><span>add_Suc</span><span>
</span><span>	  </span><span>add_mono_thms_linordered_semiring</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>le_numeral_extra</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>not_le</span><span> </span><span>nth_bj_le</span><span> </span><span>plus_1_eq_Suc</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa_weight_decreasing_confl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight n (trail (f (Suc (nth_bj (Suc a))))) &gt; propa_weight n (trail (f (nth_confl a)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &gt; 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8805; length (trail (f (nth_confl a)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pw0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight n (trail (f (Suc (nth_confl a)))) =
      propa_weight n (trail (f (nth_confl a)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (f (Suc (nth_confl a))) = trail (f (nth_confl a))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_confl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>conflictE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj (Suc a) = Suc (nth_confl a) &#8744; nth_bj (Suc a) &#8805; Suc (Suc (nth_confl a))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_bj_le_nth_confl</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>nth_confl_le_nth_bj_Suc</span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ex_trail_decomp</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_bj (Suc a) - (1+nth_confl a)&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>M</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (f (Suc (nth_confl a))) = M @ trail (f (nth_bj (Suc a)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>H</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_bj_le_nth_confl</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span> </span><span>nth_bj_ge</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>a_n</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>numeral_2_eq_2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>D</span><span> </span><span>D&#39;</span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided K # M1, M2)
         &#8712; set (get_all_ann_decomposition (trail (f (nth_bj (Suc a)))))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (trail (f (nth_bj (Suc a)))) (add_mset L D&#39;) =
       backtrack_lvl (f (nth_bj (Suc a)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail (f (nth_bj (Suc a)))) L = backtrack_lvl (f (nth_bj (Suc a)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail (f (nth_bj (Suc a)))) K =
       Suc (get_maximum_level (trail (f (nth_bj (Suc a)))) D&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; &#8838;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses (f (nth_bj (Suc a))) &#8872;pm add_mset L D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>st_Suc</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;f (Suc (nth_bj (Suc a))) &#8764;
       cons_trail (Propagated L (add_mset L D&#39;))
        (reduce_trail_to M1
          (add_learned_cls (add_mset L D&#39;)
            (update_conflicting None (f (nth_bj (Suc a))))))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bt_nth_bj</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>a_n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>backtrackE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>tr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (f (nth_bj (Suc a))) = M3 @ M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>decomp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M2&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39; = M3 @ M2&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span>tr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (f (nth_bj (Suc a))) = M2&#39; @ Decided K # M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>M&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; = M @ M2&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tr2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (f (nth_confl a)) = M&#39; @ Decided K # M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tr</span><span> </span><span>M</span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;max (length M) (n - Suc (length M1 + (length M2&#39;)))
      = (n - Suc (length M1 + (length M2&#39;)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tr</span><span> </span><span>M</span><span> </span><span>st_Suc</span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;2 *
      (of_list_weight (list_weight_propa_trail M1) *
       (2 ^ length M2&#39; *
        (2 ^ (n - Suc (length M1 + length M2&#39;))))) =
	 of_list_weight (list_weight_propa_trail M1) * 2 ^ (n - length M1)&#8250;</span></span></span><span>
</span><span>	 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tr</span><span> </span><span>M</span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>algebra_simps</span><span> </span><span>field_simps</span><span> </span><span>pow2_times_n</span><span>
</span><span>	   </span><span>comm_semiring_1_class.semiring_normalization_rules</span><span class="delimiter">(</span><span>26</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_ge</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (length M + (length M2&#39; + length M1)) &#8804; n&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n</span><span> </span><span>st_Suc</span><span> </span><span>tr</span><span> </span><span>M</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>WTF</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &lt; b &#10233; b &#8804; c &#10233; a &lt; c&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>WTF&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; b &#10233; b &lt; c &#10233; a &lt; c&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight (n - Suc (length M1 + (length M2&#39;))) M
      &#8804; 2^(n - Suc (length M1 + length M2&#39;)) - 1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_list_weight_le</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;max (length M) (n - Suc (length M1 + (length M2&#39;))) = n - Suc (length M1 + (length M2&#39;))&#8250;</span></span></span><span>
</span><span>        </span><span>length_comp_list_weight_propa_trail</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight (list_weight_propa_trail M2&#39;) *
      2 ^ (n - Suc (length M1 + length M2&#39;)) &lt; Suc (if M2&#39; = [] then 0
        else 2 ^ (n - Suc (length M1)) - 2 ^ (n - Suc (length M1 + length M2&#39;)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#39; = []&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>WTF&#39;</span><span class="delimiter">)</span><span>
</span><span>	  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Nat.mult_le_mono1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;of_list_weight (list_weight_propa_trail M2&#39;)&#8250;</span></span></span><span class="delimiter">,</span><span>
</span><span>	  </span><span>OF</span><span> </span><span>of_list_weight_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(list_weight_propa_trail M2&#39;)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_list_weight_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(list_weight_propa_trail M2&#39;)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>n</span><span> </span><span>M</span><span> </span><span>tr</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>comm_semiring_1_class.semiring_normalization_rules</span><span class="delimiter">(</span><span>26</span><span class="delimiter">)</span><span>
</span><span>	  </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>WTF2</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; a&#39; &#10233; b &lt; b&#39; &#10233; a + b &lt; a&#39; + b&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>a&#39;</span><span> </span><span>b&#39;</span><span> </span><span>c&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight (n - Suc (length M1 + length M2&#39;)) M +
    of_list_weight (list_weight_propa_trail M2&#39;) *
    2 ^ (n - Suc (length M1 + length M2&#39;))
    &lt; 2 ^ (n - Suc (length M1))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>WTF</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>WTF2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>3</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_ge</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>nat_le_iff_add</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ac_simps</span><span> </span><span>algebra_simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight n (trail (f (nth_confl a))) &lt; propa_weight n (trail (f (Suc (nth_bj (Suc a)))))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tr2</span><span> </span><span>M</span><span> </span><span>st_Suc</span><span> </span><span>n</span><span> </span><span>tr</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pow2_times_n</span><span> </span><span>algebra_simps</span><span>
</span><span>        </span><span>comm_semiring_1_class.semiring_normalization_rules</span><span class="delimiter">(</span><span>26</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?thesis&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pw0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length_trail_le_m</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (trail (f k)) &lt; ?m + 1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &#8804; n&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (f k)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_st_k</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>inv</span><span>
</span><span>      </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (f k)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_strange_atm (f k)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail (f k))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>incl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of ` lits_of_l (trail (f k)) &#8838; atms_of_mm (init_clss (f k))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span>no_strange_atm_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(atms_of_mm (init_clss (f k))) = (atms_of_mm (init_clss S))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_init_clss</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cdcl_st_k</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (trail (f k)) = card (atm_of ` lits_of_l (trail (f k)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail (f k))&#8250;</span></span></span><span> </span><span>no_dup_length_eq_card_atm_of_lits_of_l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card (atm_of ` lits_of_l (trail (f k))) &#8804; ?m&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>incl</span><span class="delimiter">]</span><span> </span><span>eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa_weight_decreasing_propa</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight ?m (trail (f (nth_confl a))) &#8805; propa_weight ?m (trail (f (Suc (nth_bj a))))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ppa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight ?m (trail (f (Suc (nth_bj a) + Suc k)))
      &#8805; propa_weight ?m (trail (f (Suc (nth_bj a) + k)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; nth_confl a - Suc (nth_bj a)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_bj a + k) &lt; n&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_bj a + k) &lt; nth_confl a&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>nth_bj_le_nth_confl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span> </span><span>nth_confl_le_nth_bj_Suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span>
</span><span>	  </span><span>nth_bj_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>a_n</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Suc (nth_bj a) + k)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>conflicting_before_nth_confl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>	</span><span>no_conflict_before_nth_confl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>a_n</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (nth_bj a) + k&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>that</span><span>
</span><span>	</span><span>length_trail_le_m</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (Suc (nth_bj a) + k)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>skipE</span><span> </span><span>resolveE</span><span> </span><span>backtrackE</span><span>
</span><span>            </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span>
</span><span>	    </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>propagate_propa_weight</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="var">?m</span><span class="delimiter">]</span><span>
</span><span>	      </span><span>decide_propa_weight</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="var">?m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>WTF3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Suc (nth_bj a + (nth_confl a - Suc (nth_bj a)))) = nth_confl a&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>nth_bj_le_nth_confl</span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight ?m (trail (f (Suc (nth_bj a) + k)))
      &#8805; propa_weight ?m (trail (f (Suc (nth_bj a))))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &#8804; nth_confl a - Suc (nth_bj a)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ppa</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;k &lt; nth_confl a - Suc (nth_bj a)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_confl a - (Suc (nth_bj a))&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>WTF3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>propa_weight_decreasing_confl</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight ?m (trail (f (Suc (nth_bj a))))
      &lt; propa_weight ?m (trail (f (Suc (nth_bj (Suc a)))))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>WTF</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;b &lt; c &#10233; a &#8804; b &#10233; a &lt; c&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span>  </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_confl a &lt; n&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_le_mono</span><span> </span><span>a_n</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span> </span><span>add_lessD1</span><span> </span><span>less_imp_le</span><span> </span><span>nat_le_iff_add</span><span>
</span><span>        </span><span>nth_bj_le</span><span> </span><span>nth_confl_le_nth_bj_Suc</span><span> </span><span>plus_1_eq_Suc</span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>WTF</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>propa_weight_decreasing_confl</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?m</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>	</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_trail_le_m</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_confl a&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nth_confl a &lt; n&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>propa_weight_decreasing_propa</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_n</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>weight1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight ?m (trail (f (Suc (nth_bj 1)))) &#8805; 1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bt_nth_bj</span><span class="delimiter">[</span><span>of</span><span> </span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>backtrackE</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>trans_le_add1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight ?m (trail (f (Suc (nth_bj (Suc a))))) &#8805;
       propa_weight ?m (trail (f (Suc (nth_bj 1)))) + a&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>a_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8804; ?b&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>propa_weight_decreasing_confl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc a&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?b&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propa_weight ?m (trail (f (Suc (nth_bj (Suc (?b)))))) &#8805; 1 + ?b&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;max (length (trail (f (Suc (nth_bj (Suc ?b)))))) ?m = ?m&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_trail_le_m</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Suc (nth_bj (Suc ?b)))&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>Suc_leI</span><span> </span><span>nth_bj_le</span><span>
</span><span>    </span><span>nth_bj_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (?b)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;False&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>of_list_weight_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;comp_list_weight_propa_trail ?m (trail (f (Suc (nth_bj (Suc ?b)))))&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>state_eq_init_clss</span><span> </span><span>state_eq_trail</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Application of the previous theorem to an initial state:&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>cdcl_pow2_n_learned_clauses2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>cdcl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (init_state N) T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (init_state N)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;size (learned_clss T) &#8804; 2 ^ (card (atms_of_mm N))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>cdcl_pow2_n_learned_clauses</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_state N&#8250;</span></span></span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A rather obvious theorem, but can be handy when talking about CDCL with inclusion of new rules.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_enlarge_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail T = trail S &#8743; init_clss T = init_clss S + N&#39; &#8743;
    learned_clss T = learned_clss S + U&#39; &#8743; conflicting T = conflicting S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;T&#39;. trail T&#39; = trail S&#39; &#8743; init_clss T&#39; = init_clss S&#39; + N&#39; &#8743;
    learned_clss T&#39; = learned_clss S&#39; + U&#39; &#8743; conflicting T&#39; = conflicting S&#39; &#8743;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub> T T&#39;&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>H</span><span> </span><span class="delimiter">=</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail (Propagated L C)
        (reduce_trail_to xx_M
          (add_learned_cls _ (update_conflicting None T)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xx_M</span><span> </span><span>L</span><span> </span><span>C</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induction</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>propagate.simps</span><span> </span><span>clauses_def</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conflicting_cons_trail</span><span> </span><span>init_clss_cons_trail</span><span> </span><span>learned_clss_cons_trail</span><span> </span><span>state_eq_ref</span><span> 
</span><span>      </span><span>trail_cons_trail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>conflict.simps</span><span> </span><span>clauses_def</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>conflicting_update_conflicting</span><span> </span><span>init_clss_update_conflicting</span><span>
</span><span>      </span><span>learned_clss_update_conflicting</span><span> </span><span>state_eq_ref</span><span> </span><span>trail_update_conflicting</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>decide.simps</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>conflicting_cons_trail_conflicting</span><span> </span><span>init_clss_cons_trail</span><span>
</span><span>      </span><span>learned_clss_cons_trail</span><span> </span><span>state_eq_ref</span><span> </span><span>state_eq_trail</span><span> </span><span>trail_cons_trail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>skip.simps</span><span> </span><span>clauses_def</span><span>  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trail T&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>resolve.simps</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conflicting_update_conflicting</span><span> </span><span>init_clss_tl_trail</span><span> </span><span>init_clss_update_conflicting</span><span> </span><span>learned_clss_tl_trail</span><span> </span><span>learned_clss_update_conflicting</span><span> </span><span>state_eq_ref</span><span> </span><span>trail_tl_trail</span><span> </span><span>trail_update_conflicting</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>backtrack.simps</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>xx_M8</span><span class="delimiter">=</span><span>M1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L8</span><span class="delimiter">=</span><span>L</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C8</span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>H</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>L</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>D</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>K</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>M1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>D&#39;</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span> </span><span>Un_commute</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_enlarge_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail T = trail S &#8743; init_clss T = init_clss S + N&#39; &#8743;
    learned_clss T = learned_clss S + U&#39; &#8743; conflicting T = conflicting S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rtranclp cdcl<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;T&#39;. trail T&#39; = trail S&#39; &#8743; init_clss T&#39; = init_clss S&#39; + N&#39; &#8743;
    learned_clss T&#39; = learned_clss S&#39; + U&#39; &#8743; conflicting T&#39; = conflicting S&#39; &#8743;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T T&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>T</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>U</span><span> </span><span>T&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>T&#39;</span><span class="delimiter">]</span><span> </span><span>p</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span>-</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_enlarge_clauses</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span> </span><span>U</span><span> </span><span>_</span><span> </span><span>N&#39;</span><span> </span><span>U&#39;</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_clauses_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail T = trail S &#8743; set_mset (init_clss T) = set_mset (init_clss S) &#8743;
    set_mset (learned_clss T) = set_mset (learned_clss S) &#8743; conflicting T = conflicting S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;T&#39;. trail T&#39; = trail S&#39; &#8743; set_mset (init_clss T&#39;) = set_mset (init_clss S&#39;) &#8743;
      learned_clss T&#39; = learned_clss T + (learned_clss S&#39; - learned_clss S) &#8743; conflicting T&#39; = conflicting S&#39; &#8743;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub> T T&#39;&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>H</span><span> </span><span class="delimiter">=</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail (Propagated L C)
        (reduce_trail_to xx_M
          (add_learned_cls _ (update_conflicting None T)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>xx_M</span><span> </span><span>L</span><span> </span><span>C</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>induction</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>propagate.simps</span><span> </span><span>clauses_def</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conflicting_cons_trail</span><span> </span><span>init_clss_cons_trail</span><span> </span><span>learned_clss_cons_trail</span><span> </span><span>state_eq_ref</span><span> 
</span><span>      </span><span>trail_cons_trail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>conflict.simps</span><span> </span><span>clauses_def</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>conflicting_update_conflicting</span><span> </span><span>init_clss_update_conflicting</span><span>
</span><span>      </span><span>learned_clss_update_conflicting</span><span> </span><span>state_eq_ref</span><span> </span><span>trail_update_conflicting</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>decide.simps</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>conflicting_cons_trail_conflicting</span><span> </span><span>init_clss_cons_trail</span><span>
</span><span>      </span><span>learned_clss_cons_trail</span><span> </span><span>state_eq_ref</span><span> </span><span>state_eq_trail</span><span> </span><span>trail_cons_trail</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>skip.simps</span><span> </span><span>clauses_def</span><span>  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tl_trail T&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>resolve.simps</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>conflicting_update_conflicting</span><span> </span><span>init_clss_tl_trail</span><span> </span><span>init_clss_update_conflicting</span><span> </span><span>learned_clss_tl_trail</span><span> </span><span>learned_clss_update_conflicting</span><span> </span><span>state_eq_ref</span><span> </span><span>trail_tl_trail</span><span> </span><span>trail_update_conflicting</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>backtrack.simps</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>xx_M8</span><span class="delimiter">=</span><span>M1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L8</span><span class="delimiter">=</span><span>L</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C8</span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>H</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span class="delimiter">[</span><span>4</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>L</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>D</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>K</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>M1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>D&#39;</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Un_assoc</span><span> </span><span>Un_commute</span><span> </span><span>ac_simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learnel_clss_mono</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub> S T &#10233; learned_clss S &#8838;# learned_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_bj.simps</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_mono</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; learned_clss S &#8838;# learned_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learnel_clss_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_clauses_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail T = trail S &#8743; set_mset (init_clss T) = set_mset (init_clss S) &#8743;
    set_mset (learned_clss T) = set_mset (learned_clss S) &#8743; conflicting T = conflicting S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;rtranclp cdcl<span class="hidden">&#8681;</span><sub>W</sub> S S&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;T&#39;. trail T&#39; = trail S&#39; &#8743; set_mset (init_clss T) = set_mset (init_clss S) &#8743;
    learned_clss T&#39; = learned_clss T + (learned_clss S&#39; - learned_clss S) &#8743; conflicting T&#39; = conflicting S&#39; &#8743;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub><span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T T&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>T</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>U</span><span> </span><span>T&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>T&#39;</span><span class="delimiter">]</span><span> </span><span>p</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>4</span><span>-</span><span class="delimiter">)</span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_clauses_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span> </span><span>U</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart</span><span> </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_init_clss</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_multiset_minus_notin_snd</span><span> </span><span>mset_subset_eqD</span><span> </span><span>mset_subset_eq_add_right</span><span>
</span><span>      </span><span>rtranclp_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_mono</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>T&#39;aa</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learnel_clss_mono</span><span> </span><span>p</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>subset_mset.add_diff_assoc</span><span> </span><span>subset_mset.add_diff_assoc2</span><span>
</span><span>     </span><span>subset_mset.add_diff_inverse</span><span> </span><span>union_assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_clauses_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail T = trail S &#8743; set_mset (init_clss T) = set_mset (init_clss S) &#8743;
    set_mset (learned_clss T) = set_mset (learned_clss S) &#8743; conflicting T = conflicting S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>no_strange_atm_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>   </span><span>distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span> </span><span>clauses_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause_def</span><span>
</span><span>  </span><span>reasons_in_clauses_def</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:25:56 AM CEST </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


