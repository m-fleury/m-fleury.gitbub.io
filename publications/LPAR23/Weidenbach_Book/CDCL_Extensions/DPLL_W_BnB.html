<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory DPLL_W_BnB (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory DPLL_W_BnB</h1>

<span class="command">theory</span> <span class="name">DPLL_W_BnB</span><br/>
<span class="keyword">imports</span> <a href="CDCL_W_Optimal_Model.html"><span class="name">CDCL_W_Optimal_Model</span></a> <a href="../CDCL/DPLL_W.html"><span class="name">DPLL_W</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>DPLL_W_BnB</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CDCL_W_Optimal_Model</span><span>
</span><span>  </span><span>CDCL.DPLL_W</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_split M1 = (M&#39;, L # M) &#10233; is_decided L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>backtrack_split_snd_hd_decided</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>funpow_tl_append_skip_ge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8805; length M&#39; &#10233; ((tl ^^ n) (M&#39; @ M)) = (tl ^^ (n - length M&#39;)) M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>M&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span>M&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>M&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>funpow.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>funpow_Suc_right</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*TODO MOVE*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The following version is more suited than @{thm backtrack_split_some_is_decided_then_snd_has_hd}
 for direct use.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>backtrack_split_some_is_decided_then_snd_has_hd&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;l&#8712;set M &#10233; is_decided l &#10233; &#8707;M&#39; L&#39; M&#39;&#39;. backtrack_split M = (M&#39;&#39;, L&#39; # M&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>backtrack_snd_empty_not_decided</span><span> </span><span>list.exhaust</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>total_over_m_entailed_or_conflict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m M N &#10233; M &#8872;s N &#8744; (&#8707;C &#8712; N. M &#8872;s CNot C)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Set.set_insert</span><span> </span><span>total_not_true_cls_true_clss_CNot</span><span> </span><span>total_over_m_empty</span><span> </span><span>total_over_m_insert</span><span> </span><span>true_clss_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The locales on DPLL should eventually be moved to the DPLL theory, but currently it is only a discount
  version (in particular, we cheat and don&#39;t use \&lt;^text&gt;&#8249;S &#8764; T&#8250; in the transition system below, even if it
  would be cleaner to do as as we de for CDCL).
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dpll_ops</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>clauses</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lit &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state_eq</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8764;&#8250;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#215; &#39;v clauses &#215; &#39;b&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>additional_info</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_info S = (&#955;(M, N, w). w) (state S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reduce_trail_to</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;reduce_trail_to M S = (tl_trail ^^ (length (trail S) - length M)) S&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>bnb_ops</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>clauses</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lit &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state_eq</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8764;&#8250;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#215; &#39;v clauses &#215; &#39;a &#215; &#39;b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_weight_information</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>is_improving_int</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#8658; &#39;v clauses &#8658; &#39;a &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting_clauses</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clauses &#8658; &#39;a &#8658; &#39;v clauses&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>dpll</span><span class="delimiter">:</span><span> </span><span>dpll_ops</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>trail</span><span> </span><span class="delimiter">=</span><span> </span><span>trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>clauses</span><span> </span><span class="delimiter">=</span><span> </span><span>clauses</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>tl_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>tl_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>cons_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>cons_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>state_eq</span><span> </span><span class="delimiter">=</span><span> </span><span>state_eq</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span>state</span><span>
</span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>conflicting_clss</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v literal multiset multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting_clss S = conflicting_clauses (clauses S) (weight S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>abs_state</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;abs_state S = (trail S, clauses S + conflicting_clss S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>is_improving</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving M M&#39; S &#8801; is_improving_int M M&#39; (clauses S) (weight S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>state&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#215; &#39;v clauses &#215; &#39;a &#215; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state&#39; S = (trail S, clauses S, weight S, conflicting_clss S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>additional_info</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;b&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_info S = (&#955;(M, N, _, w). w) (state S)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_state</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>dpll_ops</span><span> </span><span>trail</span><span> </span><span>clauses</span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span>cons_trail</span><span> </span><span>state_eq</span><span> </span><span>state</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>    </span><span>trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>clauses</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lit &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state_eq</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8764;&#8250;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#215; &#39;v clauses &#215; &#39;b&#8250;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>state_eq_ref</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S &#8764; S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state_eq_sym</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S &#8764; T &#10231; T &#8764; S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state_eq_trans</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S &#8764; T &#10233; T &#8764; U&#39; &#10233; S &#8764; U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state_eq_state</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S &#8764; T &#10233; state S = state T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>
</span><span>    </span><span>cons_trail</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;S&#39;. state st = (M, S&#39;) &#10233;
        state (cons_trail L st) = (L # M, S&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>
</span><span>    </span><span>tl_trail</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;S&#39;. state st = (M, S&#39;) &#10233; state (tl_trail st) = (tl M, S&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state S = (trail S, clauses S, additional_info S)&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses (cons_trail uu S) = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (cons_trail uu S) = uu # trail S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (tl_trail S) = tl (trail S)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses (tl_trail S) = clauses (S)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_info (cons_trail L S) = additional_info S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_info (tl_trail S) = additional_info S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span>
</span><span>    </span><span>cons_trail</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>    </span><span>tl_trail</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>state_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; S &#10233; trail T = trail S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; S &#10233; clauses T = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>state_eq_state</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>state_tl_trail</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state (tl_trail S) = (tl (trail S), clauses S, additional_info S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>state_tl_trail_comp_pow</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state ((tl_trail ^^ n) S) = ((tl ^^ n) (trail S), clauses S, additional_info S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_tl_trail</span><span> </span><span>state</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reduce_trail_to_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_split (trail S) = (M&#39;, L # M) &#10233; trail (reduce_trail_to M S) = M&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses (reduce_trail_to M S) = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_info (reduce_trail_to M S) = additional_info S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_tl_trail_comp_pow</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (length M&#39;)&#8250;</span></span></span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reduce_trail_to_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span> </span><span>funpow_tl_append_skip_ge</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state</span><span> </span><span>state_tl_trail_comp_pow</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>dpll_backtrack</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll_backtrack S T&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D &#8712;# clauses S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_split (trail S) = (M&#39;, L # M)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764;cons_trail (Propagated (-lit_of L) ()) (reduce_trail_to M S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>dpll_propagate</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll_propagate S T&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L D &#8712;# clauses S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (trail S) L&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; cons_trail (Propagated L ()) S&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>dpll_decide</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll_decide S T&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (trail S) L&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; cons_trail (Decided L) S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8712; atms_of_mm (clauses S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>dpll</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll_decide S T&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll_propagate S T&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll_backtrack S T&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll_is_dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub> (trail S, clauses S) (trail T, clauses T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll.simps</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll_decide.simps</span><span> </span><span>dpll_backtrack.simps</span><span> </span><span>dpll_propagate.simps</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses S&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll.simps</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll_decide.simps</span><span> </span><span>dpll_backtrack.simps</span><span> </span><span>dpll_propagate.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll_decide.simps</span><span> </span><span>dpll_backtrack.simps</span><span> </span><span>dpll_propagate.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>bnb</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>bnb_ops</span><span> </span><span>trail</span><span> </span><span>clauses</span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span>cons_trail</span><span> </span><span>state_eq</span><span> </span><span>state</span><span> </span><span>weight</span><span> </span><span>update_weight_information</span><span> </span><span>is_improving_int</span><span> </span><span>conflicting_clauses</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>    </span><span>weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;a&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_weight_information</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>is_improving_int</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#8658; &#39;v clauses &#8658; &#39;a &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>clauses</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lit &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state_eq</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8764;&#8250;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting_clauses</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clauses &#8658; &#39;a &#8658; &#39;v clauses&#8250;</span></span></span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v  dpll<span class="hidden">&#8681;</span><sub>W</sub>_ann_lits &#215; &#39;v clauses &#215; &#39;a &#215; &#39;b&#8250;</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>state_eq_ref</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S &#8764; S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state_eq_sym</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S &#8764; T &#10231; T &#8764; S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state_eq_trans</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S &#8764; T &#10233; T &#8764; U&#39; &#10233; S &#8764; U&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state_eq_state</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S &#8764; T &#10233; state S = state T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>
</span><span>    </span><span>cons_trail</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;S&#39;. state st = (M, S&#39;) &#10233;
        state (cons_trail L st) = (L # M, S&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>
</span><span>    </span><span>tl_trail</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;S&#39;. state st = (M, S&#39;) &#10233; state (tl_trail st) = (tl M, S&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_weight_information</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state S = (M, N, w, oth) &#10233;
          &#8707;w&#39;. state (update_weight_information M&#39; S) = (M, N, w&#39;, oth)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>
</span><span>    </span><span>conflicting_clss_update_weight_information_mono</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S) &#10233; is_improving M M&#39; S &#10233;
        conflicting_clss S &#8838;# conflicting_clss (update_weight_information M&#39; S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting_clss_update_weight_information_in</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving M M&#39; S &#10233; negate_ann_lits M&#39; &#8712;# conflicting_clss (update_weight_information M&#39; S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>atms_of_conflicting_clss</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (conflicting_clss S) &#8838; atms_of_mm (clauses S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state S = (trail S, clauses S, weight S, additional_info S)&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DPLL_W.clauses (abs_state S) = clauses S + conflicting_clss S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DPLL_W.trail (abs_state S) = trail S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>abs_state_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (update_weight_information M&#39; S) = trail S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>update_weight_information</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses (update_weight_information M&#39; S) = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (cons_trail uu S) = weight S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses (cons_trail uu S) = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting_clss (cons_trail uu S) = conflicting_clss S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (cons_trail uu S) = uu # trail S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (tl_trail S) = tl (trail S)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses (tl_trail S) = clauses (S)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (tl_trail S) = weight (S)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting_clss (tl_trail S) = conflicting_clss (S)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_info (cons_trail L S) = additional_info S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_info (tl_trail S) = additional_info S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_info (update_weight_information M&#39; S) = additional_info S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>update_weight_information</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>    </span><span>cons_trail</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>    </span><span>tl_trail</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span> </span><span>conflicting_clss_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>state_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; S &#10233; trail T = trail S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; S &#10233; clauses T = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; S &#10233; weight T = weight S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; S &#10233; conflicting_clss T = conflicting_clss S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>state_eq_state</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span> </span><span>conflicting_clss_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>dpll</span><span class="delimiter">:</span><span> </span><span>dpll_ops</span><span> </span><span>trail</span><span> </span><span>clauses</span><span> </span><span>tl_trail</span><span> </span><span>cons_trail</span><span> </span><span>state_eq</span><span> </span><span>state</span><span>
</span><span>  </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>dpll</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_state</span><span> </span><span>trail</span><span> </span><span>clauses</span><span> </span><span>tl_trail</span><span> </span><span>cons_trail</span><span> </span><span>state_eq</span><span> </span><span>state</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>state_eq_sym</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>state_eq_trans</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>state_eq_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span> </span><span>cons_trail</span><span> </span><span>dpll.additional_info_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting_clss (dpll.reduce_trail_to M S) = conflicting_clss S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (dpll.reduce_trail_to M S) = weight S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll.reduce_trail_to_simps</span><span class="delimiter">(</span><span>2</span><span>-</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span>state</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll.additional_info_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>conflicting_clss_def</span><span> </span><span>dpll.reduce_trail_to_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>dpll.state</span><span> </span><span>dpll_ops.additional_info_def</span><span>
</span><span>    </span><span>old.prod.inject</span><span> </span><span>state</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>backtrack_opt</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>backtrack_opt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;backtrack_split (trail S) = (M&#39;, L # M) &#10233; is_decided L &#10233; D &#8712;# conflicting_clss S
  &#10233; trail S &#8872;as CNot D
  &#10233; T &#8764;cons_trail (Propagated (-lit_of L) ()) (dpll.reduce_trail_to M S)
  &#10233; backtrack_opt S T&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  In the definition below the \&lt;^term&gt;&#8249;state&#39; T = (Propagated L () # trail
  S, clauses S, weight S, conflicting_clss S)&#8250; are not necessary, but
  avoids to change the DPLL formalisation with proper locales, as we
  did for CDCL.

  The DPLL calculus looks slightly more general than the CDCL calculus
  because we can take any conflicting clause from \&lt;^term&gt;&#8249;conflicting_clss S&#8250;.
  However, this does not make a difference for the trail, as we backtrack
  to the last decision independantly of the conflict.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>propagate</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll.dpll_propagate S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>decided</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll.dpll_decide S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T &#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>backtrack</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll.dpll_backtrack S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>backtrack_opt</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_opt S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_coreE</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>update_info</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving M M&#39; S &#10233; T &#8764; (update_weight_information M&#39; S)
   &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound S T&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>dpll</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>bnb</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound S T&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnbE</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb S T&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_is_dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub> (abs_state S) (abs_state T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>abs_state_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>state&#39;_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll.dpll_propagate.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll.dpll_decide.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll.dpll_backtrack.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>backtrack_opt.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_abs_state_all_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S) &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_is_dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_same_weight</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T &#10233; weight S = weight T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>abs_state_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>state&#39;_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll.dpll_propagate.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll.dpll_decide.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll.dpll_backtrack.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>backtrack_opt.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound_trail</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound S T &#10233; trail S = trail T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound_clauses</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound S T &#10233; clauses S = clauses T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound_conflicting_clss</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S) &#10233; conflicting_clss S &#8838;# conflicting_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_def</span><span> </span><span>state</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>conflicting_clss_update_weight_information_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound.induct</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_def</span><span> </span><span>state</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>conflicting_clss_update_weight_information_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span> </span><span>conflicting_clss_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>conflicting_clss_update_weight_information_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound_abs_state_all_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S) &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound_conflicting_clss</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound_clauses</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>   </span><span>atms_of_conflicting_clss</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>atms_of_conflicting_clss</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_def</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound_trail</span><span> </span><span>lits_of_def</span><span> </span><span>image_image</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>all_decomposition_implies_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>set_mset_mono</span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound_conflicting_clss</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>all_decomposition_implies_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb_abs_state_all_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S) &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound_abs_state_all_inv</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_abs_state_all_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb_abs_state_all_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S) &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb_abs_state_all_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T &#10233; clauses S = clauses T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span>abs_state_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>state&#39;_def</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll.dpll_propagate.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>dpll.dpll_decide.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span>  </span><span>dpll.dpll_backtrack.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span>  </span><span>backtrack_opt.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb S T &#10233; clauses S = clauses T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnbE</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound_clauses</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_clauses</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; clauses S = clauses T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>  </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb_clauses</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atms_of_clauses_conflicting_clss</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (clauses S) &#8746; atms_of_mm (conflicting_clss S) = atms_of_mm (clauses S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atms_of_conflicting_clss</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb_bnb</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete"><a id="wf_dpll_bnb"></a></span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>improve</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;S T. dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound S T &#10233; clauses S = N &#10233; (&#957; (weight T), &#957; (weight S)) &#8712; R&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>wf_R</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf R&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S) &#8743; dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb S T &#8743;
      clauses S = N}&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?A&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?R</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{(T, S). (&#957; (weight T), &#957; (weight S)) &#8712; R}&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv S &#8743; dpll<span class="hidden">&#8681;</span><sub>W</sub> S T}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>wf_if_measure_f</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>abs_state</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S).  dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S) &#8743;
      dpll<span class="hidden">&#8681;</span><sub>W</sub> (abs_state S) (abs_state T) &#8743; weight S = weight T}&#8250;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?CDCL&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf (?R &#8746; ?CDCL)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_union_compatible</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_if_measure_f</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_R</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;x. &#957; (weight x)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_same_weight</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A &#8838; ?R &#8746; ?CDCL&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnbE</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_abs_state_all_inv</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_is_dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_same_weight</span><span> </span><span>improve</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight ((tl_trail ^^ n) S) = weight S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail ((tl_trail ^^ n) S) = (tl ^^ n) (trail S)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses ((tl_trail ^^ n) S) = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting_clss ((tl_trail ^^ n) S) = conflicting_clss S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll.state_tl_trail_comp_pow</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state</span><span> </span><span>conflicting_clss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Pair_inject</span><span> </span><span>dpll.state</span><span> </span><span>state</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_Ex_propagate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L C &#8712;# clauses S &#10233; trail S &#8872;as CNot C &#10233; undefined_lit (trail S) L &#10233;
    Ex (dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_Ex_decide</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;undefined_lit (trail S) L &#10233; atm_of L &#8712; atms_of_mm (clauses S) &#10233;
     Ex (dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_Ex_backtrack</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;backtrack_split (trail S) = (M&#39;, L&#39; # M) &#10233; is_decided L&#39; &#10233; D &#8712;# clauses S &#10233;
   trail S &#8872;as CNot D &#10233; Ex (dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_Ex_backtrack_opt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;backtrack_split (trail S) = (M&#39;, L&#39; # M) &#10233; is_decided L&#39; &#10233; D &#8712;# conflicting_clss S
  &#10233; trail S &#8872;as CNot D &#10233;
   Ex (dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail (Propagated L ()) S&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.simps</span><span> </span><span>state_eq_ref</span><span> </span><span>dpll.dpll_propagate.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail (Decided L) S&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.simps</span><span> </span><span>state&#39;_def</span><span> </span><span>dpll.dpll_decide.simps</span><span> </span><span>dpll.dpll_backtrack.simps</span><span>
</span><span>        </span><span>backtrack_opt.simps</span><span> </span><span>dpll.dpll_propagate.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail (Propagated (-lit_of L&#39;) ()) (dpll.reduce_trail_to M S)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.simps</span><span> </span><span>state&#39;_def</span><span> </span><span>funpow_tl_append_skip_ge</span><span>
</span><span>       </span><span>dpll.dpll_decide.simps</span><span> </span><span>dpll.dpll_backtrack.simps</span><span> </span><span>backtrack_opt.simps</span><span>
</span><span>        </span><span>dpll.dpll_propagate.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail (Propagated (-lit_of L&#39;) ()) (dpll.reduce_trail_to M S)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.simps</span><span> </span><span>state&#39;_def</span><span> </span><span>funpow_tl_append_skip_ge</span><span>
</span><span>       </span><span>dpll.dpll_decide.simps</span><span> </span><span>dpll.dpll_backtrack.simps</span><span> </span><span>backtrack_opt.simps</span><span>
</span><span>        </span><span>dpll.dpll_propagate.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Unlike the CDCL case, we do not need assumptions on improve. The reason behind it is that
  we do not need any strategy on propagation and decisions.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_dpll_bnb_dpll<span class="hidden">&#8681;</span><sub>W</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct_invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step dpll<span class="hidden">&#8681;</span><sub>W</sub> (abs_state S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_decide</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8712; atms_of_mm (clauses S) &#10233;
                  defined_lit (trail S) L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ns</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail _ S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb.simps</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span>
</span><span>      </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.simps</span><span> </span><span>state&#39;_def</span><span>
</span><span>       </span><span>dpll.dpll_decide.simps</span><span> </span><span>dpll.dpll_backtrack.simps</span><span> </span><span>backtrack_opt.simps</span><span>
</span><span>       </span><span>dpll.dpll_propagate.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_decided L &#10233;
       backtrack_split (trail S) = (M&#39;, L # M) &#10233;
       trail S &#8872;as CNot D &#10233; D &#8712;# clauses S &#10233; False&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>D</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_Ex_backtrack</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>D</span><span class="delimiter">]</span><span> </span><span>ns</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_decided L &#10233;
       backtrack_split (trail S) = (M&#39;, L # M) &#10233;
       trail S &#8872;as CNot D &#10233; D &#8712;# conflicting_clss S &#10233; False&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>D</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_Ex_backtrack_opt</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>M&#39;</span><span> </span><span>L</span><span> </span><span>M</span><span> </span><span>D</span><span class="delimiter">]</span><span> </span><span>ns</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (lits_of_l (trail S)) (set_mset (clauses S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_decide</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span> </span><span>state&#39;_def</span><span>
</span><span>      </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L C &#8712;# clauses S &#10233; defined_lit (trail S) L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>C</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_decide</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;add_mset L C &#8712;# conflicting_clss S &#10233; defined_lit (trail S) L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>C</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_decide</span><span> </span><span>atms_of_conflicting_clss</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>.simps</span><span> </span><span>no_decide</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>can_always_improve</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;S. trail S &#8872;asm clauses S &#10233; (&#8704;C &#8712;# conflicting_clss S. &#172; trail S &#8872;as CNot C) &#10233;
       dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S) &#10233;
       total_over_m (lits_of_l (trail S)) (set_mset (clauses S)) &#10233; Ex (dpll<span class="hidden">&#8681;</span><sub>W</sub>_bound S)&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb_conflict</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>invs</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv (abs_state S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;C &#8712;# clauses S + conflicting_clss S. trail S &#8872;as CNot C&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?A</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (trail S) = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (clauses S + conflicting_clss S))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_decide</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8712; atms_of_mm (clauses S) &#10233; defined_lit (trail S) L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spec</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ns</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail _ S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb.simps</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span>
</span><span>      </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.simps</span><span> </span><span>state&#39;_def</span><span> 
</span><span>       </span><span>dpll.dpll_decide.simps</span><span> </span><span>dpll.dpll_backtrack.simps</span><span> </span><span>backtrack_opt.simps</span><span>
</span><span>       </span><span>dpll.dpll_propagate.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (lits_of_l (trail S)) (set_mset (clauses S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_decide</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span> </span><span>state&#39;_def</span><span>
</span><span>      </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dec0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (trail S) = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# clauses S + conflicting_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent</span><span> </span><span>tot</span><span> </span><span>ns</span><span> </span><span>invs</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (trail S) = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ns</span><span>  </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_Ex_backtrack</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>C</span><span class="delimiter">]</span><span>  </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_Ex_backtrack_opt</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>C</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>count_decided_0_iff</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>backtrack_split_some_is_decided_then_snd_has_hd&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb.simps</span><span> </span><span>count_decided_0_iff</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>backtrack_split_snd_hd_decided</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;?A&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;a C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# clauses S + conflicting_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; trail S &#8872;as CNot C&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;?A&#8250;</span></span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?thesis&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span> </span><span>that</span><span>
</span><span>        </span><span>total_not_true_cls_true_clss_CNot</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lits_of_l (trail S)&#8250;</span></span></span><span> </span><span>C</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>true_clss_def_iff_negation_in_model</span><span>  </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_annot_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_annot_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>atms_of_clauses_conflicting_clss</span><span> </span><span>atms_of_ms_union</span><span>
</span><span>          </span><span>in_m_in_literals</span><span> </span><span>no_decide</span><span> </span><span>set_mset_union</span><span> </span><span>that</span><span> </span><span>true_annot_def</span><span> </span><span>true_cls_add_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;asm clauses S + conflicting_clss S&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_def</span><span>  </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>can_always_improve</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;?A&#8250;</span></span></span><span> </span><span>tot</span><span> </span><span>invs</span><span> </span><span>ns</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_bnb.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (trail S) = 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (clauses S + conflicting_clss S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>only_propagated_vars_unsat</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span> </span><span>_</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (clauses S + conflicting_clss S)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>invs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_all_inv_def</span><span> </span><span>count_decided_0_iff</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>T</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>propagate</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll.dpll_propagate S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy S T&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>decided</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll.dpll_decide S T &#10233; no_step dpll.dpll_propagate S  &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy S T &#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>backtrack</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll.dpll_backtrack S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy S T&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>backtrack_opt</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_opt S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy S T&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy_dpll<span class="hidden">&#8681;</span><sub>W</sub>_core</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy_dpll<span class="hidden">&#8681;</span><sub>W</sub>_core</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; dpll<span class="hidden">&#8681;</span><sub>W</sub>_core<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy_dpll<span class="hidden">&#8681;</span><sub>W</sub>_core</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_stgy_iff</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy S &#10231; no_step dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy.simps</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>full_dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy_dpll<span class="hidden">&#8681;</span><sub>W</sub>_core</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy S T &#10233; full dpll<span class="hidden">&#8681;</span><sub>W</sub>_core S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>no_step_stgy_iff</span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy_dpll<span class="hidden">&#8681;</span><sub>W</sub>_core</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy S T &#10233; clauses T = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy.induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dpll.dpll_propagate.simps</span><span> </span><span>dpll.dpll_decide.simps</span><span> </span><span>dpll.dpll_backtrack.simps</span><span>
</span><span>      </span><span>backtrack_opt.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; clauses T = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>dpll<span class="hidden">&#8681;</span><sub>W</sub>_core_stgy_clauses</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:25:56 AM CEST </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


