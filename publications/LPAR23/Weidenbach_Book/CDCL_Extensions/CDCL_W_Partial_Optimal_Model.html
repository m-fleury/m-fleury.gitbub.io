<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory CDCL_W_Partial_Optimal_Model (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory CDCL_W_Partial_Optimal_Model</h1>

<span class="command">theory</span> <span class="name">CDCL_W_Partial_Optimal_Model</span><br/>
<span class="keyword">imports</span> <a href="CDCL_W_Partial_Encoding.html"><span class="name">CDCL_W_Partial_Encoding</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CDCL_W_Partial_Optimal_Model</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>CDCL_W_Partial_Encoding</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isabelle_should_do_that_automatically</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc (a - Suc 0) = a &#10231; a &#8805; 1&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>conflict_driven_clause_learning<span class="hidden">&#8681;</span><sub>W</sub>_optimal_weight</span><span class="delimiter">)</span><span>
</span><span>   </span><span>conflict_opt_state_eq_compatible</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflict_opt S T &#10233; S &#8764; S&#39; &#10233; T &#8764; T&#39; &#10233; conflict_opt S&#39; T&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_eq_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>T&#39;</span><span> </span><span>T</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_conflicting (Some (negate_ann_lits (trail S&#39;))) S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_eq_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_conflicting (Some (negate_ann_lits (trail S&#39;))) S&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_conflicting (Some (negate_ann_lits (trail S&#39;))) S&#39;&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>update_conflicting_state_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Some {#}&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflict_opt.simps</span><span> </span><span>state_eq_sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reduce_trail_to_state_eq</span><span> </span><span>state_eq_trans</span><span> </span><span>update_conflicting_state_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>optimal_encoding</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>base_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v &#8658; &#39;v&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;base_atm L = (if L &#8712; &#931; - &#916;&#931; then L else
    if L &#8712; replacement_neg ` &#916;&#931; then (SOME K. (K &#8712; &#916;&#931; &#8743; L = replacement_neg K))
    else (SOME K. (K &#8712; &#916;&#931; &#8743; L = replacement_pos K)))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_lit_Some_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(SOME K. K &#8712; &#916;&#931; &#8743; (L<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup> = K<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>)) = L&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; &#916;&#931;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>K</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>some1_equality</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>that</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>base_atm_simps1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; &#931; &#10233; L &#8713; &#916;&#931; &#10233; base_atm L = L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>base_atm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>base_atm_simps2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; (&#931; - &#916;&#931;) &#8746; replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931; &#10233;
    K &#8712; &#931; &#10233; K &#8713; &#916;&#931; &#10233; L &#8712; &#931; &#10233; K = base_atm L &#10231; L = K&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>base_atm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>base_atm_simps3</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; &#931; - &#916;&#931; &#10233; base_atm L &#8712; &#931;&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931; &#10233; base_atm L &#8712; &#916;&#931;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>base_atm_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>tfl_some</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>base_atm_simps4</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; &#916;&#931; &#10233; base_atm (replacement_pos L) = L&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; &#916;&#931; &#10233; base_atm (replacement_neg L) = L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>base_atm_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>normalize_lit</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal &#8658; &#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;normalize_lit (Pos L) =
    (if L &#8712; replacement_neg ` &#916;&#931;
      then Neg (replacement_pos (SOME K. (K &#8712; &#916;&#931; &#8743; L = replacement_neg K)))
     else Pos L)&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;normalize_lit (Neg L) =
    (if L &#8712; replacement_neg ` &#916;&#931;
      then Pos (replacement_pos (SOME K. K &#8712; &#916;&#931; &#8743; L = replacement_neg K))
     else Neg L)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>normalize_clause</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause &#8658; &#39;v clause&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;normalize_clause C &#8801; normalize_lit `# C&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_lit</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; &#931; - &#916;&#931; &#10233; normalize_lit (Pos L) = (Pos L)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; &#931; - &#916;&#931; &#10233; normalize_lit (Neg L) = (Neg L)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; &#916;&#931; &#10233; normalize_lit (Pos (replacement_neg L)) = Neg (replacement_pos L)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; &#916;&#931; &#10233; normalize_lit (Neg (replacement_neg L)) = Pos (replacement_pos L)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>all_clauses_literals</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_clauses_literals =
    (SOME xs. mset xs = mset_set ((&#931; - &#916;&#931;) &#8746; replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span class="tfree">&#39;c</span><span> </span><span>search_depth</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>sd_is_zero</span><span class="delimiter">:</span><span> </span><span>SD_ZERO</span><span> </span><span class="delimiter">(</span><span>the_search_depth</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;c</span><span class="delimiter">)</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>sd_is_one</span><span class="delimiter">:</span><span> </span><span>SD_ONE</span><span> </span><span class="delimiter">(</span><span>the_search_depth</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;c</span><span class="delimiter">)</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>sd_is_two</span><span class="delimiter">:</span><span> </span><span>SD_TWO</span><span> </span><span class="delimiter">(</span><span>the_search_depth</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;c</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>-</span><span class="delimiter">)</span><span> </span><span>un_hide_sd</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a search_depth list &#8658; &#39;a list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;un_hide_sd &#8801; map the_search_depth&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nat_of_search_deph</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;c search_depth &#8658; nat&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_of_search_deph (SD_ZERO _) = 0&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_of_search_deph (SD_ONE _) = 1&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat_of_search_deph (SD_TWO _) = 2&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>opposite_var</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;opposite_var L = (if L &#8712; replacement_pos ` &#916;&#931; then replacement_neg (base_atm L)
    else replacement_pos (base_atm L))&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>opposite_var_replacement_if</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; (replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;) &#10233; A &#8712; &#916;&#931; &#10233;
   opposite_var L = replacement_pos A &#10231; L = replacement_neg A&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; (replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;) &#10233; A &#8712; &#916;&#931; &#10233;
   opposite_var L = replacement_neg A &#10231; L = replacement_pos A&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; &#916;&#931; &#10233; opposite_var (replacement_pos A) = replacement_neg A&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; &#916;&#931; &#10233; opposite_var (replacement_neg A) = replacement_pos A&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>opposite_var_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;finite &#931;&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_clauses_literals</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset all_clauses_literals = mset_set ((&#931; - &#916;&#931;) &#8746; replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct all_clauses_literals&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set all_clauses_literals = ((&#931; - &#916;&#931;) &#8746; replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset_set ((&#931; - &#916;&#931;) &#8746; replacement_neg ` &#916;&#931; &#8746;
      replacement_pos ` &#916;&#931;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset all_clauses_literals = ?A&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>someI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;xs. mset xs = ?A&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>finite_&#931;</span><span> </span><span>ex_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?A</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_clauses_literals_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct all_clauses_literals&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>someI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;xs. mset xs = ?A&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>finite_&#931;</span><span> </span><span>ex_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?A</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_clauses_literals_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>distinct_mset_mset_set</span><span> </span><span>distinct_mset_mset_distinct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set all_clauses_literals = ((&#931; - &#916;&#931;) &#8746; replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>set_mset</span><span class="delimiter">]</span><span> </span><span>finite_&#931;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>unset_literals_in_&#931;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unset_literals_in_&#931;  M L &#10231; undefined_lit M (Pos L) &#8743; L &#8712; &#931; - &#916;&#931;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>full_unset_literals_in_&#916;&#931;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full_unset_literals_in_&#916;&#931;  M L &#10231;
    undefined_lit M (Pos L) &#8743; L &#8713; &#931; - &#916;&#931; &#8743; undefined_lit M (Pos (opposite_var L)) &#8743;
    L &#8712; replacement_pos ` &#916;&#931;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>full_unset_literals_in_&#916;&#931;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full_unset_literals_in_&#916;&#931;&#39;  M L &#10231;
    undefined_lit M (Pos L) &#8743; L &#8713; &#931; - &#916;&#931; &#8743; undefined_lit M (Pos (opposite_var L)) &#8743;
    L &#8712; replacement_neg ` &#916;&#931;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>half_unset_literals_in_&#916;&#931;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;half_unset_literals_in_&#916;&#931;  M L &#10231;
    undefined_lit M (Pos L) &#8743; L &#8713; &#931; - &#916;&#931; &#8743; defined_lit M (Pos (opposite_var L))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sorted_unadded_literals</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, &#39;v clause) ann_lits &#8658; &#39;v list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sorted_unadded_literals M =
  (let
    M0 = filter (full_unset_literals_in_&#916;&#931;&#39; M) all_clauses_literals;
      &#8213; &#8249;weight is 0&#8250;
    M1 = filter (unset_literals_in_&#931; M) all_clauses_literals;
      &#8213; &#8249;weight is 2&#8250;
    M2 = filter (full_unset_literals_in_&#916;&#931; M) all_clauses_literals;
      &#8213; &#8249;weight is 2&#8250;
    M3 = filter (half_unset_literals_in_&#916;&#931; M) all_clauses_literals
      &#8213; &#8249;weight is 1&#8250;
  in
    M0 @ M3 @ M1 @ M2)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>complete_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, &#39;v clause) ann_lits &#8658; (&#39;v, &#39;v clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;complete_trail M =
  (map (Decided o Pos) (sorted_unadded_literals M) @ M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_sorted_unadded_literals_undefD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of (lit_of l) &#8712; set (sorted_unadded_literals M) &#10233; l &#8713; set M&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of (l&#39;) &#8712; set (sorted_unadded_literals M) &#10233; undefined_lit M l&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xa &#8712; set (sorted_unadded_literals M) &#10233; lit_of x = Neg xa &#10233;  x &#8713; set M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>set_sorted_unadded_literals</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (sorted_unadded_literals M) =
     Set.filter (&#955;L. undefined_lit M (Pos L)) (set all_clauses_literals)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sorted_unadded_literals_def</span><span> </span><span>undefined_notin</span><span>  </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span>defined_lit_Neg_Pos_iff</span><span> </span><span>half_unset_literals_in_&#916;&#931;_def</span><span> </span><span>full_unset_literals_in_&#916;&#931;_def</span><span>
</span><span>    </span><span>unset_literals_in_&#931;_def</span><span> </span><span>Let_def</span><span> </span><span>full_unset_literals_in_&#916;&#931;&#39;_def</span><span>
</span><span>    </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full_unset_literals_in_&#916;&#931; [] = (&#955;L. L &#8712; replacement_pos ` &#916;&#931;)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full_unset_literals_in_&#916;&#931;&#39; [] = (&#955;L. L &#8712; replacement_neg ` &#916;&#931;)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;half_unset_literals_in_&#916;&#931; [] = (&#955;L. False)&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unset_literals_in_&#931; [] = (&#955;L. L &#8712; &#931; - &#916;&#931;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>full_unset_literals_in_&#916;&#931;_def</span><span>
</span><span>    </span><span>unset_literals_in_&#931;_def</span><span> </span><span>full_unset_literals_in_&#916;&#931;&#39;_def</span><span>
</span><span>    </span><span>half_unset_literals_in_&#916;&#931;_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filter_disjount_union</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8896;x. x &#8712; set xs &#10233; P x &#10233; &#172;Q x) &#10233;
   length (filter P xs) + length (filter Q xs) =
     length (filter (&#955;x. P x &#8744; Q x) xs)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_sorted_unadded_literals_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (sorted_unadded_literals []) = length all_clauses_literals&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sorted_unadded_literals_def</span><span> </span><span>sum_length_filter_compl</span><span>
</span><span>    </span><span>Let_def</span><span> </span><span>ac_simps</span><span> </span><span>filter_disjount_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>filter_disjount_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>filter_disjount_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Diff_iff</span><span> </span><span>UnE</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>filter_True</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_unadded_literals_Cons_notin_all_clauses_literals</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of (lit_of K) &#8713; set all_clauses_literals&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sorted_unadded_literals (K # M) = sorted_unadded_literals M&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter (full_unset_literals_in_&#916;&#931;&#39; (K # M))
                            all_clauses_literals =
                           filter (full_unset_literals_in_&#916;&#931;&#39; M)
                            all_clauses_literals&#8250;</span></span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter (full_unset_literals_in_&#916;&#931; (K # M))
                            all_clauses_literals =
                           filter (full_unset_literals_in_&#916;&#931; M)
                            all_clauses_literals&#8250;</span></span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter (half_unset_literals_in_&#916;&#931; (K # M))
                            all_clauses_literals =
                           filter (half_unset_literals_in_&#916;&#931; M)
                            all_clauses_literals&#8250;</span></span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter (unset_literals_in_&#931; (K # M)) all_clauses_literals =
       filter (unset_literals_in_&#931; M) all_clauses_literals&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_unset_literals_in_&#916;&#931;&#39;_def</span><span>  </span><span>full_unset_literals_in_&#916;&#931;_def</span><span>
</span><span>     </span><span>half_unset_literals_in_&#916;&#931;_def</span><span> </span><span>unset_literals_in_&#931;_def</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sorted_unadded_literals_def</span><span> </span><span>undefined_notin</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span>
</span><span>         </span><span>defined_lit_Neg_Pos_iff</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>defined_lit_cons</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>filter_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>undefined_notin</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span>defined_lit_Neg_Pos_iff</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>sorted_unadded_literals_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_unadded_literals_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L. L &#8712; set all_clauses_literals &#10233; defined_lit M (Pos L) = defined_lit M&#39; (Pos L)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sorted_unadded_literals M = sorted_unadded_literals M&#39;&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter (full_unset_literals_in_&#916;&#931;&#39; (M))
                            all_clauses_literals =
                           filter (full_unset_literals_in_&#916;&#931;&#39; M&#39;)
                            all_clauses_literals&#8250;</span></span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter (full_unset_literals_in_&#916;&#931; (M))
                            all_clauses_literals =
                           filter (full_unset_literals_in_&#916;&#931; M&#39;)
                            all_clauses_literals&#8250;</span></span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter (half_unset_literals_in_&#916;&#931; (M))
                            all_clauses_literals =
                           filter (half_unset_literals_in_&#916;&#931; M&#39;)
                            all_clauses_literals&#8250;</span></span></span><span>
</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter (unset_literals_in_&#931; (M)) all_clauses_literals =
       filter (unset_literals_in_&#931; M&#39;) all_clauses_literals&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_unset_literals_in_&#916;&#931;&#39;_def</span><span>  </span><span>full_unset_literals_in_&#916;&#931;_def</span><span>
</span><span>     </span><span>half_unset_literals_in_&#916;&#931;_def</span><span> </span><span>unset_literals_in_&#931;_def</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sorted_unadded_literals_def</span><span> </span><span>undefined_notin</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span>
</span><span>         </span><span>defined_lit_Neg_Pos_iff</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>defined_lit_cons</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ext</span><span> </span><span>filter_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>undefined_notin</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span>defined_lit_Neg_Pos_iff</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>sorted_unadded_literals_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_unadded_literals_Cons_already_set</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit M (lit_of K)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;sorted_unadded_literals (K # M) = sorted_unadded_literals M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sorted_unadded_literals_cong</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: defined_lit_cons&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_sorted_unadded_literals</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct (sorted_unadded_literals M)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>half_unset_literals_in_&#916;&#931;_def</span><span>
</span><span>      </span><span>full_unset_literals_in_&#916;&#931;_def</span><span> </span><span>unset_literals_in_&#931;_def</span><span>
</span><span>      </span><span>sorted_unadded_literals_def</span><span>
</span><span>      </span><span>full_unset_literals_in_&#916;&#931;&#39;_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sorted_unadded_literals_def</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Collect_req_remove1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{a &#8712; A. a &#8800; b &#8743; P a} = (if P b then Set.remove b {a &#8712; A. P a} else {a &#8712; A. P a})&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>Collect_req_remove2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{a &#8712; A. b &#8800; a &#8743; P a} = (if P b then Set.remove b {a &#8712; A. P a} else {a &#8712; A. P a})&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_remove</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card (Set.remove a A) = (if a &#8712; A then card A - 1 else card A)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Set.remove_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Diff_empty</span><span> </span><span>One_nat_def</span><span> </span><span>card_Diff_insert</span><span> </span><span>card_infinite</span><span> </span><span>empty_iff</span><span>
</span><span>    </span><span>finite_Diff_insert</span><span> </span><span>gr_implies_not0</span><span> </span><span>neq0_conv</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_unadded_literals_cons_in_undef</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M (lit_of K) &#10233;
             atm_of (lit_of K) &#8712; set all_clauses_literals &#10233;
             Suc (length (sorted_unadded_literals (K # M))) =
             length (sorted_unadded_literals M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>distinct_card</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Set.filter_def</span><span> </span><span>Collect_req_remove2</span><span>
</span><span>    </span><span>card_remove</span><span> </span><span>isabelle_should_do_that_automatically</span><span>
</span><span>    </span><span>card_gt_0_iff</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>less_eq_Suc_le</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_dup_complete_trail</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (complete_trail M) &#10231; no_dup M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>complete_trail_def</span><span> </span><span>no_dup_def</span><span> </span><span>comp_def</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span>undefined_notin</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tautology_complete_trail</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tautology (lit_of `# mset (complete_trail M)) &#10231; tautology (lit_of `# mset M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>complete_trail_def</span><span> </span><span>tautology_decomp&#39;</span><span> </span><span>comp_def</span><span> </span><span>all_clauses_literals</span><span>
</span><span>          </span><span>undefined_notin</span><span> </span><span>uminus_lit_swap</span><span> </span><span>defined_lit_Neg_Pos_iff</span><span>
</span><span>       </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>defined_lit_Neg_Pos_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atms_of_complete_trail</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of (lit_of `# mset (complete_trail M)) =
     atms_of (lit_of `# mset M) &#8746; (&#931; - &#916;&#931;) &#8746; replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>complete_trail_def</span><span> </span><span>all_clauses_literals</span><span>
</span><span>    </span><span>image_image</span><span> </span><span>image_Un</span><span> </span><span>atms_of_def</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>depth_lit_of</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v,_) ann_lit &#8658; (&#39;v, _) ann_lit search_depth&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;depth_lit_of (Decided L) = SD_TWO (Decided L)&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;depth_lit_of (Propagated L C) = SD_ZERO (Propagated L C)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>depth_lit_of_additional_fst</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v,_) ann_lit &#8658; (&#39;v, _) ann_lit search_depth&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;depth_lit_of_additional_fst (Decided L) = SD_ONE (Decided L)&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;depth_lit_of_additional_fst (Propagated L C) = SD_ZERO (Propagated L C)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>depth_lit_of_additional_snd</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v,_) ann_lit &#8658; (&#39;v, _) ann_lit search_depth list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;depth_lit_of_additional_snd (Decided L) = [SD_ONE (Decided L)]&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;depth_lit_of_additional_snd (Propagated L C) = []&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  This function is suprisingly complicated to get right. Remember that the last set element
  is at the beginning of the list

&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>remove_dup_information_raw</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, _) ann_lits &#8658; (&#39;v, _) ann_lit search_depth list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_dup_information_raw [] = []&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_dup_information_raw (L # M) =
     (if atm_of (lit_of L) &#8712; &#931; - &#916;&#931; then depth_lit_of L # remove_dup_information_raw M
     else if defined_lit (M) (Pos (opposite_var (atm_of (lit_of L))))
     then if Decided (Pos (opposite_var (atm_of (lit_of L)))) &#8712; set (M)
       then remove_dup_information_raw M
       else depth_lit_of_additional_fst L # remove_dup_information_raw M
     else depth_lit_of_additional_snd L @ remove_dup_information_raw M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>remove_dup_information</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_dup_information xs = un_hide_sd (remove_dup_information_raw xs)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;the_search_depth (depth_lit_of L) = L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_complete_trail</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (complete_trail []) = length all_clauses_literals&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>complete_trail_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sum_length_filter_compl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_count_list_if</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct xs &#10233; count_list xs x = (if x &#8712; set xs then 1 else 0)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_complete_trail_Cons</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (K # M) &#10233;
    length (complete_trail (K # M)) =
      (if atm_of (lit_of K) &#8712; set all_clauses_literals then 0 else 1) + length (complete_trail M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>complete_trail_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_complete_trail_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M &#10233; atm_of ` (lits_of_l M) &#8838; set all_clauses_literals &#10233;
  length (complete_trail M) = length all_clauses_literals&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>ann_lit_list_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>length_complete_trail_Cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_set_all_clauses_literals_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of L &#8712; &#931; - &#916;&#931; &#10233; atm_of L &#8712; set all_clauses_literals&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712; &#916;&#931; &#10233; replacement_pos K &#8712; set all_clauses_literals&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8712; &#916;&#931; &#10233; replacement_neg K &#8712; set all_clauses_literals&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_clauses_literals</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_dup_information [] = []&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_dup_information_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atm_of_remove_dup_information</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of ` (lits_of_l M) &#8838; set all_clauses_literals &#10233;
    atm_of ` (lits_of_l (remove_dup_information M)) &#8838; set all_clauses_literals&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_dup_information_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>ann_lit_list_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span>lits_of_def</span><span> </span><span>image_image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>remove_dup_information_raw2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, _) ann_lits &#8658; (&#39;v, _) ann_lits &#8658;
    (&#39;v, _) ann_lit search_depth list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_dup_information_raw2 M&#39; [] = []&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_dup_information_raw2 M&#39; (L # M) =
     (if atm_of (lit_of L) &#8712; &#931; - &#916;&#931; then depth_lit_of L # remove_dup_information_raw2 M&#39; M
     else if defined_lit (M @ M&#39;) (Pos (opposite_var (atm_of (lit_of L))))
     then if Decided (Pos (opposite_var (atm_of (lit_of L)))) &#8712; set (M @ M&#39;)
       then remove_dup_information_raw2 M&#39; M
       else depth_lit_of_additional_fst L # remove_dup_information_raw2 M&#39; M
     else depth_lit_of_additional_snd L @ remove_dup_information_raw2 M&#39; M)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_dup_information_raw2_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_dup_information_raw2 [] M = remove_dup_information_raw M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This can be useful as simp, but I am not certain (yet), because the RHS does not look simpler
 than the LHS.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_dup_information_raw_cons</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_dup_information_raw (L # M2) =
    remove_dup_information_raw2 M2 [L] @
    remove_dup_information_raw M2&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_dup_information_raw_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_dup_information_raw (M1 @ M2) =
    remove_dup_information_raw2 M2 M1 @
    remove_dup_information_raw M2&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_dup_information_raw_append2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;remove_dup_information_raw2 M (M1 @ M2) =
    remove_dup_information_raw2 (M @ M2) M1 @
    remove_dup_information_raw2 M M2&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_dup_information_subset</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset (remove_dup_information M) &#8838;# mset M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>remove_dup_information_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>ann_lit_list_induct</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mset_remove_trivial</span><span> </span><span>diff_subset_eq_self</span><span> </span><span>subset_mset.dual_order.trans</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*TODO Move*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_dup_subsetD</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M &#10233; mset M&#39; &#8838;# mset M &#10233; no_dup M&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_dup_def</span><span> </span><span>distinct_mset_mset_distinct</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>mset_map</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>image_mset_subseteq_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of o lit_of&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>distinct_mset_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_dup_remove_dup_information</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M &#10233; no_dup (remove_dup_information M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_dup_subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>remove_dup_information_subset</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atm_of_complete_trail</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of ` (lits_of_l M) &#8838; set all_clauses_literals &#10233;
   atm_of ` (lits_of_l (complete_trail M)) = set all_clauses_literals&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>complete_trail_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>image_image</span><span> </span><span>image_Un</span><span> </span><span>defined_lit_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>remove_dup_information_raw.simps</span><span>
</span><span>  </span><span>remove_dup_information_raw2.simps</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>remove_dup_information_raw_append</span><span>
</span><span>  </span><span>remove_dup_information_raw_cons</span><span>
</span><span>  </span><span>remove_dup_information_raw_append2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>truncate_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, _) ann_lits &#8658; _&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;truncate_trail M &#8801;
    (snd (backtrack_split M))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>ocdcl_score</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, _) ann_lits &#8658; _&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ocdcl_score M =
  rev (map nat_of_search_deph (remove_dup_information_raw (complete_trail (truncate_trail M))))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>enc_weight_opt</span><span class="delimiter">:</span><span> </span><span>conflict_driven_clause_learning<span class="hidden">&#8681;</span><sub>W</sub>_optimal_weight</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>state_eq</span><span> </span><span class="delimiter">=</span><span> </span><span>state_eq</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span>state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>trail</span><span> </span><span class="delimiter">=</span><span> </span><span>trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>init_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>init_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>learned_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>learned_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>cons_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>cons_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>tl_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>tl_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>add_learned_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>add_learned_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>remove_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>remove_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>update_conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>update_conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>init_state</span><span> </span><span class="delimiter">=</span><span> </span><span>init_state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>&#961;</span><span> </span><span class="delimiter">=</span><span> </span><span>&#961;<span class="hidden">&#8681;</span><sub>e</sub></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>update_additional_info</span><span> </span><span class="delimiter">=</span><span> </span><span>update_additional_info</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>&#961;<span class="hidden">&#8681;</span><sub>e</sub>_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>update_additional_info</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_init_state</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(a, b) &#8712; lexn less_than n &#10233; (b, c) &#8712; lexn less_than n &#8744; b = c &#10233; (a, c) &#8712; lexn less_than n&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(a, b) &#8712; lexn less_than n &#10233; (b, c) &#8712; lexn less_than n &#8744; b = c &#10233; (a, c) &#8712; lexn less_than n&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>lexn_transI</span><span> </span><span>trans_def</span><span> </span><span>trans_less_than</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>truncate_trail_Prop</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;truncate_trail (Propagated L E # S) = truncate_trail (S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>truncate_trail_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ocdcl_score_Prop</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ocdcl_score (Propagated L E # S) = ocdcl_score (S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ocdcl_score_def</span><span> </span><span>truncate_trail_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_dup_information_raw2_undefined_&#931;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct xs &#10233;
  (&#8896;L. L &#8712; set xs &#10233; undefined_lit M (Pos L) &#10233; L &#8712; &#931; &#10233; undefined_lit MM (Pos L)) &#10233;
  remove_dup_information_raw2 MM
     (map (Decided &#8728; Pos)
       (filter (unset_literals_in_&#931; M)
                 xs)) =
  map (SD_TWO o Decided &#8728; Pos)
       (filter (unset_literals_in_&#931; M)
                 xs)&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_dup_information_raw2.simps</span><span>
</span><span>       </span><span>unset_literals_in_&#931;_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>defined_lit_map_Decided_pos</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;defined_lit (map (Decided &#8728; Pos) M) L &#10231; atm_of L &#8712; set M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_dup_information_raw2_full_undefined_&#931;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct xs &#10233; set xs &#8838; set all_clauses_literals &#10233;
  (&#8896;L. L &#8712; set xs &#10233; undefined_lit M (Pos L) &#10233; L &#8713; &#931; - &#916;&#931; &#10233;
    undefined_lit M (Pos (opposite_var L)) &#10233; L &#8712; replacement_pos ` &#916;&#931; &#10233;
    undefined_lit MM (Pos (opposite_var L))) &#10233;
  remove_dup_information_raw2 MM
     (map (Decided &#8728; Pos)
       (filter (full_unset_literals_in_&#916;&#931; M)
                 xs)) =
  map (SD_ONE o Decided &#8728; Pos)
       (filter (full_unset_literals_in_&#916;&#931; M)
                 xs)&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>all_clauses_literals</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remove_dup_information_raw2.simps</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>xs</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span class="delimiter">(</span><span>1</span><span>-</span><span>3</span><span class="delimiter">)</span><span> </span><span>p</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span class="delimiter">]</span><span> </span><span>p</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remove_dup_information_raw2.simps</span><span>
</span><span>       </span><span>defined_lit_map_Decided_pos</span><span>
</span><span>       </span><span>full_unset_literals_in_&#916;&#931;_def</span><span> </span><span>defined_lit_append</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>full_unset_literals_in_&#916;&#931;_notin</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712; &#931; &#10233; full_unset_literals_in_&#916;&#931; M La &#10231; False&#8250;</span></span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;La &#8712; &#931; &#10233; full_unset_literals_in_&#916;&#931;&#39; M La &#10231; False&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>full_unset_literals_in_&#916;&#931;_def</span><span>
</span><span>    </span><span>image_iff</span><span> </span><span>new_vars_pos</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>full_unset_literals_in_&#916;&#931;&#39;_def</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Decided_in_definedD</span><span class="delimiter">:</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided K &#8712; set M &#10233; defined_lit M K&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>defined_lit_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>full_unset_literals_in_&#916;&#931;&#39;_full_unset_literals_in_&#916;&#931;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; replacement_pos ` &#916;&#931; &#8746; replacement_neg ` &#916;&#931; &#10233;
    full_unset_literals_in_&#916;&#931;&#39; M (opposite_var L) &#10231; full_unset_literals_in_&#916;&#931; M L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>full_unset_literals_in_&#916;&#931;&#39;_def</span><span> </span><span>full_unset_literals_in_&#916;&#931;_def</span><span>
</span><span>    </span><span>opposite_var_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_dup_information_raw2_full_unset_literals_in_&#916;&#931;&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8896;L. L &#8712; set (filter (full_unset_literals_in_&#916;&#931;&#39; M) xs) &#10233; Decided (Pos (opposite_var L)) &#8712; set M&#39;) &#10233;
  set xs &#8838; set all_clauses_literals &#10233;
  (remove_dup_information_raw2
       M&#39;
       (map (Decided &#8728; Pos)
         (filter (full_unset_literals_in_&#916;&#931;&#39; (M))
           xs))) = []&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>goals_limit</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>remove_dup_information_raw2.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>xs</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>remove_dup_information_raw2.simps</span><span>
</span><span>        </span><span>full_unset_literals_in_&#916;&#931;&#39;_full_unset_literals_in_&#916;&#931;</span><span>
</span><span>        </span><span>all_clauses_literals</span><span>
</span><span>        </span><span>defined_lit_map_Decided_pos</span><span> </span><span>defined_lit_append</span><span> </span><span>image_iff</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Decided_in_definedD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>M</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, _) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, _) ann_lit&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n1 &#8801; map nat_of_search_deph (remove_dup_information_raw (complete_trail (L # M)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n2 &#8801; map nat_of_search_deph (remove_dup_information_raw (complete_trail M))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>lits</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atm_of ` (lits_of_l (L # M)) &#8838; set all_clauses_literals&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>undef</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M (lit_of L)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(rev n1, rev n2) &#8712; lexn less_than n &#8744; n1 = n2&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lits</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>n1_def</span><span> </span><span>n2_def</span><span> </span><span>complete_trail_def</span><span> </span><span>prepend_same_lexn</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sorted_unadded_literals_def</span><span>
</span><span>      </span><span>remove_dup_information_raw2.simps</span><span>  </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>defined_lit_map_Decided_pos</span><span>
</span><span>         </span><span>remove_dup_information_raw2_undefined_&#931;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>remove_dup_information_raw2_undefined_&#931;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>defined_lit_map_Decided_pos</span><span>
</span><span>         </span><span>remove_dup_information_raw2_undefined_&#931;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>remove_dup_information_raw2_full_undefined_&#931;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>all_clauses_literals</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>remove_dup_information_raw2_full_unset_literals_in_&#916;&#931;&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>full_unset_literals_in_&#916;&#931;&#39;_full_unset_literals_in_&#916;&#931;</span><span class="delimiter">)</span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8801; card &#931;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss S = penc N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.cdcl_bnb_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(ocdcl_score (trail T), ocdcl_score (trail S)) &#8712; lexn less_than n &#8744;
     ocdcl_score (trail T) = ocdcl_score (trail S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_bnb_conflict</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_bnb_propagate</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_bnb_improve</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>enc_weight_opt.improveE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_bnb_conflict_opt</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>enc_weight_opt.conflict_optE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_bnb_other&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>bj</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>skip</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>resolve</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>backtrack</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, &#39;v clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>D</span><span> </span><span>D&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>	</span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S = Some (add_mset L D)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided K # M1, M2) &#8712; set (get_all_ann_decomposition (trail S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (trail S) (add_mset L D&#39;) = local.backtrack_lvl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) L = local.backtrack_lvl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>lev_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) K = Suc (get_maximum_level (trail S) D&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>D&#39;_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; &#8838;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (clauses S) &#8746; set_mset (enc_weight_opt.conflicting_clss S) &#8872;p
	 add_mset L D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764;
	   cons_trail (Propagated L (add_mset L D&#39;))
	    (reduce_trail_to M1
	      (add_learned_cls (add_mset L D&#39;) (update_conflicting None S)))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>enc_weight_opt.obacktrack.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>tr_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot (add_mset L D)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (add_mset L D)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail S)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span>confl</span><span>
</span><span>	</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>	  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span>
</span><span>	  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span>
</span><span>	  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tr_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot (add_mset L D&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D&#39;_D</span><span> </span><span>tr_D</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot D&#39; &#10233; trail S &#8872;as CNot (normalize2 D&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (trail S) D&#39; &lt; backtrack_lvl S&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>D&#39;</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by induction on all the literals*)</span></span></span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma remove_dup_information_subset: &#8249;mset (remove_dup_information M) &#8838;# mset M&#8250;
  unfolding remove_dup_information_def
  apply (induction M rule: ann_lit_list_induct) apply auto
  apply (metis add_mset_remove_trivial diff_subset_eq_self subset_mset.dual_order.trans)+
  done

(*TODO Move*)
lemma no_dup_subsetD: &#8249;no_dup M &#10233; mset M&#39; &#8838;# mset M &#10233; no_dup M&#39;&#8250;
  unfolding no_dup_def distinct_mset_mset_distinct[symmetric] mset_map
  apply (drule image_mset_subseteq_mono[of _ _ &#8249;atm_of o lit_of&#8250;])
  apply (drule distinct_mset_mono)
  apply auto
  done

lemma no_dup_remove_dup_information:
  &#8249;no_dup M &#10233; no_dup (remove_dup_information M)&#8250;
  using no_dup_subsetD[OF _ remove_dup_information_subset] by blast

lemma atm_of_complete_trail:
  &#8249;atm_of ` (lits_of_l M) &#8838; set all_clauses_literals &#10233;
   atm_of ` (lits_of_l (complete_trail M)) = set all_clauses_literals&#8250;
  unfolding complete_trail_def by (auto simp: lits_of_def image_image image_Un defined_lit_map)

definition ocdcl_trail_inv where
  &#8249;ocdcl_trail_inv M &#10231; no_dup M &#8743;
    atm_of ` (lits_of_l M) &#8838; &#931; &#8746; replacement_pos ` &#916;&#931; &#8746; replacement_neg ` &#916;&#931; &#8743;
    (&#8704;P. P &#8712; replacement_pos ` &#916;&#931; &#8746; replacement_neg ` &#916;&#931; &#10230;
       Decided (Neg P) &#8713; set M) &#8743;
    (&#8704;P. P &#8712; replacement_pos ` &#916;&#931; &#8746; replacement_neg ` &#916;&#931; &#10230;
       Decided (Pos P) &#8712; set M &#10230; Decided (Pos (opposite_var P)) &#8713; set M)&#8250;


lemma ocdcl_trail_inv_tlD:
  &#8249;ocdcl_trail_inv (L # M) &#10233; ocdcl_trail_inv M&#8250;
  by (auto simp: ocdcl_trail_inv_def)

lemma ocdcl_trail_inv_Cons1[simp]:
  &#8249;atm_of (lit_of L) &#8712; &#931; &#10233; ocdcl_trail_inv (L # M) &#10231; undefined_lit M (lit_of L) &#8743; ocdcl_trail_inv M&#8250;
  by (auto simp: ocdcl_trail_inv_def)

lemma ocdcl_trail_inv_Cons2:
  &#8249;atm_of (lit_of L) &#8712; replacement_pos ` &#916;&#931; &#8746; replacement_neg ` &#916;&#931;  &#10233;
  ocdcl_trail_inv (L # M) &#10233;
    undefined_lit M (lit_of L) &#8743; (is_decided L &#10230; is_pos (lit_of L) &#8743; Decided (Pos (opposite_var (atm_of (lit_of L)))) &#8713; set M) &#8743; ocdcl_trail_inv M&#8250;
  by (cases L; cases &#8249;lit_of L&#8250;; auto simp: ocdcl_trail_inv_def)

lemma ocdcl_trail_inv_ConsE:
  &#8249;ocdcl_trail_inv (L # M) &#10233; atm_of (lit_of L) &#8712; &#931; &#8746; replacement_pos ` &#916;&#931; &#8746; replacement_neg ` &#916;&#931; &#10233;
    (atm_of (lit_of L) &#8712; replacement_pos ` &#916;&#931; &#8746; replacement_neg ` &#916;&#931;  &#10233;
       undefined_lit M (lit_of L) &#10233;
       (is_decided L &#10230; is_pos (lit_of L) &#8743;
          Decided (Pos (opposite_var (atm_of (lit_of L)))) &#8713; set M) &#10233;
       ocdcl_trail_inv M &#10233; P) &#10233;
    (atm_of (lit_of L) &#8712; &#931; &#10233; undefined_lit M (lit_of L) &#10233;
       ocdcl_trail_inv M &#10233; P)
    &#10233; P&#8250;
  using ocdcl_trail_inv_Cons2 ocdcl_trail_inv_Cons1 by blast

lemma
  &#8249;P &#8712; replacement_pos ` &#916;&#931; &#8746; replacement_neg ` &#916;&#931; &#10233; ocdcl_trail_inv M &#10233;
  defined_lit (remove_dup_information M) (Pos P) &#10233;
    undefined_lit (remove_dup_information M) (Pos (opposite_var P))&#8250;
  unfolding remove_dup_information_def
  apply (induction M arbitrary: P rule: ann_lit_list_induct)
  apply (auto simp: defined_lit_cons split:
     dest: elim!: )
thm TrueI
subgoal
apply (auto elim!: ocdcl_trail_inv_ConsE)
  sorry
lemma atm_of_complete_trail_remove_dup_information:
  &#8249;no_dup M &#10233; atm_of ` (lits_of_l M) &#8838; set all_clauses_literals &#10233;
  atm_of ` (lits_of_l (complete_trail (remove_dup_information M))) = set all_clauses_literals&#8250;
  by (simp_all add: atm_of_complete_trail atm_of_remove_dup_information)

text &#8249;TODO:
  &#9642; complete_trail is doing the wrong thing (or it should be done before
    @{term &#8249;remove_dup_information&#8250;}).
  &#9642; is the measure really the simplest thing we can do?
&#8250;


fun ocdcl_score_rev :: &#8249;(&#39;v, _) ann_lits &#8658; nat list&#8250; where
  &#8249;ocdcl_score_rev  [] = []&#8250; |
  &#8249;ocdcl_score_rev (Propagated K C # M) =
     (if defined_lit M (Pos (opposite_var (atm_of K)))
         then 1 else 0) #
     ocdcl_score_rev M&#8250; |
  &#8249;ocdcl_score_rev (Decided K # M) =
     (if atm_of K &#8712; &#931; - &#916;&#931; then 1
     else if defined_lit M (Pos (opposite_var (atm_of K)))
         then 2 else 1) #  ocdcl_score_rev M&#8250;


definition ocdcl_mu where
  &#8249;ocdcl_mu M = rev (ocdcl_score_rev (complete_trail M))&#8250;

lemma ocdcl_score_rev_in_0_3:
  &#8249;x &#8712; set (ocdcl_score_rev M) &#10233; x &#8712; {0..&lt;3}&#8250;
  by (induction M rule: ann_lit_list_induct) auto

lemma &#8249;no_dup M &#10233; length (ocdcl_score_rev M) &#8804; length M&#8250;

fun ocdcl_score_rev :: &#8249;(&#39;v, &#39;b) ann_lits &#8658; (&#39;v, &#39;b) ann_lits &#8658; nat&#8250; where
  &#8249;ocdcl_score_rev _ [] = 0&#8250; |
  &#8249;ocdcl_score_rev M&#39; (Propagated K C # M) = ocdcl_score_rev (M&#39; @ [Propagated K C]) M&#8250; |
  &#8249;ocdcl_score_rev M&#39; (Decided K # M) = ocdcl_score_rev (M&#39; @ [Decided K]) M +
     (if atm_of K &#8712; &#931; - &#916;&#931; then 1
     else if Decided (base_atm (atm_of K)) &#8712; set (map (map_annotated_lit (base_atm o atm_of) id id) M&#39;)
         then 2 else 1) * 3^card (base_atm ` atms_of (lit_of `# mset M))&#8250;

abbreviation ocdcl_score:: &#8249;(&#39;v, &#39;b) ann_lits &#8658; (&#39;v, &#39;b) ann_lits &#8658; nat&#8250; where
  &#8249;ocdcl_score M M&#39; &#8801; ocdcl_score_rev M (rev M&#39;)&#8250;

lemma ocdcl_score_rev_induct_internal:
  fixes xs ys :: &#8249;(&#39;v, &#39;b) ann_lits&#8250;
  assumes
    &#8249;ys @ xs = M0&#8250;
    &#8249;P M0 []&#8250;
    &#8249;&#8896;L C M M&#39;. M0 = M&#39; @ Propagated L C # M  &#10233; P (M&#39; @ [Propagated L C]) M &#10233; P M&#39; (Propagated L C # M)&#8250;
    &#8249;&#8896;L M M&#39;. M0 = M&#39; @ Decided L # M&#10233; P (M&#39; @ [Decided L]) M &#10233; P M&#39; (Decided L # M)&#8250;
  shows &#8249;P ys xs &#8743; ys @ xs = M0&#8250;
  using assms(1)
  apply (induction ys xs rule: ocdcl_score_rev.induct)
  subgoal using assms(1,2) by auto
  subgoal for M L C M&#39;
    using assms(3) by auto
  subgoal for M L M&#39;
    using assms(4) by auto
  done

lemma ocdcl_score_rev_induct2:
  fixes xs ys :: &#8249;(&#39;v, &#39;b) ann_lits&#8250;
  assumes
    &#8249;P (ys @ xs) []&#8250;
    &#8249;&#8896;L C M M&#39;. ys @ xs = M&#39; @ Propagated L C # M  &#10233; P (M&#39; @ [Propagated L C]) M &#10233; P M&#39; (Propagated L C # M)&#8250;
    &#8249;&#8896;L M M&#39;. ys @ xs = M&#39; @ Decided L # M &#10233; P (M&#39; @ [Decided L]) M &#10233; P M&#39; (Decided L # M) &#8250;
  shows &#8249;P ys xs&#8250;
  using ocdcl_score_rev_induct_internal[of ys xs &#8249;ys @ xs&#8250; P] assms by auto

lemma ocdcl_score_rev_induct:
  fixes xs ys :: &#8249;(&#39;v, &#39;b) ann_lits&#8250;
  assumes
    &#8249;P xs []&#8250;
    &#8249;&#8896;L C M M&#39;. xs = M&#39; @ Propagated L C # M  &#10233; P (M&#39; @ [Propagated L C]) M &#10233; P M&#39; (Propagated L C # M)&#8250;
    &#8249;&#8896;L M M&#39;. xs = M&#39; @ Decided L # M &#10233; P (M&#39; @ [Decided L]) M &#10233; P M&#39; (Decided L # M) &#8250;
  shows &#8249;P [] xs&#8250;
  using ocdcl_score_rev_induct_internal[of &#8249;[]&#8250; xs xs P] assms by auto

lemma Decided_map_annotated_lit_iff[simp]:
  &#8249;Decided L = map_annotated_lit f g h x &#10231; (&#8707;x&#39;. x = Decided x&#39; &#8743; L = f x&#39;)&#8250;
  by (cases x) auto

lemma
  &#8249;atm_of ` (lits_of_l (M&#39; @ M)) &#8838; &#931; &#10233; no_dup (M&#39; @ M) &#10233;
     ocdcl_score_rev M&#39; M &#8804; 3 ^ (card ((base_atm o atm_of) ` lits_of_l M))&#8250;
  apply (induction M&#39; M rule: ocdcl_score_rev_induct2)
  subgoal by auto
  subgoal for L M&#39; M
    by (cases &#8249;atm_of L &#8712; &#931;&#8250;) (auto simp: card_insert_if)
  subgoal for L Ma M&#39;a
    using &#916;&#931;_&#931;
    apply (auto simp: card_insert_if atm_of_eq_atm_of lits_of_def image_image
      atms_of_def image_Un dest!: split_list[of _ M&#39;a])
  oops
*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>enc_weight_opt</span><span class="delimiter">:</span><span> </span><span>conflict_driven_clause_learning<span class="hidden">&#8681;</span><sub>W</sub>_optimal_weight</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>state_eq</span><span> </span><span class="delimiter">=</span><span> </span><span>state_eq</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span>state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>trail</span><span> </span><span class="delimiter">=</span><span> </span><span>trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>init_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>init_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>learned_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>learned_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>cons_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>cons_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>tl_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>tl_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>add_learned_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>add_learned_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>remove_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>remove_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>update_conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>update_conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>init_state</span><span> </span><span class="delimiter">=</span><span> </span><span>init_state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>&#961;</span><span> </span><span class="delimiter">=</span><span> </span><span>&#961;<span class="hidden">&#8681;</span><sub>e</sub></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>update_additional_info</span><span> </span><span class="delimiter">=</span><span> </span><span>update_additional_info</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>&#961;<span class="hidden">&#8681;</span><sub>e</sub>_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>update_additional_info</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weight_init_state</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>simple_backtrack_conflict_opt</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;simple_backtrack_conflict_opt S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_split (trail S) = (M2, Decided K # M1)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_ann_lits (trail S) &#8712;# enc_weight_opt.conflicting_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; cons_trail (Propagated (-K) (DECO_clause (trail S)))
      (add_learned_cls (DECO_clause (trail S)) (reduce_trail_to M1 S))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>simple_backtrack_conflict_optE</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;simple_backtrack_conflict_opt S T&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>simple_backtrack_conflict_opt_conflict_analysis</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;simple_backtrack_conflict_opt S U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;T T&#39;. enc_weight_opt.conflict_opt S T &#8743; resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T T&#39;
    &#8743; enc_weight_opt.obacktrack T&#39; U&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>simple_backtrack_conflict_opt.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>M2</span><span> </span><span>K</span><span> </span><span>M1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S = M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>backtrack_split_list_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_conflicting (Some (negate_ann_lits (trail S))) S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.conflict_opt S ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>enc_weight_opt.conflict_opt.intros</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;n. update_conflicting
    (Some (negate_ann_lits (drop n (trail S))))
    (reduce_trail_to (drop n (trail S)) S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>proped_M2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_proped (M2 ! n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &lt; length M2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>nth_length_takeWhile</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Not &#8728; is_decided&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>length_takeWhile_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Not &#8728; is_decided&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>backtrack_split_takeWhile_dropWhile</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>annotated_lit.exhaust_disc</span><span> </span><span>comp_apply</span><span> </span><span>nth_mem</span><span> </span><span>set_takeWhileD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>is_dec_M2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;filter_mset is_decided (mset M2) = {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>nth_length_takeWhile</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Not &#8728; is_decided&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>length_takeWhile_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Not &#8728; is_decided&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>backtrack_split_takeWhile_dropWhile</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_mset_empty_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>annotated_lit.exhaust_disc</span><span> </span><span>comp_apply</span><span> </span><span>nth_mem</span><span> </span><span>set_takeWhileD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting (enc_weight_opt.abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state (enc_weight_opt.abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>decomp_imp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_decomposition_implies_m (clauses S + (enc_weight_opt.conflicting_clss S))
      (get_all_ann_decomposition (trail S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause (enc_weight_opt.abs_state S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;K &#8800; lit_of (M2 ! n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &lt; length M2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>defined_lit_nth</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d_n</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (drop n M2 @ Decided K # M1)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>append_take_drop_id</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>append_take_drop_id</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_appendD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mark_dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (mark_of (M2!n))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &lt; length M2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>that</span><span> </span><span>proped_M2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span>nth_mem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span> </span><span>tr</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2!n&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit (drop n M2) K&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>defined_lit_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop n M2&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>set_drop_subset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M2 K&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (drop n M2) = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>count_decided_0_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>nth_length_takeWhile</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Not &#8728; is_decided&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>length_takeWhile_le</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Not &#8728; is_decided&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>backtrack_split_takeWhile_dropWhile</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>in_set_dropD</span><span> </span><span>set_takeWhileD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M2 = 0&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>proped</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L mark a b.
      a @ Propagated L mark # b = trail S &#10230;
      b &#8872;as CNot (remove1_mset L mark) &#8743; L &#8712;# mark&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mark</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (Suc n) M2 @ Decided K # M1 &#8872;as
      CNot (mark_of (M2 ! n) - unmark (M2 ! n)) &#8743;
      lit_of (M2 ! n) &#8712;# mark_of (M2 ! n)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &lt; length M2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>proped_M2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span>that</span><span>
</span><span>      </span><span>append_take_drop_id</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>M2</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span>proped</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;take n M2&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of (M2 ! n)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mark_of (M2 ! n)&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (Suc n) M2 @ Decided K # M1&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2!n&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.conflict_opt S ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>enc_weight_opt.conflict_opt.intros</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>res</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> ?S (?T n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8804; length M2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>get_all_ann_decomposition_backtrack_split</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span>1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_all_ann_decomposition (trail S)&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; Suc (length M2 - Suc n) &lt; length M2 &#10231; n = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;reduce_trail_to (drop (Suc 0) M2 @ Decided K # M1) S = tl_trail S&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>reduce_trail_to.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;reduce_trail_to (M2 ! 0 # drop (Suc 0) M2 @ Decided K # M1) S = S&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>reduce_trail_to.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Suc (length M1) -
          (length M2 - n + (Suc (length M1) - (n - length M2)))) = 0&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Suc (length M2 + length M1) -
          (length M2 - n + (Suc (length M1) - (n - length M2)))) =n&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M2 - n + (Suc (length M1) - (n - length M2)) = Suc (length M2 + length M1) - n&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2 ! n = Propagated (lit_of (M2 ! n)) (mark_of (M2 ! n))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span>proped_M2</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2 ! n&#8250;</span></span></span><span class="delimiter">)</span><span>  </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span> </span><span>trail_reduce_trail_to_drop</span><span> </span><span>hd_drop_conv_nth</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>resolve.intros</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- lit_of (M2 ! n) &#8712;# negate_ann_lits (drop n M2 @ Decided K # M1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span>in_set_dropI</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;map (uminus o lit_of) M2&#8250;</span></span></span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>negate_ann_lits_def</span><span> </span><span>comp_def</span><span> </span><span>drop_map</span><span>
</span><span>         </span><span>del</span><span class="delimiter">:</span><span> </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (drop n M2 @ Decided K # M1)
       (remove1_mset (- lit_of (M2 ! n)) (negate_ann_lits (drop n M2 @ Decided K # M1))) =
      Suc (count_decided M1)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>count_decided_ge_get_maximum_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop n M2 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(remove1_mset (- lit_of (M2 ! n)) (negate_ann_lits (drop n M2 @ Decided K # M1)))&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>negate_ann_lits_def</span><span> </span><span>tr</span><span> </span><span>max_def</span><span> </span><span>ac_simps</span><span>
</span><span>        </span><span>remove1_mset_add_mset_If</span><span> </span><span>get_maximum_level_add_mset</span><span>
</span><span>       </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of (M2 ! n) &#8712;# mark_of (M2 ! n)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mark</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(remove1_mset (- lit_of (M2 ! n))
         (negate_ann_lits (drop n M2 @ Decided K # M1)) &#8746;#
        (mark_of (M2 ! n) - unmark (M2 ! n))) = negate_ann_lits (drop (Suc n) (trail S))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>distinct_set_mset_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d_n</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>n_d_n</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Suc n&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>no_dup_distinct_mset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_d_n</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>Suc</span><span>
</span><span>        </span><span>mark</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>mark_dist</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>          </span><span>entails_CNot_negate_ann_lits</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_diffD</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>distinct_mset_minus</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(tl_trail
       (reduce_trail_to (drop n M2 @ Decided K # M1) S)) &#8764;
        (reduce_trail_to (drop (Suc n) M2 @ Decided K # M1) S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>n</span><span> </span><span>M2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tl_trail_update_conflicting</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (M2 ! n # drop (Suc n) M2 @ Decided K # M1) &lt; length (trail S)&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tl_trail_reduce_trail_to_cons</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_conflicting
     (Some (negate_ann_lits (drop (Suc n) M2 @ Decided K # M1)))
     (reduce_trail_to (drop (Suc n) M2 @ Decided K # M1) S) &#8764;
    update_conflicting
     (Some (negate_ann_lits (drop (Suc n) M2 @ Decided K # M1)))
     (tl_trail
       (update_conflicting (Some (negate_ann_lits (drop n M2 @ Decided K # M1)))
         (reduce_trail_to (drop n M2 @ Decided K # M1) S)))&#8250;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_conflicting_state_eq</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tl_trail_update_conflicting</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>state_eq_sym</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>state_eq_sym</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>update_conflicting_update_conflicting</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>1</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve (?T n) (?T (n+1))&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>resolve.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of (M2 ! n)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mark_of (M2 ! n)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span>
</span><span>        </span><span>get_all_ann_decomposition_backtrack_split</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>         </span><span>in_get_all_ann_decomposition_trail_update_trail</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided K&#8250;</span></span></span><span> </span><span>M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span> </span><span>trail_reduce_trail_to_drop</span><span> </span><span>hd_drop_conv_nth</span><span>
</span><span>        </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>resolve.intros</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>update_conflicting_state_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (Decided K # M1) (DECO_clause M1) = get_maximum_level M1 (DECO_clause M1)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>get_maximum_level_cong</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>n_d</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: tr get_level_cons_if atm_of_eq_atm_of
      DECO_clause_def Decided_Propagated_in_iff_in_lits_of_l lits_of_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;... = count_decided M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>M1</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>ann_lit_list_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>M1&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;La&#8712;#DECO_clause M1&#39;. get_level (Decided L # M1&#39;) La = get_level M1&#39; La&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_decided_ge_get_maximum_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause M1&#39;&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>get_maximum_level_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause M1&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided L # M1&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1&#39;&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_maximum_level_add_mset</span><span> </span><span>tr</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>        </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>DECO_clause_def</span><span>
</span><span>          </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span>
</span><span>          </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>C</span><span> </span><span>M1&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;La&#8712;#DECO_clause M1&#39;. get_level (Propagated L C # M1&#39;) La = get_level M1&#39; La&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_decided_ge_get_maximum_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause M1&#39;&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>get_maximum_level_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause M1&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Propagated L C # M1&#39;&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1&#39;&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_maximum_level_add_mset</span><span> </span><span>tr</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>        </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>DECO_clause_def</span><span>
</span><span>          </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span>
</span><span>          </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>max</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (Decided K # M1) (DECO_clause M1) = count_decided M1&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot (negate_ann_lits (trail S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>      </span><span>negate_ann_lits_def</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses S + (enc_weight_opt.conflicting_clss S) &#8872;pm DECO_clause (trail S)&#8250;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DECO_clause_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_decomposition_implies_conflict_DECO_clause</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp_imp</span><span class="delimiter">,</span><span>
</span><span>      </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_ann_lits (trail S)&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>neg</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot (mset (map (uminus o lit_of) (trail S)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>      </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses S + enc_weight_opt.conflicting_clss S &#8872;pm DECO_clause (trail S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DECO_clause_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>all_decomposition_implies_conflict_DECO_clause</span><span class="delimiter">[</span><span>OF</span><span> </span><span>decomp_imp</span><span class="delimiter">,</span><span>
</span><span>         </span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset (map (uminus o lit_of) (trail S))&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>neg</span><span> </span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: negate_ann_lits_def&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>deco</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause (M2 @ Decided K # M1) = add_mset (- K) (DECO_clause M1)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>DECO_clause_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eg</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;reduce_trail_to M1 (reduce_trail_to (Decided K # M1) S) &#8764;
    reduce_trail_to M1 S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>reduce_trail_to_compow_tl_trail_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>solves</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: tr&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>reduce_trail_to_compow_tl_trail_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>solves</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: tr&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M2 = []&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reduce_trail_to_compow_tl_trail_le</span><span> </span><span>reduce_trail_to_compow_tl_trail_eq</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cons_trail (Propagated (- K) (DECO_clause (M2 @ Decided K # M1)))
     (add_learned_cls (DECO_clause (M2 @ Decided K # M1))
       (reduce_trail_to M1 S)) &#8764;
    cons_trail (Propagated (- K) (add_mset (- K) (DECO_clause M1)))
     (reduce_trail_to M1
       (add_learned_cls (add_mset (- K) (DECO_clause M1))
         (update_conflicting None
           (update_conflicting (Some (add_mset (- K) (negate_ann_lits M1)))
             (reduce_trail_to (Decided K # M1) S)))))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>deco</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>cons_trail_state_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_sym</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduce_trail_to_add_learned_cls_state_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>solves</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: tr&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>add_learned_cls_state_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_sym</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduce_trail_to_update_conflicting_state_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>solves</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: tr&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_sym</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_conflicting_state_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduce_trail_to_update_conflicting_state_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>solves</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: tr&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_sym</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_conflicting_update_conflicting</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eg</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_sym</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_conflicting_itself</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>1</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bt</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.obacktrack (?T (length M2)) U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>enc_weight_opt.obacktrack.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-K&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_ann_lits M1&#8250;</span></span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[]&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided M1&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_decided_ge_get_maximum_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decided K # M1&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;DECO_clause M1&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span> </span><span>get_maximum_level_add_mset</span><span> </span><span>max_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>DECO_clause_def</span><span> </span><span>negate_ann_lits_def</span><span>
</span><span>      </span><span>image_mset_subseteq_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span> </span><span>DECO_clause_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>U</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span>res</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length M2&#8250;</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>bt</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>conflict_opt0</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflict_opt0 S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (trail S) = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_ann_lits (trail S) &#8712;# enc_weight_opt.conflicting_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764; update_conflicting (Some {#}) (reduce_trail_to ([] :: (&#39;v, &#39;v clause) ann_lits) S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>conflict_opt0E</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflict_opt0 S T&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>cdcl_dpll_bnb_r</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;st</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>cdcl_conflict</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflict S S&#39; &#10233; cdcl_dpll_bnb_r S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>cdcl_propagate</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate S S&#39; &#10233; cdcl_dpll_bnb_r S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>cdcl_improve</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.improvep S S&#39; &#10233; cdcl_dpll_bnb_r S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>cdcl_conflict_opt0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflict_opt0 S S&#39; &#10233; cdcl_dpll_bnb_r S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>cdcl_simple_backtrack_conflict_opt</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;simple_backtrack_conflict_opt S S&#39; &#10233; cdcl_dpll_bnb_r S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>cdcl_o&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r S S&#39; &#10233; cdcl_dpll_bnb_r S S&#39;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>cdcl_dpll_bnb_r_stgy</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;st</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>cdcl_dpll_bnb_r_conflict</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflict S S&#39; &#10233; cdcl_dpll_bnb_r_stgy S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>cdcl_dpll_bnb_r_propagate</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;propagate S S&#39; &#10233; cdcl_dpll_bnb_r_stgy S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>cdcl_dpll_bnb_r_improve</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.improvep S S&#39; &#10233; cdcl_dpll_bnb_r_stgy S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>cdcl_dpll_bnb_r_conflict_opt0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflict_opt0 S S&#39; &#10233; cdcl_dpll_bnb_r_stgy S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>cdcl_dpll_bnb_r_simple_backtrack_conflict_opt</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;simple_backtrack_conflict_opt S S&#39; &#10233; cdcl_dpll_bnb_r_stgy S S&#39;&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>cdcl_dpll_bnb_r_other&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r S S&#39; &#10233; no_confl_prop_impr S &#10233; cdcl_dpll_bnb_r_stgy S S&#39;&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_dup_dropI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup M &#10233; no_dup (drop n M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &lt; length M&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_dup_def</span><span> </span><span>drop_map</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tranclp_resolve_state_eq_compatible</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T &#10233;T &#8764; T&#39; &#10233; resolve<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> S T&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>T&#39;</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tranclp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>resolve_state_eq_compatible</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>resolve_state_eq_compatible</span><span> </span><span>state_eq_ref</span><span> </span><span>tranclp_into_rtranclp</span><span> </span><span>tranclp_unfold_end</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conflict_opt0_state_eq_compatible</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflict_opt0 S T &#10233; S &#8764; S&#39; &#10233; T &#8764; T&#39; &#10233; conflict_opt0 S&#39; T&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_eq_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>T&#39;</span><span> </span><span>T</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_conflicting (Some {#}) (reduce_trail_to ([]::(&#39;v,&#39;v clause) ann_lits) S)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>state_eq_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_conflicting (Some {#}) (reduce_trail_to ([]::(&#39;v,&#39;v clause) ann_lits) S)&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_conflicting (Some {#}) (reduce_trail_to ([]::(&#39;v,&#39;v clause) ann_lits) S&#39;)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>update_conflicting_state_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>S&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Some {#}&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflict_opt0.simps</span><span> </span><span>state_eq_sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reduce_trail_to_state_eq</span><span> </span><span>state_eq_trans</span><span> </span><span>update_conflicting_state_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conflict_opt0_conflict_opt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflict_opt0 S U&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;T. enc_weight_opt.conflict_opt S T &#8743; resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> T U&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (trail S) = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>neg</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_ann_lits (trail S) &#8712;# enc_weight_opt.conflicting_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>U</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;U &#8764; update_conflicting (Some {#}) (reduce_trail_to ([]::(&#39;v,&#39;v clause)ann_lits) S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>conflict_opt0E</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_conflicting (Some (negate_ann_lits (trail S))) S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.conflict_opt S ?T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg</span><span> </span><span>confl</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>enc_weight_opt.conflict_opt.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?T</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#955;n. update_conflicting
    (Some (negate_ann_lits (drop n (trail S))))
    (reduce_trail_to (drop n (trail S)) S)&#8250;</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>proped_M2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_proped (trail S ! n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &lt; length (trail S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>count_decided_0_iff</span><span> </span><span>is_decided_no_proped_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting (enc_weight_opt.abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state (enc_weight_opt.abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>decomp_imp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_decomposition_implies_m (clauses S + (enc_weight_opt.conflicting_clss S))
      (get_all_ann_decomposition (trail S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause (enc_weight_opt.abs_state S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>proped</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;L mark a b.
      a @ Propagated L mark # b = trail S &#10230;
      b &#8872;as CNot (remove1_mset L mark) &#8743; L &#8712;# mark&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;count_decided (drop n (trail S)) = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>count_decided_0_iff</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &lt; length (trail S)&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_set_dropD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (drop n (trail S)) C = 0&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>count_decided_ge_get_maximum_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop n (trail S)&#8250;</span></span></span><span> </span><span>C</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mark_dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (mark_of (trail S!n))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &lt; length (trail S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>that</span><span> </span><span>proped_M2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span>nth_mem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S!n&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>res</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve (?T n) (?T (Suc n))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &lt; length (trail S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L = lit_of (trail S ! n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;E = mark_of (trail S ! n)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;hd (drop n (trail S)) = Propagated L E&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>tr_Sn</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S ! n = Propagated L E&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>proped_M2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S ! n&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>that</span><span> </span><span>hd_drop_conv_nth</span><span> </span><span>L_def</span><span> </span><span>E_def</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# E&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>ent_E</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (Suc n) (trail S) &#8872;as CNot (remove1_mset L E)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>proped</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;take n (trail S)&#8250;</span></span></span><span> </span><span>L</span><span> </span><span>E</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (Suc n) (trail S)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr_Sn</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_ann_lits (drop (Suc n) (trail S)) =
       (remove1_mset (- L) (negate_ann_lits (drop n (trail S))) &#8746;#
        remove1_mset L E)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>distinct_set_mset_eq_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_dup_dropI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>mark_dist</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr_Sn</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>distinct_mset_mono</span><span> </span><span>no_dup_dropI</span><span>
</span><span>         </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>distinct_mset_minus</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent_E</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr_Sn</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>negate_ann_lits_def</span><span> </span><span>that</span><span>
</span><span>           </span><span>Cons_nth_drop_Suc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>L_def</span><span> </span><span>lits_of_def</span><span>
</span><span>           </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span>
</span><span>           </span><span>uminus_lit_swap</span><span>
</span><span>         </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_conflicting (Some (negate_ann_lits (drop (Suc n) (trail S))))
       (reduce_trail_to (drop (Suc n) (trail S)) S) &#8764;
      update_conflicting
       (Some
         (remove1_mset (- L) (negate_ann_lits (drop n (trail S))) &#8746;#
          remove1_mset L E))
       (tl_trail
         (update_conflicting (Some (negate_ann_lits (drop n (trail S))))
           (reduce_trail_to (drop n (trail S)) S)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_sym</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_conflicting_state_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tl_trail_update_conflicting</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_sym</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_conflicting_update_conflicting</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_ref</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>update_conflicting_state_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reduce_trail_to_compow_tl_trail</span><span> </span><span>funpow_swap1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# E&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>proped</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;take n (trail S)&#8250;</span></span></span><span> </span><span>L</span><span> </span><span>E</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;drop (Suc n) (trail S)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tr_Sn</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons_nth_drop_Suc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;- L &#8712;# negate_ann_lits (drop n (trail S))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>negate_ann_lits_def</span><span> </span><span>L_def</span><span>
</span><span>        </span><span>in_set_dropI</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">term</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (drop n (trail S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>resolve.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>L</span><span> </span><span>E</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>use</span><span> </span><span>that</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: trail_reduce_trail_to_drop
         &#8249;hd (drop n (trail S)) = Propagated L E&#8250;&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (?T 0) (?T n)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;n &#8804; length (trail S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (trail S)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (?T 0) (?T (length (trail S)))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?T (length (trail S)) &#8764; U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_eq_sym</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>U</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(?T 0) = (?T (length (trail S)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (trail S) &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>conflicting</span><span class="delimiter">]</span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>negate_ann_lits_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (trail S) &gt; 0 &#10230; resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> (?T 0) U&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tranclp_resolve_state_eq_compatible</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?T 0&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?T (length (trail S))&#8250;</span></span></span><span> </span><span>U</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>rtranclp_unfold</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (trail S) &gt; 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;length (trail S) = 0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>confl</span><span> </span><span>U</span><span>
</span><span>      </span><span>enc_weight_opt.conflict_opt_state_eq_compatible</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(update_conflicting (Some {#}) S)&#8250;</span></span></span><span> </span><span>S</span><span> </span><span>U</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_eq_sym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>backtrack_split_some_is_decided_then_snd_has_hd2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;l&#8712;set M. is_decided l &#10233; &#8707;M&#39; L&#39; M&#39;&#39;. backtrack_split M = (M&#39;&#39;, Decided L&#39; # M&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>backtrack_split_snd_hd_decided</span><span> </span><span>backtrack_split_some_is_decided_then_snd_has_hd</span><span>
</span><span>    </span><span>is_decided_def</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_conflict_opt0_simple_backtrack_conflict_opt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step conflict_opt0 S &#10233; no_step simple_backtrack_conflict_opt S &#10233;
  no_step enc_weight_opt.conflict_opt S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_split_some_is_decided_then_snd_has_hd2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>count_decided_0_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflict_opt0.simps</span><span> </span><span>simple_backtrack_conflict_opt.simps</span><span>
</span><span>    </span><span>enc_weight_opt.conflict_opt.simps</span><span>
</span><span>    </span><span>annotated_lit.is_decided_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_cdcl_dpll_bnb_r_cdcl_bnb_r</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_dpll_bnb_r S &#10231; no_step cdcl_bnb_r S&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A &#10231; ?B&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?A</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?B</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A&#8250;</span></span></span><span> </span><span>no_step_conflict_opt0_simple_backtrack_conflict_opt</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r.simps</span><span>
</span><span>      </span><span>cdcl_dpll_bnb_r.simps</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?B</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?B&#8250;</span></span></span><span> </span><span>simple_backtrack_conflict_opt_conflict_analysis</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r.simps</span><span> </span><span>cdcl_dpll_bnb_r.simps</span><span> </span><span>all_conj_distrib</span><span> </span><span>assms</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>conflict_opt0_conflict_opt</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_dpll_bnb_r_cdcl_bnb_r</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_dpll_bnb_r S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_dpll_bnb_r.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_simple_backtrack_conflict_opt</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S1</span><span> </span><span>S2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.conflict_opt S S1&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S1 S2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.obacktrack S2 T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simple_backtrack_conflict_opt_conflict_analysis</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r S S1&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S1 S2&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r S2 T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>mono_rtranclp</span><span class="delimiter">[</span><span>of</span><span> </span><span>resolve</span><span> </span><span>enc_weight_opt.cdcl_bnb_bj</span><span class="delimiter">]</span><span>
</span><span>      </span><span>mono_rtranclp</span><span class="delimiter">[</span><span>of</span><span> </span><span>enc_weight_opt.cdcl_bnb_bj</span><span> </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r</span><span class="delimiter">]</span><span>
</span><span>      </span><span>mono_rtranclp</span><span class="delimiter">[</span><span>of</span><span> </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r</span><span> </span><span>cdcl_bnb_r</span><span class="delimiter">]</span><span>
</span><span>      </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r.intros</span><span> </span><span>enc_weight_opt.cdcl_bnb_bj.resolve</span><span>
</span><span>      </span><span>cdcl_bnb_r.intros</span><span>
</span><span>      </span><span>enc_weight_opt.cdcl_bnb_bj.intros</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>4</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r.intros</span><span> </span><span>conflict_opt0_conflict_opt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_conflict_opt0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.conflict_opt S S1&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S1 T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conflict_opt0_conflict_opt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r S S1&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S1 T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>mono_rtranclp</span><span class="delimiter">[</span><span>of</span><span> </span><span>resolve</span><span> </span><span>enc_weight_opt.cdcl_bnb_bj</span><span class="delimiter">]</span><span>
</span><span>      </span><span>mono_rtranclp</span><span class="delimiter">[</span><span>of</span><span> </span><span>enc_weight_opt.cdcl_bnb_bj</span><span> </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r</span><span class="delimiter">]</span><span>
</span><span>      </span><span>mono_rtranclp</span><span class="delimiter">[</span><span>of</span><span> </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r</span><span> </span><span>cdcl_bnb_r</span><span class="delimiter">]</span><span>
</span><span>      </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r.intros</span><span> </span><span>enc_weight_opt.cdcl_bnb_bj.resolve</span><span>
</span><span>      </span><span>cdcl_bnb_r.intros</span><span>
</span><span>      </span><span>enc_weight_opt.cdcl_bnb_bj.intros</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>4</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r.intros</span><span> </span><span>conflict_opt0_conflict_opt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>4</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r.intros</span><span> </span><span>conflict_opt0_conflict_opt</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resolve_no_prop_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve S T &#10233; no_step propagate S &#8743; no_step conflict S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_bnb_r_stgy_res</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve S T &#10233; cdcl_bnb_r_stgy S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enc_weight_opt.cdcl_bnb_bj.resolve</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>cdcl_bnb_r_stgy.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>resolve_no_prop_confl</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>4</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r_stgy.intros</span><span> </span><span>conflict_opt0_conflict_opt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_bnb_r_stgy_res</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; cdcl_bnb_r_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_rtranclp</span><span class="delimiter">[</span><span>of</span><span> </span><span>resolve</span><span> </span><span>cdcl_bnb_r_stgy</span><span class="delimiter">]</span><span>
</span><span>    </span><span>cdcl_bnb_r_stgy_res</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obacktrack_no_prop_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.obacktrack S T &#10233; no_step propagate S &#8743; no_step conflict S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span> </span><span>enc_weight_opt.obacktrackE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_bnb_r_stgy_bt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.obacktrack S T &#10233; cdcl_bnb_r_stgy S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enc_weight_opt.cdcl_bnb_bj.backtrack</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>cdcl_bnb_r_stgy.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>obacktrack_no_prop_confl</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>4</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r_stgy.intros</span><span> </span><span>conflict_opt0_conflict_opt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_dpll_bnb_r_stgy_cdcl_bnb_r_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_dpll_bnb_r_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_dpll_bnb_r_stgy.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_dpll_bnb_r_simple_backtrack_conflict_opt</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S1</span><span> </span><span>S2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.conflict_opt S S1&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S1 S2&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.obacktrack S2 T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simple_backtrack_conflict_opt_conflict_analysis</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r_stgy S S1&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S1 S2&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r_stgy S2 T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enc_weight_opt.cdcl_bnb_bj.resolve</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r_stgy.intros</span><span> </span><span>conflict_opt0_conflict_opt</span><span>
</span><span>      </span><span>rtranclp_cdcl_bnb_r_stgy_res</span><span> </span><span>cdcl_bnb_r_stgy_bt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_dpll_bnb_r_conflict_opt0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>S1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.conflict_opt S S1&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S1 T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conflict_opt0_conflict_opt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r_stgy S S1&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S1 T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>enc_weight_opt.cdcl_bnb_bj.resolve</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r_stgy.intros</span><span> </span><span>conflict_opt0_conflict_opt</span><span>
</span><span>      </span><span>rtranclp_cdcl_bnb_r_stgy_res</span><span> </span><span>cdcl_bnb_r_stgy_bt</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>5</span><span> </span><span>4</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r_stgy.intros</span><span> </span><span>conflict_opt0_conflict_opt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_bnb_r_stgy_cdcl_bnb_r</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r_stgy S T &#10233; cdcl_bnb_r S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r_stgy.simps</span><span> </span><span>cdcl_bnb_r.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_bnb_r_stgy_cdcl_bnb_r</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; cdcl_bnb_r<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r_stgy_cdcl_bnb_r</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;st</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S_&#931;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (init_clss S) = &#931; - &#916;&#931; &#8746; replacement_pos ` &#916;&#931; &#8746; replacement_neg ` &#916;&#931;&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_dpll_bnb_r_stgy_all_struct_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_dpll_bnb_r_stgy S T &#10233;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S) &#10233;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_dpll_bnb_r_stgy_cdcl_bnb_r_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>rtranclp_cdcl_bnb_r_all_struct_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S_&#931;</span><span class="delimiter">]</span><span>
</span><span>    </span><span>rtranclp_cdcl_bnb_r_stgy_cdcl_bnb_r</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_bnb_r_stgy_cdcl_dpll_bnb_r_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r_stgy S T &#10233; &#8707;T. cdcl_dpll_bnb_r_stgy S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cdcl_bnb_r_stgy.simps</span><span> </span><span>cdcl_dpll_bnb_r_conflict</span><span> </span><span>cdcl_dpll_bnb_r_conflict_opt0</span><span>
</span><span>    </span><span>cdcl_dpll_bnb_r_other&#39;</span><span> </span><span>cdcl_dpll_bnb_r_propagate</span><span> </span><span>cdcl_dpll_bnb_r_simple_backtrack_conflict_opt</span><span>
</span><span>    </span><span>cdcl_dpll_bnb_r_stgy.intros</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>no_step_conflict_opt0_simple_backtrack_conflict_opt</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;st</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S_&#931;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (init_clss S) = &#931; - &#916;&#931; &#8746; replacement_pos ` &#916;&#931; &#8746; replacement_neg ` &#916;&#931;&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_dpll_bnb_r_stgy_cdcl_bnb_r</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_dpll_bnb_r_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_r_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>T</span><span> </span><span>U</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_dpll_bnb_r_stgy_cdcl_bnb_r_stgy</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span> </span><span>U</span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_bnb_r_all_struct_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S_&#931;</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>      </span><span>rtranclp_cdcl_bnb_r_stgy_cdcl_bnb_r</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_dpll_bnb_r_stgy_all_struct_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_dpll_bnb_r_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S) &#10233;
    cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_dpll_bnb_r_stgy_cdcl_bnb_r</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>rtranclp_cdcl_bnb_r_all_struct_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>S_&#931;</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>rtranclp_cdcl_bnb_r_stgy_cdcl_bnb_r</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>full_cdcl_dpll_bnb_r_stgy_full_cdcl_bnb_r_stgy</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl_dpll_bnb_r_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl_bnb_r_stgy S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_step_cdcl_dpll_bnb_r_cdcl_bnb_r</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>rtranclp_cdcl_dpll_bnb_r_stgy_cdcl_bnb_r</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>    </span><span>rtranclp_cdcl_dpll_bnb_r_stgy_all_struct_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>      </span><span>rtranclp_cdcl_bnb_r_stgy_cdcl_bnb_r</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span>T</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>full_def</span><span>
</span><span>    </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_r_stgy_cdcl_bnb_r</span><span> </span><span>cdcl_bnb_r_stgy_cdcl_dpll_bnb_r_stgy</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>replace_pos_neg_not_both_decided_highest_lvl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_confl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dec0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>) &#8712; lits_of_l (trail S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dec1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>1</sup>) &#8712; lits_of_l (trail S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_constraints &#8838;# init_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; &#916;&#931;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) (Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>)) = backtrack_lvl S &#8743;
     get_level (trail S) (Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>1</sup>)) = backtrack_lvl S&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>neg</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;?thesis&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?L0</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) (Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?L1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) (Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>1</sup>))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>KL</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;KL = (if ?L0 &gt; ?L1 then (Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>1</sup>)) else (Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>)))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>KL&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;KL&#39; = (if ?L0 &gt; ?L1 then (Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>)) else (Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>1</sup>)))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) KL &lt; backtrack_lvl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?L0 &lt; backtrack_lvl S &#8744; ?L1 &lt; backtrack_lvl S&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?L0 &#8804; backtrack_lvl S &#8743; ?L1 &#8804; backtrack_lvl S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg</span><span> </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>1</sup>)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>KL_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;KL &#8712; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dec1</span><span> </span><span>dec0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>KL_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_constraint A &#8838;# init_clss S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset_set &#916;&#931;&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>additional_constraints_def</span><span>
</span><span>      </span><span>subset_mset.dual_order.trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M K M&#39; D L.
     trail S = M&#39; @ Decided K # M &#10233;
     D + {#L#} &#8712;# additional_constraint A &#10233; undefined_lit M L &#10233; &#172; M &#8872;as CNot D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>H&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M K M&#39; D L.
     trail S = M&#39; @ Decided K # M &#10233;
     D &#8712;# additional_constraint A &#10233;  &#172; M &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller_propa</span><span> </span><span>add</span><span> </span><span>smaller_confl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_smaller_propa_def</span><span> </span><span>no_smaller_confl_def</span><span> </span><span>clauses_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>L1_L0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?L1 = ?L0&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>neq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?L1 &#8800; ?L0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &#8801; min ?L1 ?L0&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided K # M1, M2) &#8712; set (get_all_ann_decomposition (trail S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) K = Suc i&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_ex_decomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_d</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>neq</span><span> </span><span>le</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?L1 &lt; ?L0&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>min_def</span><span> </span><span>i_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) KL &#8804; i&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) KL&#39; &gt; i&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg</span><span> </span><span>neq</span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>KL_def</span><span> </span><span>KL&#39;_def</span><span> </span><span>i_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M1 KL&#39;&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>decomp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) K = Suc i&#8250;</span></span></span><span>
</span><span>         </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1&#8250;</span></span></span><span> </span><span>KL&#39;</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span>  </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_append_if</span><span> </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>	</span><span>dest</span><span class="delimiter">:</span><span> </span><span>defined_lit_no_dupD</span><span>
</span><span>	</span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#-KL&#39;, -KL#} &#8712;# additional_constraint A&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>additional_constraint_def</span><span> </span><span>KL_def</span><span> </span><span>KL&#39;_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;KL &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) KL &#8804; i&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) K = Suc i&#8250;</span></span></span><span>
</span><span>       </span><span>n_d</span><span> </span><span>decomp</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;KL &#8712; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span>         </span><span>count_decided_ge_get_level</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M1&#8250;</span></span></span><span> </span><span>KL</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>get_level_append_if</span><span> </span><span>get_level_cons_if</span><span> </span><span>atm_of_eq_atm_of</span><span>
</span><span>	</span><span>dest</span><span class="delimiter">:</span><span> </span><span>defined_lit_no_dupD</span><span> </span><span>in_lits_of_l_defined_litD</span><span>
</span><span>	</span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#-KL#}&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-KL&#39;&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>decomp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided K # M1, M2) &#8712; set (get_all_ann_decomposition (trail S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) K = Suc ?L1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backtrack_ex_decomp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>n_d</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="var">?L1</span><span class="delimiter">]</span><span> </span><span>le</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?L1 &lt; ?L0&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>min_def</span><span> </span><span>L1_L0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>M3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S = M3 @ Decided K # M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M3 (Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>1</sup>))&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;undefined_lit M3 (Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>solves</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;use n_d L1_L0 lev_K M3 in auto&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>solves</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;use n_d L1_L0[symmetric] lev_K M3 in auto&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>) &#8713; lits_of_l M3&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>1</sup>) &#8713; lits_of_l M3&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>1</sup>) &#8712; lits_of_l M1&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>) &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_d</span><span> </span><span>L1_L0</span><span> </span><span>lev_K</span><span> </span><span>dec0</span><span> </span><span>dec1</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>get_all_ann_decomposition_exists_prepend</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>M3</span><span> </span><span>get_level_cons_if</span><span>
</span><span>	</span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>M3</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#Neg (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>0</sup>), Neg (A<span class="hidden">&#8679;</span><sup>&#8614;</sup><span class="hidden">&#8679;</span><sup>1</sup>)#}&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>additional_constraint_def</span><span> </span><span>M3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_dpll_bnb_r_stgy_clauses_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_dpll_bnb_r_stgy S T &#10233; clauses S &#8838;# clauses T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_dpll_bnb_r_stgy.cases</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span> </span><span>obacktrackE</span><span> </span><span>enc_weight_opt.improveE</span><span>
</span><span>         </span><span>conflict_opt0E</span><span> </span><span>simple_backtrack_conflict_optE</span><span> </span><span>odecideE</span><span>
</span><span>	 </span><span>enc_weight_opt.obacktrackE</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r.simps</span><span>  </span><span>enc_weight_opt.cdcl_bnb_bj.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_dpll_bnb_r_stgy_clauses_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_dpll_bnb_r_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; clauses S &#8838;# clauses T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl_dpll_bnb_r_stgy_clauses_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_dpll_bnb_r_stgy_init_clss_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_dpll_bnb_r_stgy S T &#10233; init_clss S = init_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_dpll_bnb_r_stgy.cases</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span> </span><span>obacktrackE</span><span> </span><span>enc_weight_opt.improveE</span><span>
</span><span>         </span><span>conflict_opt0E</span><span> </span><span>simple_backtrack_conflict_optE</span><span> </span><span>odecideE</span><span>
</span><span>	 </span><span>enc_weight_opt.obacktrackE</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_r.simps</span><span>  </span><span>enc_weight_opt.cdcl_bnb_bj.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_dpll_bnb_r_stgy_init_clss_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_dpll_bnb_r_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; init_clss S = init_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>cdcl_dpll_bnb_r_stgy_init_clss_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;st</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clauses&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S_&#931;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss S = penc N&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>replacement_pos_neg_defined_same_lvl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>A</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; &#916;&#931;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) (Pos (replacement_pos A)) &lt; backtrack_lvl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (replacement_pos A) &#8712; lits_of_l (trail S) &#10233;
      Neg (replacement_neg A) &#8712; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M K M&#39; D L.
        trail S = M&#39; @ Decided K # M &#10233;
        D + {#L#} &#8712;# additional_constraint A &#10233; undefined_lit M L &#10233; &#172; M &#8872;as CNot D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>H&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M K M&#39; D L.
        trail S = M&#39; @ Decided K # M &#10233;
        D &#8712;# additional_constraint A &#10233;  &#172; M &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller_propa</span><span> </span><span>S_&#931;</span><span> </span><span>A</span><span> </span><span>smaller_confl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_smaller_propa_def</span><span> </span><span>clauses_def</span><span> </span><span>penc_def</span><span>
</span><span>      </span><span>additional_constraints_def</span><span> </span><span>cdcl_bnb_stgy_inv_def</span><span> </span><span>no_smaller_confl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Neg (replacement_neg A) &#8712; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>Pos</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (replacement_pos A) &#8712; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S = M2 @ Decided K # M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (replacement_pos A) &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev</span><span> </span><span>n_d</span><span> </span><span>Pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>split_list</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>is_decided_ex_Decided</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>count_decided_def</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Neg (replacement_neg A) &#8712; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>M2</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#Neg (replacement_pos A)#}&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Neg (replacement_neg A)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>H&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>M2</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#Neg (replacement_pos A), Neg (replacement_neg A)#}&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>additional_constraint_def</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>replacement_pos_neg_defined_same_lvl&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>A</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; &#916;&#931;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) (Pos (replacement_neg A)) &lt; backtrack_lvl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (replacement_neg A) &#8712; lits_of_l (trail S) &#10233;
      Neg (replacement_pos A) &#8712; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M K M&#39; D L.
        trail S = M&#39; @ Decided K # M &#10233;
        D + {#L#} &#8712;# additional_constraint A &#10233; undefined_lit M L &#10233; &#172; M &#8872;as CNot D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>H&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M K M&#39; D L.
        trail S = M&#39; @ Decided K # M &#10233;
        D &#8712;# additional_constraint A &#10233;  &#172; M &#8872;as CNot D&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>smaller_propa</span><span> </span><span>S_&#931;</span><span> </span><span>A</span><span> </span><span>smaller_confl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>no_smaller_propa_def</span><span> </span><span>clauses_def</span><span> </span><span>penc_def</span><span>
</span><span>      </span><span>additional_constraints_def</span><span> </span><span>cdcl_bnb_stgy_inv_def</span><span> </span><span>no_smaller_confl_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Neg (replacement_pos A) &#8712; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>Pos</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (replacement_neg A) &#8712; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S = M2 @ Decided K # M1&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos (replacement_neg A) &#8712; lits_of_l M1&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev</span><span> </span><span>n_d</span><span> </span><span>Pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>split_list</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>is_decided_ex_Decided</span><span>
</span><span>        </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span> </span><span>count_decided_def</span><span> </span><span>filter_empty_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Neg (replacement_pos A) &#8712; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>of</span><span> </span><span>M2</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#Neg (replacement_neg A)#}&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Neg (replacement_pos A)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>H&#39;</span><span class="delimiter">[</span><span>of</span><span> </span><span>M2</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#Neg (replacement_neg A), Neg (replacement_pos A)#}&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>additional_constraint_def</span><span> </span><span>Decided_Propagated_in_iff_in_lits_of_l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>all_new_literals</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_new_literals = (SOME xs. mset xs = mset_set (replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;))&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_all_new_literals</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set all_new_literals = (replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_&#931;</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_new_literals_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>ex_mset</span><span> </span><span>finite_Un</span><span> </span><span>finite_&#931;</span><span> </span><span>finite_imageI</span><span> </span><span>finite_set_mset_mset_set</span><span> </span><span>set_mset_mset</span><span> </span><span>someI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This function is basically resolving the clause with all the additional clauses \&lt;^term&gt;&#8249;{#Neg (replacement_pos L), Neg (replacement_neg L)#}&#8250;.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>resolve_with_all_new_literals</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause &#8658; &#39;v list &#8658; &#39;v clause&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve_with_all_new_literals C [] = C&#8250;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;resolve_with_all_new_literals C (L # Ls) =
     remdups_mset (resolve_with_all_new_literals (if Pos L &#8712;# C then add_mset (Neg (opposite_var L)) (removeAll_mset (Pos L) C) else C) Ls)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>normalize2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;normalize2 C &#8801; resolve_with_all_new_literals C all_new_literals&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Neg_in_normalize2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Neg L &#8712;# C &#10233; Neg L &#8712;# resolve_with_all_new_literals C xs&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>resolve_with_all_new_literals.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pos_in_normalize2D</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos L &#8712;# resolve_with_all_new_literals C xs &#10233; Pos L &#8712;# C&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>resolve_with_all_new_literals.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>opposite_var_involutive</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; (replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;) &#10233; opposite_var (opposite_var L) = L&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>opposite_var_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Neg_in_resolve_with_all_new_literals_Pos_notin</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; (replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;) &#10233; set xs &#8838; (replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;) &#10233;
      Pos (opposite_var L) &#8713;# C &#10233; Neg L &#8712;# resolve_with_all_new_literals C xs &#10231; Neg L &#8712;# C&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>resolve_with_all_new_literals.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>p</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span class="delimiter">(</span><span>2</span><span>-</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>Neg_in_normalize2</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eq_commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;opposite_var _&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pos_in_normalize2_Neg_notin</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; (replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;) &#10233;
      Pos (opposite_var L) &#8713;# C &#10233; Neg L &#8712;# normalize2 C &#10231; Neg L &#8712;# C&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Neg_in_resolve_with_all_new_literals_Pos_notin</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_negation_deleted</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set all_new_literals &#10233; Pos L &#8713;# normalize2 C&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>resolve_with_all_new_literals.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pos_in_resolve_with_all_new_literals_iff_already_in_or_negation_in</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set all_new_literals &#10233;set xs &#8838; (replacement_neg ` &#916;&#931; &#8746; replacement_pos ` &#916;&#931;) &#10233; Neg L &#8712;# resolve_with_all_new_literals C xs&#10233;
    Neg L &#8712;# C &#8744; Pos (opposite_var L) &#8712;# C&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>resolve_with_all_new_literals.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span> </span><span>La</span><span> </span><span>Ls</span><span> </span><span>Ca</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Neg_in_resolve_with_all_new_literals_Pos_notin</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Pos_in_normalize2_iff_already_in_or_negation_in</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712; set all_new_literals &#10233;  Neg L &#8712;# normalize2 C &#10233;
    Neg L &#8712;# C &#8744; Pos (opposite_var L) &#8712;# C&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pos_in_resolve_with_all_new_literals_iff_already_in_or_negation_in</span><span class="delimiter">[</span><span>of</span><span> </span><span>L</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;all_new_literals&#8250;</span></span></span><span> </span><span>C</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This proof makes it hard to measure progress because I currently do not see a way to
distinguish between \&lt;^term&gt;&#8249;add_mset (replacement_pos A) C&#8250; and  \&lt;^term&gt;&#8249;add_mset (replacement_pos A)
  (add_mset (replacement_neg A) C)&#8250;. &#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;enc_weight_opt.cdcl_bnb_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (enc_weight_opt.abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (normalize_clause `# learned_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_propa</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_smaller_propa S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>smaller_confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (remdups_mset (normalize2 `# learned_clss T))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_bnb_conflict</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_bnb_propagate</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_bnb_improve</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>enc_weight_opt.improveE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_bnb_conflict_opt</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>enc_weight_opt.conflict_optE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_bnb_other&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>decide</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>bj</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>skip</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>resolve</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>backtrack</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, &#39;v clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>K</span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>D</span><span> </span><span>D&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>	</span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S = Some (add_mset L D)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>decomp</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(Decided K # M1, M2) &#8712; set (get_all_ann_decomposition (trail S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (trail S) (add_mset L D&#39;) = local.backtrack_lvl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) L = local.backtrack_lvl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>lev_K</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_level (trail S) K = Suc (get_maximum_level (trail S) D&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>D&#39;_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;D&#39; &#8838;# D&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (clauses S) &#8746; set_mset (enc_weight_opt.conflicting_clss S) &#8872;p
	 add_mset L D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;T &#8764;
	   cons_trail (Propagated L (add_mset L D&#39;))
	    (reduce_trail_to M1
	      (add_learned_cls (add_mset L D&#39;) (update_conflicting None S)))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>enc_weight_opt.obacktrack.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>tr_D</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot (add_mset L D)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (add_mset L D)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>	</span><span>n_d</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail S)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct</span><span> </span><span>confl</span><span>
</span><span>	</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>	  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_conflicting_def</span><span>
</span><span>	  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.distinct_cdcl<span class="hidden">&#8681;</span><sub>W</sub>_state_def</span><span>
</span><span>	  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tr_D&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot (add_mset L D&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D&#39;_D</span><span> </span><span>tr_D</span><span>
</span><span>	</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>true_annots_true_cls_def_iff_negation_in_model</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;as CNot D&#39; &#10233; trail S &#8872;as CNot (normalize2 D&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;get_maximum_level (trail S) D&#39; &lt; backtrack_lvl S&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>D&#39;</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*by induction on all the literals*)</span></span></span></span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>	</span><span class="keyword1"><span class="command">find_theorems</span></span><span> </span><span>get_level</span><span> </span><span>Pos</span><span> </span><span>Neg</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
	sorry
      have False
	if
	  C: &#8249;add_mset (normalize_lit L) (normalize_clause D&#39;) = normalize_clause C&#8250; and
	  &#8249;C &#8712;# learned_clss S&#8250;
	for C
      proof -
        obtain L&#39; C&#39; where
	  C_L&#39;_C&#39;[simp]: &#8249;C = add_mset L&#39; C&#39;&#8250; and
	  &#8249;normalize_clause C&#39; = normalize_clause D&#39;&#8250; and
	  [simp]: &#8249;normalize_lit L&#39; = normalize_lit L&#8250;
	  using C msed_map_invR[of &#8249;normalize_lit&#8250; C &#8249;normalize_lit L&#8250; &#8249;normalize_clause D&#39;&#8250;]
	  by auto
	have &#8249;trail S &#8872;as CNot C&#39;&#8250;
	  unfolding true_annots_true_cls_def_iff_negation_in_model
	proof
	  fix A
	  assume &#8249;A &#8712;# C&#39;&#8250;
	  then obtain A&#39; where
	    &#8249;A&#39; &#8712;# D&#39;&#8250; and
	    &#8249;normalize_lit A&#39; = normalize_lit A&#8250;
	    using &#8249;normalize_clause C&#39; = normalize_clause D&#39;&#8250;[symmetric]
	    by (force dest!: msed_map_invR multi_member_split)
	  then have &#8249;- A&#39; &#8712; lits_of_l (trail S)&#8250;
	    using tr_D&#39; by (auto dest: multi_member_split)
	  then have &#8249;-normalize_lit A&#39; &#8712; lits_of_l (trail S)&#8250;
	    apply (cases A&#39;)
	    apply auto
	    sorry
	  then show &#8249;- A &#8712; lits_of_l (trail S)&#8250;
	    sorry
	qed
        show False sorry
      qed
      then show ?thesis
        using dist T
        by (auto simp: enc_weight_opt.obacktrack.simps)
    qed
  qed
qed
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:25:56 AM CEST </td></tr></table></p><a href="https://imprint.mpi-klsb.mpg.de/mpi/mfleury">Imprint</a> / <a href="https://data-protection.mpi-klsb.mpg.de/mpi/mfleury">Data Protection</a></footer></div>

</html>


