<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory CDCL_W_Optimal_Model (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory CDCL_W_Optimal_Model</h1>

<span class="command">theory</span> <span class="name">CDCL_W_Optimal_Model</span><br/>
<span class="keyword">imports</span> <a href="CDCL_W_BnB.html"><span class="name">CDCL_W_BnB</span></a> <a href="Extended_Nat.html"><span class="name">Extended_Nat</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CDCL_W_Optimal_Model</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>CDCL_W_BnB</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Library.Extended_Nat&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;OCDCL&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  The following datatype is equivalent to \&lt;^typ&gt;&#8249;&#39;a option&#8250;. Howover, it has the opposite
  ordering. Therefore, I decided to use a different type instead of have a second order
  which conflicts with &#128463;&#8249;~~/src/HOL/Library/Option_ord.thy&#8250;.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">&#39;a</span><span> </span><span>optimal_model</span><span> </span><span class="delimiter">=</span><span> </span><span>Not_Found</span><span> </span><span class="delimiter">|</span><span> </span><span>is_found</span><span class="delimiter">:</span><span> </span><span>Found</span><span> </span><span class="delimiter">(</span><span>the_optimal</span><span class="delimiter">:</span><span> </span><span class="tfree">&#39;a</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>optimal_model</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>ord</span><span class="delimiter">)</span><span> </span><span>ord</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>less_optimal_model</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a :: ord optimal_model &#8658; &#39;a optimal_model &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;less_optimal_model Not_Found _ = False&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;less_optimal_model (Found _) Not_Found &#10231; True&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;less_optimal_model (Found a) (Found b) &#10231; a &lt; b&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>less_eq_optimal_model</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;a :: ord optimal_model &#8658; &#39;a optimal_model &#8658; bool&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;less_eq_optimal_model Not_Found Not_Found = True&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;less_eq_optimal_model Not_Found (Found _) = False&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;less_eq_optimal_model (Found _) Not_Found &#10231; True&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;less_eq_optimal_model (Found a) (Found b) &#10231; a &#8804; b&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>optimal_model</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>preorder</span><span class="delimiter">)</span><span> </span><span>preorder</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_le_not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>optimal_model</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>order</span><span class="delimiter">)</span><span> </span><span>order</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_le_not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span>optimal_model</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>linorder</span><span class="delimiter">)</span><span> </span><span>linorder</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>less_le_not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instantiation</span></span><span> </span><span>optimal_model</span><span> </span><span class="delimiter">::</span><span> </span><span class="delimiter">(</span><span>wellorder</span><span class="delimiter">)</span><span> </span><span>wellorder</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_less_optimal_model</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(M :: &#39;a optimal_model, N). M &lt; N}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{(M :: &#39;a optimal_model, N). M &lt; N} =
    map_prod Found Found ` {(M :: &#39;a, N). M &lt; N} &#8746;
    {(a, b). a &#8800; Not_Found &#8743; b = Not_Found}&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A = ?B &#8746; ?C&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>case_tac</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inj Found&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?B&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_map_prod_image</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>wf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf ?C&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wfI_pf</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf (?A)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_Un</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">instance</span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>standard</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CollectI</span><span> </span><span>split_conv</span><span> </span><span>wf_def</span><span> </span><span>wf_less_optimal_model</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;This locales includes only the assumption we make on the weight function.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>ocdcl_weight</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>&#961;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause &#8658; &#39;a :: {linorder}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>&#961;_mono</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset B &#10233; A &#8838;# B &#10233; &#961; A &#8804; &#961; B&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>&#961;_empty_simp</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset A)&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset A&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961; A &#8805; &#961; {#}&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;&#961; A &lt; &#961; {#}&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961; A &#8804; &#961; {#} &#10231; &#961; A = &#961; {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>&#961;_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{#}&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>&#961;&#39;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause option &#8658; &#39;a optimal_model&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961;&#39; w &#8801; (case w of None &#8658; Not_Found | Some w &#8658; Found (&#961; w))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_improving_int</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;v literal, &#39;v literal, &#39;b) annotated_lits &#8658; (&#39;v literal, &#39;v literal, &#39;b) annotated_lits &#8658; &#39;v clauses &#8658;
    &#39;v clause option &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving_int M M&#39; N w &#10231; Found (&#961; (lit_of `# mset M&#39;)) &lt; &#961;&#39; w &#8743;
    M&#39; &#8872;asm N &#8743; no_dup M&#39; &#8743;
    lit_of `# mset M&#39; &#8712; simple_clss (atms_of_mm N) &#8743;
    total_over_m (lits_of_l M&#39;) (set_mset N) &#8743;
    (&#8704;M&#39;. total_over_m (lits_of_l M&#39;) (set_mset N) &#10230; mset M &#8838;# mset M&#39; &#10230;
      lit_of `# mset M&#39; &#8712; simple_clss (atms_of_mm N) &#10230;
      &#961; (lit_of `# mset M&#39;) = &#961; (lit_of `# mset M))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>too_heavy_clauses</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clauses &#8658; &#39;v clause option &#8658; &#39;v clauses&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;too_heavy_clauses M w =
     {#pNeg C | C &#8712;# mset_set (simple_clss (atms_of_mm M)). &#961;&#39; w &#8804; Found (&#961; C)#}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>conflicting_clauses</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clauses &#8658; &#39;v clause option &#8658; &#39;v clauses&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting_clauses N w =
    {#C &#8712;# mset_set (simple_clss (atms_of_mm N)). too_heavy_clauses N w &#8872;pm C#}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>too_heavy_clauses_conflicting_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# too_heavy_clauses M w &#10233; C &#8712;# conflicting_clauses M w&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflicting_clauses_def</span><span> </span><span>too_heavy_clauses_def</span><span> </span><span>simple_clss_finite</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>too_heavy_clauses_contains_itself</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M &#8712; simple_clss (atms_of_mm N) &#10233; pNeg M &#8712;# too_heavy_clauses N (Some M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>too_heavy_clauses_def</span><span> </span><span>simple_clss_finite</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>too_heavy_clause_None</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;too_heavy_clauses M None = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>too_heavy_clauses_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atms_of_mm_too_heavy_clauses_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (too_heavy_clauses M I) &#8838; atms_of_mm M&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>too_heavy_clauses_def</span><span> </span><span>atms_of_ms_def</span><span> </span><span>simple_clss_finite</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>simple_clssE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>atms_too_heavy_clauses_None</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (too_heavy_clauses M None) = {}&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>atms_too_heavy_clauses_Some</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of w &#8838; atms_of_mm M  &#10233; distinct_mset w &#10233; &#172;tautology w &#10233;
      atms_of_mm (too_heavy_clauses M (Some w)) = atms_of_mm M&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (too_heavy_clauses M None) = {}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>too_heavy_clauses_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>atms</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of w &#8838; atms_of_mm M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>taut</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;tautology w&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (too_heavy_clauses M (Some w)) &#8838; atms_of_mm M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>too_heavy_clauses_def</span><span> </span><span>atms_of_ms_def</span><span> </span><span>simple_clss_finite</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?w</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w + Neg `# {#x &#8712;# mset_set (atms_of_mm M). x &#8713; atms_of w#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;inj_on Neg A&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset ?w&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_add</span><span> </span><span>distinct_image_mset_inj</span><span> </span><span>distinct_mset_mset_set</span><span> </span><span>uminus_lit_swap</span><span>
</span><span>      </span><span>disjunct_not_in</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_tauto</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;tautology ?w&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>tautology_union</span><span> </span><span>taut</span><span> </span><span>uminus_lit_swap</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?w &#8712; (simple_clss (atms_of_mm M))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961; ?w &#8805; &#961; w&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>&#961;_mono</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>dist</span><span> </span><span>not_tauto</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: consistent_interp_tuatology_mset_set tautology_decomp&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;pNeg ?w &#8712;# too_heavy_clauses M (Some w)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>too_heavy_clauses_def</span><span> </span><span>simple_clss_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm M &#8838; atms_of_mm (too_heavy_clauses M (Some w))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (too_heavy_clauses M (Some w)) = atms_of_mm M&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (too_heavy_clauses M (Some w)) &#8838; atms_of_mm M&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_too_heavy_clauses_too_heavy_clauses</span><span class="delimiter">:</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete"><a id="ocdcl-entails-conflicting"></a></span></span></span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp I&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m I (set_mset (too_heavy_clauses M w))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;I &#8872;m too_heavy_clauses M w&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>w</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &#8800; None &#10233; atms_of (the w) &#8838; atms_of_mm M&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &#8800; None &#10233; &#172;tautology (the w)&#8250;</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w &#8800; None &#10233; distinct_mset (the w)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;I &#8872;m conflicting_clauses M w&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{x &#8712; simple_clss (atms_of_mm M). tautology x} = {}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>simple_clssE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>None</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflicting_clauses_def</span><span> </span><span>true_clss_cls_tautology_iff</span><span>
</span><span>      </span><span>simple_clss_finite</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>w&#39;</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>w&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712;# mset_set (simple_clss (atms_of_mm M)) &#10233; total_over_set I (atms_of x)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span> </span><span>w</span><span> </span><span>atms_too_heavy_clauses_Some</span><span class="delimiter">[</span><span>of</span><span> </span><span>w&#39;</span><span> </span><span>M</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>w&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_over_m_def</span><span> </span><span>simple_clss_finite</span><span> </span><span>total_over_set_alt_def</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>simple_clssE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>true_cls_mset_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflicting_clauses_def</span><span> </span><span>true_clss_cls_def</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>I</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_entailed_too_heavy_clauses_ge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712; simple_clss (atms_of_mm N) &#10233; &#172; too_heavy_clauses N w &#8872;pm pNeg C &#10233; &#172;Found (&#961; C) &#8805; &#961;&#39; w&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_clss_cls_in</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;pNeg C&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (too_heavy_clauses N w)&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span>too_heavy_clauses_contains_itself</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>too_heavy_clauses_def</span><span> </span><span>simple_clss_finite</span><span>
</span><span>        </span><span>image_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conflicting_clss_incl_init_clauses</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (conflicting_clauses N w) &#8838; atms_of_mm (N)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clauses_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_def</span><span> </span><span>atms_of_ms_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_mset_mset_conflicting_clss2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset_mset (conflicting_clauses N w)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clauses_def</span><span> </span><span>distinct_mset_set_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_finite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>too_heavy_clauses_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961; a &gt; &#961; (lit_of `# mset M) &#10233; too_heavy_clauses N (Some a) &#8838;#
       too_heavy_clauses N (Some (lit_of `# mset M))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>too_heavy_clauses_def</span><span> </span><span>multiset_filter_mono2</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multiset_filter_mono</span><span> </span><span>image_mset_subseteq_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_improving_conflicting_clss_update_weight_information</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving_int M M&#39; N w &#10233;
       conflicting_clauses N w &#8838;# conflicting_clauses N (Some (lit_of `# mset M&#39;))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>too_heavy_clauses_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>M&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;the w&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;w&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_improving_int_def</span><span>  </span><span>conflicting_clauses_def</span><span> </span><span>multiset_filter_mono2</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>image_mset_subseteq_mono</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">:</span><span> </span><span>true_clss_cls_subset</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>simple_clssE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conflicting_clss_update_weight_information_in2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving_int M M&#39; N w&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_ann_lits M&#39; &#8712;# conflicting_clauses N (Some (lit_of `# mset M&#39;))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_finite</span><span>
</span><span>    </span><span>conflicting_clauses_def</span><span> </span><span>is_improving_int_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_improving_int_def</span><span> </span><span>conflicting_clauses_def</span><span>  </span><span>multiset_filter_mono2</span><span> </span><span>simple_clss_def</span><span>
</span><span>       </span><span>lits_of_def</span><span> </span><span>negate_ann_lits_pNeg_lit_of</span><span> </span><span>image_iff</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>total_over_m_atms_incl</span><span>
</span><span>      </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>true_clss_cls_in</span><span> </span><span>too_heavy_clauses_contains_itself</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atms_of_init_clss_conflicting_clauses&#39;</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm N &#8746; atms_of_mm (conflicting_clauses N S) = atms_of_mm N&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conflicting_clss_incl_init_clauses</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_too_heavy_clauses_if_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset I&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset I)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of I = atms_of_mm N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found (&#961; I) &lt; &#961;&#39; (Some M&#39;)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;m too_heavy_clauses N (Some M&#39;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;m too_heavy_clauses N (Some M&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_cls_mset_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# too_heavy_clauses N (Some M&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C = pNeg x&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8712; simple_clss (atms_of_mm N)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>we</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961; M&#39; &#8804; &#961; x&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>too_heavy_clauses_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_finite</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8800; I&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset x &#8800; set_mset I&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>distinct_set_mset_eq_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>I</span><span class="delimiter">]</span><span> </span><span>x</span><span> </span><span>dist</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8707;a. ((a &#8712;# x &#8743; a &#8713;# I) &#8744; (a &#8712;# I &#8743; a &#8713;# x))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_incl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;set_mset x &#8838; set_mset I&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>&#961;_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>I</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>we</span><span> </span><span>le</span><span> </span><span>distinct_set_mset_eq_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>I</span><span class="delimiter">]</span><span> </span><span>simple_clssE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>        </span><span>dist</span><span> </span><span>cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x &#8800; {#}&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>we</span><span> </span><span>le</span><span> </span><span>cons</span><span> </span><span>dist</span><span> </span><span>not_incl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>L_x</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8712;# x&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;L &#8713;# I&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of x &#8838; atms_of I&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>simple_clssE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>tot</span><span> </span><span>atm_iff_pos_or_neg_lit</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>I</span><span class="delimiter">]</span><span> </span><span>atm_iff_pos_or_neg_lit</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>x</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-L &#8712;# I&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span> </span><span>simple_clssE</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>atm_of_notin_atms_of_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872; C&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_finite</span><span> </span><span>pNeg_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_conflicting_clauses_if_le</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>M&#39;&#39;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; &#8801; lit_of `# mset M&#39;&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset I&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset I)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of I = atms_of_mm N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found (&#961; I) &lt; &#961;&#39; (Some M&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving_int M M&#39;&#39; N w&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;m conflicting_clauses N (Some (lit_of `# mset M&#39;&#39;))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>entails_too_heavy_clauses_too_heavy_clauses</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cons</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_improving_int_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_over_m_alt_def</span><span> </span><span>M&#39;_def</span><span> </span><span>atms_of_def</span><span> </span><span>lit_in_set_iff_atm</span><span>
</span><span>          </span><span>atms_too_heavy_clauses_Some</span><span> </span><span>eq_commute</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm N&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>simple_clssE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>assms</span><span>  </span><span>entails_too_heavy_clauses_if_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span>-</span><span>5</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto simp: M&#39;_def lits_of_def image_image is_improving_int_def dest!: simple_clssE&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>conflict_driven_clause_learning<span class="hidden">&#8681;</span><sub>W</sub>_optimal_weight</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>conflict_driven_clause_learning<span class="hidden">&#8681;</span><sub>W</sub></span><span>
</span><span>    </span><span>state_eq</span><span>
</span><span>    </span><span>state</span><span>
</span><span>    </span><span class="comment">&#8213; &#8249;functions for the state:&#8250;</span><span>
</span><span>      </span><span class="comment">&#8213; &#8249;access functions:&#8250;</span><span>
</span><span>    </span><span>trail</span><span> </span><span>init_clss</span><span> </span><span>learned_clss</span><span> </span><span>conflicting</span><span>
</span><span>      </span><span class="comment">&#8213; &#8249;changing state:&#8250;</span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span>tl_trail</span><span> </span><span>add_learned_cls</span><span> </span><span>remove_cls</span><span>
</span><span>    </span><span>update_conflicting</span><span>
</span><span>      </span><span class="comment">&#8213; &#8249;get state:&#8250;</span><span>
</span><span>    </span><span>init_state</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>ocdcl_weight</span><span> </span><span>&#961;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>    </span><span>state_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st &#8658; bool&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8764;&#8250;</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;st &#8658; (&#39;v, &#39;v clause) ann_lits &#215; &#39;v clauses &#215; &#39;v clauses &#215; &#39;v clause option &#215;
      &#39;v clause option &#215; &#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; (&#39;v, &#39;v clause) ann_lits&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_clss</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned_clss</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v clauses&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v clause option&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, &#39;v clause) ann_lit &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_learned_cls</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>remove_cls</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_conflicting</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause option &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clauses &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>&#961;</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause &#8658; &#39;a :: {linorder}&#8250;</span></span></span><span>  </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>update_additional_info</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v clause option &#215; &#39;b &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>update_additional_info</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state S = (M, N, U, C, K) &#10233; state (update_additional_info K&#39; S) = (M, N, U, C, K&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>weight_init_state</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;N :: &#39;v clauses. fst (additional_info (init_state N)) = None&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>update_weight_information</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;v, &#39;v clause) ann_lits &#8658; &#39;st &#8658; &#39;st&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_weight_information M S =
    update_additional_info (Some (lit_of `# mset M), snd (additional_info S)) S&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>trail_update_additional_info</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (update_additional_info w S) = trail S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>init_clss_update_additional_info</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss (update_additional_info w S) = init_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>learned_clss_update_additional_info</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss (update_additional_info w S) = learned_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>backtrack_lvl_update_additional_info</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_lvl (update_additional_info w S) = backtrack_lvl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>conflicting_update_additional_info</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (update_additional_info w S) = conflicting S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>clauses_update_additional_info</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses (update_additional_info w S) = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>update_additional_info</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clauses_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>state_prop</span><span class="delimiter">;</span><span> </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>state_prop</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>trail_update_weight_information</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail (update_weight_information w S) = trail S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>init_clss_update_weight_information</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss (update_weight_information w S) = init_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>learned_clss_update_weight_information</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;learned_clss (update_weight_information w S) = learned_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>backtrack_lvl_update_weight_information</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;backtrack_lvl (update_weight_information w S) = backtrack_lvl S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>conflicting_update_weight_information</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting (update_weight_information w S) = conflicting S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>clauses_update_weight_information</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clauses (update_weight_information w S) = clauses S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>update_additional_info</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>update_weight_information_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;st &#8658; &#39;v clause option&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight S = fst (additional_info S)&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>additional_info_update_additional_info</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;additional_info (update_additional_info w S) = w&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>additional_info_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>update_additional_info</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state S&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">;</span><span> </span><span>fail</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>weight_cons_trail2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (cons_trail L S) = weight S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>clss_tl_trail2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (tl_trail S) = weight S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>weight_add_learned_cls_unfolded</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (add_learned_cls U S) = weight S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>weight_update_conflicting2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (update_conflicting D S) = weight S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>weight_remove_cls2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (remove_cls C S) = weight S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>weight_add_learned_cls2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (add_learned_cls C S) = weight S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>weight_update_weight_information2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (update_weight_information M S) = Some (lit_of `# mset M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>update_weight_information_def</span><span> </span><span>weight_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>conflict_driven_clause_learning_with_adding_init_clause_bnb<span class="hidden">&#8681;</span><sub>W</sub>_no_state</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span>state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>trail</span><span> </span><span class="delimiter">=</span><span> </span><span>trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>init_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>learned_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>cons_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>tl_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_learned_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>add_learned_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>remove_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>remove_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>update_conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_state</span><span> </span><span class="delimiter">=</span><span> </span><span>init_state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>weight</span><span> </span><span class="delimiter">=</span><span> </span><span>weight</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_weight_information</span><span> </span><span class="delimiter">=</span><span> </span><span>update_weight_information</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>is_improving_int</span><span> </span><span class="delimiter">=</span><span> </span><span>is_improving_int</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting_clauses</span><span> </span><span class="delimiter">=</span><span> </span><span>conflicting_clauses</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>state_additional_info&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state S = (trail S, init_clss S, learned_clss S, conflicting S, weight S, additional_info&#39; S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>additional_info&#39;_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state S&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_prop</span><span> </span><span>weight_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>state_update_weight_information</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state S = (M, N, U, C, w, other) &#10233;
    &#8707;w&#39;. state (update_weight_information T S) = (M, N, U, C, w&#39;, other)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>update_weight_information_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;state S&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>state_prop</span><span> </span><span>weight_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atms_of_init_clss_conflicting_clauses</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (init_clss S) &#8746; atms_of_mm (conflicting_clss S) = atms_of_mm (init_clss S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conflicting_clss_incl_init_clauses</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(init_clss S)&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clss_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lit_of_trail_in_simple_clss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S) &#10233;
         lit_of `# mset (trail S) &#8712; simple_clss (atms_of_mm (init_clss S))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>abs_state_def</span><span>
</span><span>  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>atms_of_def</span><span> </span><span>pNeg_def</span><span> </span><span>lits_of_def</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_not_tautology</span><span> </span><span>no_dup_distinct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pNeg_lit_of_trail_in_simple_clss</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S) &#10233;
         pNeg (lit_of `# mset (trail S)) &#8712; simple_clss (atms_of_mm (init_clss S))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>abs_state_def</span><span>
</span><span>  </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>atms_of_def</span><span> </span><span>pNeg_def</span><span> </span><span>lits_of_def</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_not_tautology_uminus</span><span> </span><span>no_dup_distinct_uminus</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conflict_clss_update_weight_no_alien</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm (conflicting_clss (update_weight_information M S))
    &#8838; atms_of_mm (init_clss S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflicting_clss_def</span><span> </span><span>conflicting_clauses_def</span><span> </span><span>atms_of_ms_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>simple_clss_finite</span><span>
</span><span>    </span><span>dest</span><span class="delimiter">:</span><span> </span><span>simple_clssE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>state<span class="hidden">&#8681;</span><sub>W</sub>_no_state</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span>state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>trail</span><span> </span><span class="delimiter">=</span><span> </span><span>trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>init_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>learned_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>cons_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>tl_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_learned_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>add_learned_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>remove_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>remove_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>update_conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_state</span><span> </span><span class="delimiter">=</span><span> </span><span>init_state</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>state<span class="hidden">&#8681;</span><sub>W</sub>_no_state</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>state_eq</span><span> </span><span class="delimiter">=</span><span> </span><span>state_eq</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span>state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>trail</span><span> </span><span class="delimiter">=</span><span> </span><span>trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>init_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>learned_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>cons_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>tl_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_learned_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>add_learned_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>remove_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>remove_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>update_conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_state</span><span> </span><span class="delimiter">=</span><span> </span><span>init_state</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>conflict_driven_clause_learning<span class="hidden">&#8681;</span><sub>W</sub></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>state_eq</span><span> </span><span class="delimiter">=</span><span> </span><span>state_eq</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span>state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>trail</span><span> </span><span class="delimiter">=</span><span> </span><span>trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>init_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>learned_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>cons_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>tl_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_learned_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>add_learned_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>remove_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>remove_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>update_conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_state</span><span> </span><span class="delimiter">=</span><span> </span><span>init_state</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_improving_conflicting_clss_update_weight_information&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving M M&#39; S &#10233;
       conflicting_clss S &#8838;# conflicting_clss (update_weight_information M&#39; S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_improving_conflicting_clss_update_weight_information</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span>M&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight S&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clss_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conflicting_clss_update_weight_information_in2&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving M M&#39; S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;negate_ann_lits M&#39; &#8712;# conflicting_clss (update_weight_information M&#39; S)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conflicting_clss_update_weight_information_in2</span><span class="delimiter">[</span><span>of</span><span> </span><span>M</span><span> </span><span>M&#39;</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight S&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clss_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>conflict_driven_clause_learning_with_adding_init_clause_bnb<span class="hidden">&#8681;</span><sub>W</sub>_ops</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>state</span><span> </span><span class="delimiter">=</span><span> </span><span>state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>trail</span><span> </span><span class="delimiter">=</span><span> </span><span>trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>init_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>learned_clss</span><span> </span><span class="delimiter">=</span><span> </span><span>learned_clss</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>cons_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tl_trail</span><span> </span><span class="delimiter">=</span><span> </span><span>tl_trail</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>add_learned_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>add_learned_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>remove_cls</span><span> </span><span class="delimiter">=</span><span> </span><span>remove_cls</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_conflicting</span><span> </span><span class="delimiter">=</span><span> </span><span>update_conflicting</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>init_state</span><span> </span><span class="delimiter">=</span><span> </span><span>init_state</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>weight</span><span> </span><span class="delimiter">=</span><span> </span><span>weight</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>update_weight_information</span><span> </span><span class="delimiter">=</span><span> </span><span>update_weight_information</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>is_improving_int</span><span> </span><span class="delimiter">=</span><span> </span><span>is_improving_int</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>conflicting_clauses</span><span> </span><span class="delimiter">=</span><span> </span><span>conflicting_clauses</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_additional_info&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>state_update_weight_information</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clss_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conflicting_clss_incl_init_clauses</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clss_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>distinct_mset_mset_conflicting_clss2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_improving_conflicting_clss_update_weight_information&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conflicting_clss_update_weight_information_in2&#39;</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_cdcl_bnb_fixed</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S) &#8743; cdcl_bnb S T
      &#8743; init_clss S = N}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_cdcl_bnb</span><span class="delimiter">[</span><span>of</span><span> </span><span>N</span><span> </span><span>id</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{(I&#39;, I). I&#39; &#8800; None &#8743;
     (the I&#39;) &#8712; simple_clss (atms_of_mm N) &#8743; (&#961;&#39; I&#39;, &#961;&#39; I) &#8712; {(j, i). j &lt; i}}&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>S</span><span> </span><span>T</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight S&#8250;</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight T&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>improvep.simps</span><span> </span><span>is_improving_int_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>enat.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_finite_segments</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>irrefl_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>irrefl_def</span><span> </span><span>trans_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>less_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found _&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>less_trans</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found _&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found _&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;{y. (y, x)
         &#8712; {(I&#39;, I). I&#39; &#8800; None &#8743; the I&#39; &#8712; simple_clss (atms_of_mm N) &#8743;
            (&#961;&#39; I&#39;, &#961;&#39; I) &#8712; {(j, i). j &lt; i}}} =
        Some ` {y. (y, x) &#8712; {(I&#39;, I).
             I&#39; &#8712; simple_clss (atms_of_mm N) &#8743;
            (&#961;&#39; (Some I&#39;), &#961;&#39; I) &#8712; {(j, i). j &lt; i}}}&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>finite_image_iff</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>finite_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>simple_clss_finite</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_mm N&#8250;</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_cdcl_bnb2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;wf {(T, S). cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)
     &#8743; cdcl_bnb S T}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>wf_cdcl_bnb_fixed_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>wf_cdcl_bnb_fixed</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>can_always_improve</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;asm clauses S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>total</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (lits_of_l (trail S)) (set_mset (clauses S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n_s</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step conflict_opt S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>confl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>all_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)&#8250;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Ex (improvep S)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(lit_of `# mset (trail S)) &#8712;# mset_set (simple_clss (atms_of_mm (init_clss S)))&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(lit_of `# mset (trail S)) &#8712; simple_clss (atms_of_mm (init_clss S))&#8250;</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_dup (trail S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>finite_set_mset_mset_set</span><span class="delimiter">[</span><span>OF</span><span> </span><span>simple_clss_finite</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_struct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>        </span><span>no_strange_atm_def</span><span> </span><span>atms_of_def</span><span> </span><span>lits_of_def</span><span> </span><span>image_image</span><span>
</span><span>        </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span> </span><span>clauses_def</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_not_tautology</span><span> </span><span>no_dup_distinct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found (&#961; (lit_of `# mset (trail S))) &lt; &#961;&#39; (weight S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_s</span><span> </span><span>total</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflict_opt.simps</span><span> </span><span>conflicting_clss_def</span><span> </span><span>lits_of_def</span><span>
</span><span>         </span><span>conflicting_clauses_def</span><span> </span><span>clauses_def</span><span> </span><span>negate_ann_lits_pNeg_lit_of</span><span> </span><span>simple_clss_finite</span><span>
</span><span>       </span><span>dest</span><span class="delimiter">:</span><span> </span><span>not_entailed_too_heavy_clauses_ge</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tr</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S &#8872;asm init_clss S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (lits_of_l (trail S)) (set_mset (init_clss S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>total</span><span> </span><span>all_struct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span>
</span><span>       </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span>clauses_def</span><span> </span><span>no_strange_atm_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961; (lit_of `# mset M&#39;) = &#961; (lit_of `# mset (trail S))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (lits_of_l M&#39;) (set_mset (init_clss S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>incl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset (trail S) &#8838;# mset M&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lit_of `# mset M&#39; &#8712; simple_clss (atms_of_mm (init_clss S))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lits_of_l M&#39; = set_mset (lit_of `# mset M&#39;)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset M&#39; = A + mset (trail S)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>incl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>mset_subset_eq_exists_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>M&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;lits_of_l M&#39; = lit_of ` set_mset A &#8746; lits_of_l (trail S)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lits_of_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>A</span><span> </span><span>image_Un</span><span> </span><span>set_mset_mset</span><span> </span><span>set_mset_union</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset M&#39; = mset (trail S)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>tot&#39;</span><span> </span><span>total</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>A</span><span> </span><span>total_over_m_alt_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>A</span><span> </span><span>simple_clss_def</span><span> </span><span>distinct_mset_add</span><span> </span><span>M&#39;</span><span> </span><span>image_Un</span><span>
</span><span>            </span><span>tautology_union</span><span> </span><span>mset_inter_empty_set_mset</span><span> </span><span>atms_of_def</span><span> </span><span>atms_of_s_def</span><span>
</span><span>            </span><span>atm_of_in_atm_of_set_iff_in_set_or_uminus_in_set</span><span> </span><span>image_image</span><span>
</span><span>            </span><span>tautology_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>atm_of_in_atm_of_set_iff_in_set_or_uminus_in_set</span><span>
</span><span>           </span><span>subsetCE</span><span> </span><span>lits_of_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>total</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving (trail S) (trail S) S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found (&#961; (lit_of `# mset (trail S))) &lt; &#961;&#39; (weight S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>total</span><span> </span><span>H</span><span> </span><span>confl</span><span> </span><span>tr</span><span> </span><span>tot&#39;</span><span> </span><span>M&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_improving_int_def</span><span> </span><span>lits_of_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Ex (improvep S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>improvep.intros</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;trail S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;update_weight_information (trail S) S&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>le</span><span> </span><span>confl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_cdcl_bnb_stgy_empty_conflict2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>n_s</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_bnb S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>all_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>stgy_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting S = Some {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>no_step_cdcl_bnb_stgy_empty_conflict</span><span class="delimiter">[</span><span>OF</span><span> </span><span>can_always_improve</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_bnb_larger_still_larger</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb S T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961;&#39; (weight S) &#8805; &#961;&#39; (weight T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>improvep.simps</span><span> </span><span>is_improving_int_def</span><span> </span><span>conflict_opt.simps</span><span> </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span>
</span><span>      </span><span>cdcl_bnb_bj.simps</span><span> </span><span>skip.simps</span><span> </span><span>resolve.simps</span><span> </span><span>obacktrack.simps</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>obacktrack_model_still_model</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;obacktrack S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>all_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;sm clauses S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;sm conflicting_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset I&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset I)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of I = atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>opt_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found (&#961; I) &lt; &#961;&#39; (weight T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;sm clauses T &#8743; set_mset I &#8872;sm conflicting_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>obacktrack.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>obacktrack_rule</span><span> </span><span>L</span><span> </span><span>D</span><span> </span><span>K</span><span> </span><span>M1</span><span> </span><span>M2</span><span> </span><span>D&#39;</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>confl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>DD&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>clss_L_D&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m I (set_mset (clauses S + conflicting_clss S) &#8746; {add_mset L D&#39;}) &#10233;
      consistent_interp I &#10233;
      I &#8872;sm clauses S + conflicting_clss S &#10233; I &#8872; add_mset L D&#39;&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>I</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clss_L_D&#39;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_clss_cls_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (abs_state S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_struct</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (set_mset I) (set_mset (init_clss S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span> </span><span>atm_iff_pos_or_neg_lit</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (set_mset I) (set_mset (clauses S + conflicting_clss S) &#8746;
       {add_mset L D&#39;})&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span>T</span><span> </span><span>confl</span><span> </span><span>tot</span><span> </span><span>DD&#39;</span><span> </span><span>opt_struct</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>abs_state_def</span><span> </span><span>atms_of_def</span><span> </span><span>clauses_def</span><span>
</span><span>      </span><span>cdcl_bnb_struct_invs_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;sm conflicting_clss S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span> </span><span>cons</span><span> </span><span>ent</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872; add_mset L D&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>cons</span><span class="delimiter">]</span><span> </span><span>2</span><span> </span><span>ent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent</span><span> </span><span>obacktrack_rule</span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>entails_conflicting_clauses_if_le&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>M&#39;&#39;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M&#39; &#8801; lit_of `# mset M&#39;&#39;&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset I&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset I)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of I = atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found (&#961; I) &lt; &#961;&#39; (Some M&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;is_improving M M&#39;&#39; S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;N = init_clss S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;m conflicting_clauses N (weight (update_weight_information M&#39;&#39; S))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>entails_conflicting_clauses_if_le</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span>-</span><span>6</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>M&#39;_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clss_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>improve_model_still_model</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;improvep S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>all_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;sm clauses S&#8250;</span></span></span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;sm conflicting_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset I&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset I)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of I = atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>opt_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>le</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found (&#961; I) &lt; &#961;&#39; (weight T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;sm clauses T &#8743; set_mset I &#8872;sm conflicting_clss T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>improvep.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>improve_rule</span><span> </span><span>M&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>imp</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>confl</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>lev</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv (abs_state S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_struct</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>atm_trail</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of (lit_of `# mset (trail S)) &#8838; atms_of_mm (init_clss S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>alien</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_strange_atm_def</span><span> </span><span>lits_of_def</span><span> </span><span>atms_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (lit_of `# mset (trail S))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>taut2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; tautology (lit_of `# mset (trail S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lev</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_distinct</span><span> </span><span>no_dup_not_tautology</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (set_mset I) (set_mset (init_clss S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span> </span><span>atm_iff_pos_or_neg_lit</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>atm_trail</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of (lit_of `# mset M&#39;) &#8838; atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (lit_of `# mset M&#39;)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>taut2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; tautology (lit_of `# mset M&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>imp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>no_strange_atm_def</span><span> </span><span>lits_of_def</span><span> </span><span>atms_of_def</span><span> </span><span>is_improving_int_def</span><span>
</span><span>      </span><span>simple_clss_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (set_mset I) (set_mset (init_clss S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span> </span><span>atm_iff_pos_or_neg_lit</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;m conflicting_clauses (init_clss S) (weight (update_weight_information M&#39; S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>entails_conflicting_clauses_if_le&#39;</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>conflicting_clss_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T</span><span> </span><span>dist</span><span> </span><span>cons</span><span> </span><span>tot</span><span> </span><span>le</span><span> </span><span>imp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;m conflicting_clss (update_weight_information M&#39; S)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>update_weight_information_def</span><span> </span><span>conflicting_clss_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent</span><span> </span><span>improve_rule</span><span> </span><span>T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_bnb_still_model</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>all_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;sm clauses S&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;sm conflicting_clss S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset I&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset I)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of I = atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>opt_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_mset I &#8872;sm clauses T &#8743; set_mset I &#8872;sm conflicting_clss T) &#8744; Found (&#961; I) &#8805; &#961;&#39; (weight T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_improve</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>improve_model_still_model</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>all_struct</span><span> </span><span>ent</span><span> </span><span>dist</span><span> </span><span>cons</span><span> </span><span>tot</span><span> </span><span>opt_struct</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>improvep.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>cdcl_other&#39;</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o_all_rules_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backtrack</span><span> </span><span>T</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>obacktrack_model_still_model</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>all_struct</span><span> </span><span>ent</span><span> </span><span>dist</span><span> </span><span>cons</span><span> </span><span>tot</span><span> </span><span>opt_struct</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>ent</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;auto elim: rulesE&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflict_opt.simps</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>rulesE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_bnb_still_model</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>all_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_mset I &#8872;sm clauses S &#8743; set_mset I &#8872;sm conflicting_clss S) &#8744; Found (&#961; I) &#8805; &#961;&#39; (weight S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset I&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset I)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of I = atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>opt_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_struct_invs S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_mset I &#8872;sm clauses T &#8743; set_mset I &#8872;sm conflicting_clss T) &#8744; Found (&#961; I) &#8805; &#961;&#39; (weight T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>st</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>T</span><span> </span><span>U</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>star</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>st</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_bnb_stgy_all_struct_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>star</span><span> </span><span>all_struct</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_struct_invs T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_bnb_cdcl_bnb_struct_invs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>star</span><span> </span><span>opt_struct</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of I = atms_of_mm (init_clss T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span> </span><span>rtranclp_cdcl_bnb_no_more_init_clss</span><span class="delimiter">[</span><span>OF</span><span> </span><span>star</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cdcl_bnb_still_model</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span> </span><span>1</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>dist</span><span> </span><span>cons</span><span> </span><span>3</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span>IH</span><span>
</span><span>      </span><span>cdcl_bnb_larger_still_larger</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>full_cdcl_bnb_stgy_larger_or_equal_weight</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl_bnb_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>all_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set_mset I &#8872;sm clauses S &#8743; set_mset I &#8872;sm conflicting_clss S) &#8744; Found (&#961; I) &#8805; &#961;&#39; (weight S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset I&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset I)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of I = atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>opt_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>stgy_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Found (&#961; I) &#8805; &#961;&#39; (weight T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (clauses T + conflicting_clss T))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_bnb_stgy T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>st&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp_cdcl_bnb_stgy_cdcl_bnb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ns&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_bnb T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cdcl_bnb.cases</span><span> </span><span>cdcl_bnb_stgy.simps</span><span> </span><span>no_confl_prop_impr.elims</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ns</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_bnb_stgy_all_struct_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st&#39;</span><span> </span><span>all_struct</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>stgy_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_bnb_stgy_stgy_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span> </span><span>all_struct</span><span> </span><span>stgy_inv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting T = Some {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_step_cdcl_bnb_stgy_empty_conflict2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ns&#39;</span><span> </span><span>struct_T</span><span> </span><span>stgy_T</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause (abs_state T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (abs_state T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ent&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (clauses T + conflicting_clss T) &#8872;p {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause_alt_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>atms_eq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of I &#8746; atms_of_mm (conflicting_clss T) = atms_of_mm (init_clss T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>atms_of_conflicting_clss</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>alien</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rtranclp_cdcl_bnb_no_more_init_clss</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st&#39;</span><span class="delimiter">]</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span> </span><span>atm_iff_pos_or_neg_lit</span><span>
</span><span>      </span><span>abs_state_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172; (set_mset I &#8872;sm clauses T + conflicting_clss T)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ent&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset I &#8872;sm clauses T + conflicting_clss T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (set_mset I) (set_mset (clauses T + conflicting_clss T))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tot</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>atms_of_conflicting_clss</span><span class="delimiter">[</span><span>of</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>alien</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>rtranclp_cdcl_bnb_no_more_init_clss</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st&#39;</span><span class="delimiter">]</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>clauses_def</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span> </span><span>atm_iff_pos_or_neg_lit</span><span>
</span><span>              </span><span>abs_state_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>atms_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent&#39;</span><span> </span><span>cons</span><span> </span><span>ent&#39;&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_clss_cls_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961;&#39; (weight T) &#8804; Found (&#961; I)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_bnb_still_model</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st&#39;</span><span> </span><span>all_struct</span><span> </span><span>ent</span><span> </span><span>dist</span><span> </span><span>cons</span><span> </span><span>tot</span><span> </span><span>opt_struct</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (clauses T + conflicting_clss T))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;satisfiable (set_mset (clauses T + conflicting_clss T))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>ent&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;I &#8872;sm clauses T + conflicting_clss T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m I (set_mset (clauses T + conflicting_clss T))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp I&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>satisfiable_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;False&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent&#39;</span><span> </span><span>cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_clss_cls_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>full_cdcl_bnb_stgy_unsat2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl_bnb_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>all_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>opt_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>stgy_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (clauses T + conflicting_clss T))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ns</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_bnb_stgy T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>st&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtranclp_cdcl_bnb_stgy_cdcl_bnb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ns&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;no_step cdcl_bnb T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cdcl_bnb.cases</span><span> </span><span>cdcl_bnb_stgy.simps</span><span> </span><span>no_confl_prop_impr.elims</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ns</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>struct_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_bnb_stgy_all_struct_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st&#39;</span><span> </span><span>all_struct</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>stgy_T</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_bnb_stgy_stgy_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span> </span><span>all_struct</span><span> </span><span>stgy_inv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>confl</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting T = Some {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_step_cdcl_bnb_stgy_empty_conflict2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ns&#39;</span><span> </span><span>struct_T</span><span> </span><span>stgy_T</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause (abs_state T)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>alien</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm (abs_state T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>struct_T</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ent&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set_mset (clauses T + conflicting_clss T) &#8872;p {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>confl</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clause_alt_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (clauses T + conflicting_clss T))&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;satisfiable (set_mset (clauses T + conflicting_clss T))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>I</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>ent&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;I &#8872;sm clauses T + conflicting_clss T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>tot</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m I (set_mset (clauses T + conflicting_clss T))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp I&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>satisfiable_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;False&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_clss_cls_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_init_state2</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight (init_state S) = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>conflicting_clss_init_state</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting_clss (init_state N) = {#}&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>weight_def</span><span> </span><span>conflicting_clss_def</span><span> </span><span>conflicting_clauses_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>weight_init_state</span><span> </span><span>true_clss_cls_tautology_iff</span><span> </span><span>simple_clss_finite</span><span>
</span><span>    </span><span>filter_mset_empty_conv</span><span> </span><span>mset_set_empty_iff</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>simple_clssE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;First part of \cwref{theo:prop:cdclmmcorrect}{Theorem 2.15.6}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>full_cdcl_bnb_stgy_no_conflicting_clause_unsat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl_bnb_stgy S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>all_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>opt_struct</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_struct_invs S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>stgy_inv</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight T = None&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;unsatisfiable (set_mset (init_clss S))&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;conflicting_clss T = {#}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ent</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init_def</span><span> </span><span>abs_state_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span>
</span><span>      </span><span>conflicting_clss_def</span><span> </span><span>conflicting_clauses_def</span><span> </span><span>true_clss_cls_tautology_iff</span><span> </span><span>simple_clss_finite</span><span>
</span><span>      </span><span>filter_mset_empty_conv</span><span> </span><span>mset_set_empty_iff</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>simple_clssE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>full_cdcl_bnb_stgy_no_conflicting_clss_unsat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>st</span><span> </span><span>all_struct</span><span>
</span><span>     </span><span>stgy_inv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>can_always_improve</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>annotation_is_model</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;annotation_is_model S &#10231;
     (weight S &#8800; None &#10230; (set_mset (the (weight S)) &#8872;sm init_clss S &#8743;
       consistent_interp (set_mset (the (weight S))) &#8743;
       atms_of (the (weight S)) &#8838; atms_of_mm (init_clss S) &#8743;
       total_over_m (set_mset (the (weight S))) (set_mset (init_clss S)) &#8743;
       distinct_mset (the (weight S))))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cdcl_bnb_annotation_is_model</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb S T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;annotation_is_model S&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;annotation_is_model T&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of (lit_of `# mset M) = atm_of ` lit_of ` set M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>M</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atms_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (lits_of_l (trail S)) &#8743;
       atm_of ` (lits_of_l (trail S)) &#8838; atms_of_mm (init_clss S) &#8743;
       distinct_mset (lit_of `# mset (trail S))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span>
</span><span>      </span><span>abs_state_def</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset_state</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.no_strange_atm_def</span><span>
</span><span>      </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_M_level_inv_def</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">:</span><span> </span><span>no_dup_distinct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflict.simps</span><span> </span><span>annotation_is_model_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>propagate.simps</span><span> </span><span>annotation_is_model_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>annotation_is_model_def</span><span> </span><span>true_annots_true_cls</span><span> </span><span>lits_of_def</span><span>
</span><span>             </span><span>improvep.simps</span><span> </span><span>is_improving_int_def</span><span> </span><span>image_Un</span><span> </span><span>image_image</span><span> </span><span>simple_clss_def</span><span>
</span><span>             </span><span>consistent_interp_tuatology_mset_set</span><span>
</span><span>           </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>consistent_interp_unionD</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>annotation_is_model_def</span><span> </span><span>conflict_opt.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>annotation_is_model_def</span><span>
</span><span>              </span><span>ocdcl<span class="hidden">&#8681;</span><sub>W</sub>_o.simps</span><span> </span><span>cdcl_bnb_bj.simps</span><span> </span><span>obacktrack.simps</span><span>
</span><span>              </span><span>skip.simps</span><span> </span><span>resolve.simps</span><span> </span><span>decide.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_cdcl_bnb_annotation_is_model</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> S T &#10233; cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state S) &#10233;
     annotation_is_model S &#10233; annotation_is_model T&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtranclp_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_annotation_is_model</span><span> </span><span>rtranclp_cdcl_bnb_stgy_all_struct_inv</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;\cwref{theo:prop:cdclmmcorrect}{Theorem 2.15.6}&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>full_cdcl_bnb_stgy_no_conflicting_clause_from_init_state</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;full cdcl_bnb_stgy (init_state N) T&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset_mset N&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight T = None &#10233; unsatisfiable (set_mset N)&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?B &#10233; ?A&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight T &#8800; None &#10233; consistent_interp (set_mset (the (weight T))) &#8743;
       atms_of (the (weight T)) &#8838; atms_of_mm N &#8743; set_mset (the (weight T)) &#8872;sm N &#8743;
       total_over_m (set_mset (the (weight T))) (set_mset N) &#8743;
       distinct_mset (the (weight T))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset I &#10233; consistent_interp (set_mset I) &#10233; atms_of I = atms_of_mm N &#10233;
      set_mset I &#8872;sm N &#10233; Found (&#961; I) &#8805; &#961;&#39; (weight T)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?S</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_state N&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset C&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;C &#8712;# N&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>C</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_set_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>multi_member_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset_mset N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_set_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv ([], N, {#}, None)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>init_state.simps</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_struct_invs ?S&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl_bnb_stgy_inv ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl_bnb_struct_invs_def</span><span> </span><span>conflict_is_false_with_level_def</span><span> </span><span>cdcl_bnb_stgy_inv_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ent</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>cdcl<span class="hidden">&#8681;</span><sub>W</sub>_learned_clauses_entailed_by_init_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cdcl<span class="hidden">&#8681;</span><sub>W</sub>_restart_mset.cdcl<span class="hidden">&#8681;</span><sub>W</sub>_all_struct_inv (abs_state (init_state N))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CDCL_W_Abstract_State.init_state.simps</span><span> </span><span>abs_state_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight T = None &#10233; unsatisfiable (set_mset N)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>full_cdcl_bnb_stgy_no_conflicting_clause_unsat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>st</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;annotation_is_model ?S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>annotation_is_model_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;annotation_is_model T&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_bnb_annotation_is_model</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?S</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>st</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>rtranclp_cdcl_bnb_stgy_cdcl_bnb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;init_clss T = N&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rtranclp_cdcl_bnb_no_more_init_clss</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?S</span><span> </span><span>T</span><span class="delimiter">]</span><span> </span><span>st</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>rtranclp_cdcl_bnb_stgy_cdcl_bnb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;weight T &#8800; None &#10233; consistent_interp (set_mset (the (weight T))) &#8743;
       atms_of (the (weight T)) &#8838; atms_of_mm N &#8743; set_mset (the (weight T)) &#8872;sm N &#8743;
       total_over_m (set_mset (the (weight T))) (set_mset N) &#8743;
       distinct_mset (the (weight T))&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>annotation_is_model_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset I &#10233; consistent_interp (set_mset I) &#10233; atms_of I = atms_of_mm N &#10233;
      set_mset I &#8872;sm N &#10233; Found (&#961; I) &#8805; &#961;&#39; (weight T)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>full_cdcl_bnb_stgy_larger_or_equal_weight</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?S</span><span> </span><span>T</span><span> </span><span>I</span><span class="delimiter">]</span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>full_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pruned_clause_in_conflicting_clss</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ge</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;M&#39;. total_over_m (set_mset (mset (M @ M&#39;))) (set_mset (init_clss S)) &#10233;
      distinct_mset (atm_of `# mset (M @ M&#39;)) &#10233;
      consistent_interp (set_mset (mset (M @ M&#39;))) &#10233;
      Found (&#961; (mset (M @ M&#39;))) &#8805; &#961;&#39; (weight S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>atm</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of (mset M) &#8838; atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct M&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set M)&#8250;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;pNeg (mset M) &#8712;# conflicting_clss S&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(pNeg o mset o ((@) M))` {M&#39;.
      distinct_mset (atm_of `# mset (M @ M&#39;)) &#8743; consistent_interp (set_mset (mset (M @ M&#39;))) &#8743;
      atms_of_s (set (M @ M&#39;)) &#8838; (atms_of_mm (init_clss S)) &#8743;
      card (atms_of_mm (init_clss S)) = n + card (atms_of (mset (M @ M&#39;)))} &#8838;
    set_mset (conflicting_clss S)&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ ` ?A n &#8838; ?H&#8250;</span></span></span><span class="delimiter">)</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xa</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>xb</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xc</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal list&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>        </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (atm_of `# mset (M @ xc))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset (mset (M @ xc)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>atm&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_s (set (M @ xc)) &#8838; atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card (atms_of_mm (init_clss S)) = 0 + card (atms_of (mset (M @ xc)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>D</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; set M &#10233; A &#8713; set xc&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A &#8712; set M &#10233; -A &#8713; set xc&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset M&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-A&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset xc&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;-A&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset M&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>multi_member_split</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;A&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset xc&#8250;</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atm_of_in_atm_of_set_iff_in_set_or_uminus_in_set</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct xc&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (atm_of `# mset xc)&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (mset M + mset xc)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>distinct_mset_atm_ofD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dist</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mset_append</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>distinct_mset_mset_distinct</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union2</span><span> </span><span>distinct_mset_atm_ofD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card (atms_of_s (set M) &#8746; atms_of_s (set xc)) =
        card (atms_of_s (set M)) + card (atms_of_s (set xc))&#8250;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>card_Un_Int</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?M</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;M @ xc&#8250;</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>H1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_s (set ?M) = atms_of_mm (init_clss S)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span>atm</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>atm&#39;</span><span class="delimiter">]</span><span> </span><span>card_subset_eq</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>atm&#39;</span><span class="delimiter">]</span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atms_of_s_def</span><span> </span><span>image_Un</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (set ?M) (set_mset (init_clss S))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span> </span><span>lit_in_set_iff_atm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;tautology (mset ?M)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_interp_tautology</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;mset ?M &#8712; simple_clss (atms_of_mm (init_clss S))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>atm</span><span> </span><span>cons</span><span> </span><span>H1</span><span> </span><span>dist2</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_def</span><span> </span><span>consistent_interp_tautology</span><span> </span><span>atms_of_s_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tot2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;total_over_m (set ?M) (set_mset (init_clss S))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>H1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_over_m_def</span><span> </span><span>total_over_set_def</span><span> </span><span>lit_in_set_iff_atm</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(pNeg &#8728; mset &#8728; (@) M) xc &#8712;# conflicting_clss S&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ge</span><span class="delimiter">[</span><span>of</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xc&#8250;</span></span></span><span class="delimiter">]</span><span> </span><span>dist</span><span> </span><span>0</span><span> </span><span>cons</span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>atm</span><span class="delimiter">]</span><span> </span><span>tot2</span><span> </span><span>cons</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>conflicting_clss_def</span><span> </span><span>too_heavy_clauses_def</span><span> </span><span>simple_clss_finite</span><span>
</span><span>            </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>too_heavy_clauses_conflicting_clauses</span><span> </span><span>imageI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?H</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?A n&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xa</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal multiset&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>xb</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal list&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xc</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;v literal list&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>        </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (atm_of `# mset (M @ xc))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>cons</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_interp (set_mset (mset (M @ xc)))&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>atm&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;atms_of_s (set (M @ xc)) &#8838; atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>0</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;card (atms_of_mm (init_clss S)) = Suc n + card (atms_of (mset (M @ xc)))&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>a</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8712; atms_of_mm (init_clss S)&#8250;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a_notin</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;a &#8713; atms_of_s (set (M @ xc))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_n_not_le_n</span><span> </span><span>add_Suc_shift</span><span> </span><span>atms_of_mmltiset</span><span> </span><span>atms_of_s_def</span><span> </span><span>le_add2</span><span>
</span><span>            </span><span>subsetI</span><span> </span><span>subset_antisym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dist2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct xc&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (atm_of `# mset xc)&#8250;</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;distinct_mset (mset M + mset xc)&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>distinct_mset_atm_ofD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dist</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mset_append</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>distinct_mset_mset_distinct</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>distinct_mset_union2</span><span> </span><span>distinct_mset_atm_ofD</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?xc1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Pos a # xc&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?xc2</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Neg a # xc&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?xc1 &#8712; ?H&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>cons</span><span> </span><span>atm&#39;</span><span> </span><span>0</span><span> </span><span>dist2</span><span> </span><span>a_notin</span><span> </span><span>a</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_add</span><span> </span><span>mset_inter_empty_set_mset</span><span>
</span><span>            </span><span>lit_in_set_iff_atm</span><span> </span><span>card_insert_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>set_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IH</span><span> </span><span>imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;too_heavy_clauses (init_clss S) (weight S) &#8872;pm add_mset (-(Pos a)) (pNeg (mset (M @ xc)))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clss_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clauses_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pNeg_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;?xc2 &#8712; ?H&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dist</span><span> </span><span>cons</span><span> </span><span>atm&#39;</span><span> </span><span>0</span><span> </span><span>dist2</span><span> </span><span>a_notin</span><span> </span><span>a</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>distinct_mset_add</span><span> </span><span>mset_inter_empty_set_mset</span><span>
</span><span>            </span><span>lit_in_set_iff_atm</span><span> </span><span>card_insert_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>set_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>IH</span><span> </span><span>imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;too_heavy_clauses (init_clss S) (weight S) &#8872;pm add_mset (Pos a) (pNeg (mset (M @ xc)))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clss_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clauses_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>pNeg_simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;tautology (mset (M @ xc))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_interp_tautology</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#172;tautology (pNeg (mset M) + pNeg (mset xc))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mset_append</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>pNeg_simps</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>mset_append</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;pNeg (mset M) + pNeg (mset xc) &#8712; simple_clss (atms_of_mm (init_clss S))&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>atm&#39;</span><span> </span><span>dist2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_def</span><span> </span><span>atms_of_s_def</span><span> </span><span>simp</span><span> </span><span>flip</span><span class="delimiter">:</span><span> </span><span>pNeg_simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(pNeg &#8728; mset &#8728; (@) M) xc &#8712;# conflicting_clss S&#8250;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>true_clss_cls_or_true_clss_cls_or_not_true_clss_cls_or</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conflicting_clss_def</span><span> </span><span>conflicting_clauses_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>true_clss_cls_remdups_mset</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>simple_clss_finite</span><span> </span><span>pNeg_simps</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>true_clss_cls_cong_set_mset</span><span>
</span><span>            </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>true_clss_cls_remdups_mset</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;[] &#8712; {M&#39;.
     distinct_mset (atm_of `# mset (M @ M&#39;)) &#8743;
     consistent_interp (set_mset (mset (M @ M&#39;))) &#8743;
     atms_of_s (set (M @ M&#39;)) &#8838; atms_of_mm (init_clss S) &#8743;
     card (atms_of_mm (init_clss S)) =
     card (atms_of_mm (init_clss S)) - card (atms_of (mset M)) +
     card (atms_of (mset (M @ M&#39;)))}&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>card_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>card_mono</span><span> </span><span>distinct_consistent_distinct_atm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>set_mp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>0</span><span> </span><span>imageI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;pNeg (mset M) &#8712;# conflicting_clss S&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
<div class=body><footer><p><table border=0  width=700> <tr><th>Isabelle version:</th><th>AFP version:</th><th>IsaFoL version:</th><th>Last compilation:</th></tr>

<tr><td align="center">Isabelle2020 </td><td align="center">6b713b029127 </td><td align="center">6e93a5c7 </td><td align="center">Sat 25 Apr 2020 09:25:56 AM CEST </td></tr></table></p></footer></div>

</html>


